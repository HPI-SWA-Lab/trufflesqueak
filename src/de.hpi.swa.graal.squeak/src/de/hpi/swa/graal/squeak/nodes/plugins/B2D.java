package de.hpi.swa.graal.squeak.nodes.plugins;

import com.oracle.truffle.api.CompilerDirectives;

import de.hpi.swa.graal.squeak.exceptions.PrimitiveExceptions.PrimitiveFailed;
import de.hpi.swa.graal.squeak.exceptions.SqueakExceptions.SqueakException;
import de.hpi.swa.graal.squeak.model.AbstractSqueakObject;
import de.hpi.swa.graal.squeak.model.ArrayObject;
import de.hpi.swa.graal.squeak.model.ClassObject;
import de.hpi.swa.graal.squeak.model.FloatObject;
import de.hpi.swa.graal.squeak.model.NativeObject;
import de.hpi.swa.graal.squeak.model.PointersObject;
import de.hpi.swa.graal.squeak.nodes.SqueakGuards;

/* Automatically generated by
    VMPluginCodeGenerator * VMMaker.oscog-eem.2480 uuid: bb3ffda7-8241-4dea-b886-d656e474b6c1
   from
    BalloonEnginePlugin * VMMaker.oscog-eem.2480 uuid: bb3ffda7-8241-4dea-b886-d656e474b6c1
 */

public final class B2D {

    /* Constants */
    private static final int BEBalloonEngineSize = 12;
    private static final int BEBitBltIndex = 2;
    private static final int BEFormsIndex = 3;
    private static final int BESpanIndex = 1;
    private static final int BEWorkBufferIndex = 0;
    private static final int ETBalloonEdgeDataSize = 6;
    private static final int ETIndexIndex = 0;
    private static final int ETLinesIndex = 4;
    private static final int ETXValueIndex = 1;
    private static final int ETYValueIndex = 2;
    private static final int ETZValueIndex = 3;
    private static final int FTBalloonFillDataSize = 6;
    private static final int FTIndexIndex = 0;
    private static final int FTMaxXIndex = 2;
    private static final int FTMinXIndex = 1;
    private static final int FTYValueIndex = 3;
    private static final int GBBaseSize = 16;
    private static final int GBBitmapDepth = 12;
    private static final int GBBitmapHeight = 11;
    private static final int GBBitmapRaster = 14;
    private static final int GBBitmapSize = 13;
    private static final int GBBitmapWidth = 10;
    private static final int GBColormapOffset = 18;
    private static final int GBColormapSize = 15;
    private static final int GBEndX = 14;
    private static final int GBEndY = 15;
    private static final int GBFinalX = 21;
    private static final int GBMBaseSize = 18;
    private static final int GBTileFlag = 16;
    private static final int GBUpdateData = 10;
    private static final int GBUpdateDDX = 4;
    private static final int GBUpdateDDY = 5;
    private static final int GBUpdateDX = 2;
    private static final int GBUpdateDY = 3;
    private static final int GBUpdateX = 0;
    private static final int GBUpdateY = 1;
    private static final int GBViaX = 12;
    private static final int GBViaY = 13;
    private static final int GBWideEntry = 18;
    private static final int GBWideExit = 19;
    private static final int GBWideExtent = 20;
    private static final int GBWideFill = 16;
    private static final int GBWideSize = 28;
    private static final int GBWideUpdateData = 22;
    private static final int GBWideWidth = 17;
    private static final int GEBaseEdgeSize = 10;
    private static final int GEBaseFillSize = 4;
    private static final int GEEdgeFillsInvalid = 0x10000;
    private static final int GEFAlreadyFailed = 100;
    private static final int GEFBadPoint = 121;
    // private static final int GEFBitBltLoadFailed = 122;
    private static final int GEFClassMismatch = 114;
    private static final int GEFEdgeDataTooSmall = 112;
    // private static final int GEFEngineIsInteger = 101;
    // private static final int GEFEngineIsWords = 102;
    private static final int GEFEngineStopped = 104;
    private static final int GEFEngineTooSmall = 103;
    private static final int GEFEntityCheckFailed = 120;
    private static final int GEFEntityLoadFailed = 119;
    private static final int GEFFillDataTooSmall = 113;
    private static final int GEFFormLoadFailed = 123;
    private static final int GEFillIndexLeft = 8;
    private static final int GEFillIndexRight = 9;
    private static final int GEFSizeMismatch = 115;
    private static final int GEFWorkBufferBadMagic = 108;
    // private static final int GEFWorkBufferIsInteger = 105;
    private static final int GEFWorkBufferIsPointers = 106;
    private static final int GEFWorkBufferStartWrong = 110;
    private static final int GEFWorkBufferTooSmall = 107;
    private static final int GEFWorkBufferWrongSize = 109;
    private static final int GEFWorkTooBig = 111;
    private static final int GEFWrongEdge = 118;
    private static final int GEFWrongFill = 117;
    private static final int GEFWrongState = 116;
    private static final int GENumLines = 7;
    private static final int GEObjectIndex = 2;
    private static final int GEObjectLength = 1;
    private static final int GEObjectType = 0;
    private static final int GEPrimitiveBezier = 6;
    private static final int GEPrimitiveClippedBitmapFill = 0x400;
    private static final int GEPrimitiveEdge = 2;
    private static final int GEPrimitiveEdgeMask = 0xFF;
    private static final int GEPrimitiveFill = 0x100;
    private static final int GEPrimitiveFillMask = 0xFF00;
    private static final int GEPrimitiveLine = 4;
    private static final int GEPrimitiveLinearGradientFill = 0x200;
    private static final int GEPrimitiveRadialGradientFill = 0x300;
    private static final int GEPrimitiveTypeMask = 0xFFFF;
    private static final int GEPrimitiveWide = 1;
    private static final int GEPrimitiveWideBezier = 7;
    private static final int GEPrimitiveWideLine = 5;
    private static final int GEPrimitiveWideMask = 0xFE;
    private static final int GErrorAETEntry = 6;
    private static final int GErrorBadState = 2;
    private static final int GErrorFillEntry = 5;
    private static final int GErrorGETEntry = 4;
    private static final int GErrorNeedFlush = 3;
    private static final int GErrorNoMoreSpace = 1;
    private static final int GEStateAddingFromGET = 1;
    private static final int GEStateBlitBuffer = 5;
    private static final int GEStateCompleted = 8;
    private static final int GEStateScanningAET = 3;
    private static final int GEStateUnlocked = 0;
    private static final int GEStateUpdateEdges = 6;
    private static final int GEStateWaitingChange = 7;
    private static final int GEStateWaitingForEdge = 2;
    private static final int GEStateWaitingForFill = 4;
    private static final int GEXValue = 4;
    private static final int GEYValue = 5;
    private static final int GEZValue = 6;
    private static final int GFDirectionX = 6;
    private static final int GFDirectionY = 7;
    private static final int GFNormalX = 8;
    private static final int GFNormalY = 9;
    private static final int GFOriginX = 4;
    private static final int GFOriginY = 5;
    private static final int GFRampLength = 10;
    private static final int GFRampOffset = 12;
    private static final int GGBaseSize = 12;
    private static final int GLBaseSize = 16;
    private static final int GLEndX = 14;
    private static final int GLEndY = 15;
    private static final int GLError = 13;
    private static final int GLErrorAdjDown = 15;
    private static final int GLErrorAdjUp = 14;
    private static final int GLWideEntry = 18;
    private static final int GLWideExit = 19;
    private static final int GLWideExtent = 20;
    private static final int GLWideFill = 16;
    private static final int GLWideSize = 21;
    private static final int GLWideWidth = 17;
    private static final int GLXDirection = 10;
    private static final int GLXIncrement = 12;
    private static final int GLYDirection = 11;
    private static final int GWAAColorMask = 0x33;
    private static final int GWAAColorShift = 50;
    private static final int GWAAHalfPixel = 53;
    private static final int GWAALevel = 48;
    private static final int GWAAScanMask = 0x34;
    private static final int GWAAShift = 49;
    private static final int GWAETStart = 13;
    private static final int GWAETUsed = 14;
    private static final int GWBezierHeightSubdivisions = 109;
    private static final int GWBezierLineConversions = 111;
    private static final int GWBezierMonotonSubdivisions = 108;
    private static final int GWBezierOverflowSubdivisions = 110;
    private static final int GWBufferTop = 10;
    private static final int GWClearSpanBuffer = 69;
    private static final int GWClipMaxX = 43;
    private static final int GWClipMaxY = 45;
    private static final int GWClipMinX = 42;
    private static final int GWClipMinY = 44;
    private static final int GWColorTransform = 24;
    private static final int GWCountAddAETEntry = 97;
    private static final int GWCountChangeAETEntry = 107;
    private static final int GWCountDisplaySpan = 103;
    private static final int GWCountFinishTest = 93;
    private static final int GWCountInitializing = 91;
    private static final int GWCountMergeFill = 101;
    private static final int GWCountNextAETEntry = 105;
    private static final int GWCountNextFillEntry = 99;
    private static final int GWCountNextGETEntry = 95;
    private static final int GWCurrentY = 88;
    private static final int GWCurrentZ = 113;
    private static final int GWDestOffsetX = 46;
    private static final int GWDestOffsetY = 47;
    private static final int GWEdgeTransform = 18;
    private static final int GWFillMaxX = 37;
    private static final int GWFillMaxY = 39;
    private static final int GWFillMinX = 36;
    private static final int GWFillMinY = 38;
    private static final int GWFillOffsetX = 40;
    private static final int GWFillOffsetY = 41;
    private static final int GWGETStart = 11;
    private static final int GWGETUsed = 12;
    private static final int GWHasColorTransform = 17;
    private static final int GWHasEdgeTransform = 16;
    private static final int GWHeaderSize = 128;
    private static final int GWLastExportedEdge = 65;
    private static final int GWLastExportedFill = 66;
    private static final int GWLastExportedLeftX = 67;
    private static final int GWLastExportedRightX = 68;
    private static final int GWMagicIndex = 0;
    private static final int GWMagicNumber = 1097753705;
    protected static final int GWMinimalSize = 256;
    private static final int GWNeedsFlush = 63;
    private static final int GWObjStart = 8;
    private static final int GWObjUsed = 9;
    private static final int GWPoint1 = 80;
    private static final int GWPoint2 = 82;
    private static final int GWPoint3 = 84;
    private static final int GWPoint4 = 86;
    private static final int GWPointListFirst = 70;
    private static final int GWSize = 1;
    private static final int GWSpanEnd = 34;
    private static final int GWSpanEndAA = 35;
    private static final int GWSpanSize = 33;
    private static final int GWSpanStart = 32;
    private static final int GWState = 2;
    private static final int GWStopReason = 64;
    private static final int GWTimeAddAETEntry = 96;
    private static final int GWTimeChangeAETEntry = 106;
    private static final int GWTimeDisplaySpan = 102;
    private static final int GWTimeFinishTest = 92;
    private static final int GWTimeInitializing = 90;
    private static final int GWTimeMergeFill = 100;
    private static final int GWTimeNextAETEntry = 104;
    private static final int GWTimeNextFillEntry = 98;
    private static final int GWTimeNextGETEntry = 94;
    private static final int PrimErrBadArgument = 3;
    // private static final int PrimErrBadNumArgs = 5;

    /* Variables */
    static int aetBufferIndex;
    static long dispatchedValue;
    static long dispatchReturnValue;
    static boolean doProfileStats = false;
    static PointersObject engine;
    static boolean engineStopped;
    static ArrayObject formArray;
    static long geProfileTime;
    static int getBufferIndex;

    static final String moduleName = "B2DPlugin * VMMaker.oscog-eem.2480 (GraalSqueak)";
    static String bbPluginName = "BitBltPlugin";
    static int objBufferIndex;
    static int objUsed;
    static int[] spanBuffer;
    static int[] workBuffer;

    /* BalloonEngineBase>>#aaColorMaskGet */
    static long aaColorMaskGet() {
        return workBuffer[GWAAColorMask];
    }

    /* BalloonEngineBase>>#aaColorMaskPut: */
    static long aaColorMaskPut(final long value) {
        return workBuffer[GWAAColorMask] = (int) value;
    }

    /* BalloonEngineBase>>#aaColorShiftGet */
    static long aaColorShiftGet() {
        return workBuffer[GWAAColorShift];
    }

    /* BalloonEngineBase>>#aaColorShiftPut: */
    static long aaColorShiftPut(final long value) {
        return workBuffer[GWAAColorShift] = (int) value;
    }

    /* Common function to compute the first full pixel for AA drawing */

    /* BalloonEngineBase>>#aaFirstPixelFrom:to: */
    static long aaFirstPixelFromto(final long leftX, final long rightX) {
        final long firstPixel;

        firstPixel = ((leftX + (aaLevelGet())) - 1) & (~((aaLevelGet()) - 1));
        if (firstPixel > rightX) {
            return rightX;
        } else {
            return firstPixel;
        }
    }

    /* BalloonEngineBase>>#aaHalfPixelGet */
    static long aaHalfPixelGet() {
        return workBuffer[GWAAHalfPixel];
    }

    /* BalloonEngineBase>>#aaHalfPixelPut: */
    static long aaHalfPixelPut(final long value) {
        return workBuffer[GWAAHalfPixel] = (int) value;
    }

    /* Common function to compute the last full pixel for AA drawing */

    /* BalloonEngineBase>>#aaLastPixelFrom:to: */
    static long aaLastPixelFromto(@SuppressWarnings("unused") final long leftX, final long rightX) {
        return (rightX - 1) & (~((aaLevelGet()) - 1));
    }

    /* BalloonEngineBase>>#aaLevelGet */
    static long aaLevelGet() {
        return workBuffer[GWAALevel];
    }

    /* BalloonEngineBase>>#aaLevelPut: */
    static long aaLevelPut(final long value) {
        return workBuffer[GWAALevel] = (int) value;
    }

    /* BalloonEngineBase>>#aaScanMaskGet */
    static long aaScanMaskGet() {
        return workBuffer[GWAAScanMask];
    }

    /* BalloonEngineBase>>#aaScanMaskPut: */
    static long aaScanMaskPut(final long value) {
        return workBuffer[GWAAScanMask] = (int) value;
    }

    /* BalloonEngineBase>>#aaShiftGet */
    static long aaShiftGet() {
        return workBuffer[GWAAShift];
    }

    /* BalloonEngineBase>>#aaShiftPut: */
    static long aaShiftPut(final long value) {
        return workBuffer[GWAAShift] = (int) value;
    }

    /*
     * Compute the squared value of a 8.24 number with 0.0 <= value < 1.0, e.g., compute (value *
     * value) bitShift: -24
     */

    /* BalloonEnginePlugin>>#absoluteSquared8Dot24: */
    static long absoluteSquared8Dot24(final long value) {
        final long word1;
        final long word2;

        word1 = value & 0xFFFF;
        word2 = ((value >> 16)) & 0xFF;
        return ((((word1 * word1 >> 16)) + ((word1 * word2) * 2)) + ((word2 * word2 << 16)) >> 8);
    }

    /* Return the accurate length of the vector described by deltaX and deltaY */

    /* BalloonEngineBase>>#accurateLengthOf:with: */
    static long accurateLengthOfwith(final long deltaX, final long deltaY) {
        if (deltaX == 0) {
            if (deltaY < 0) {
                return 0 - deltaY;
            } else {
                return deltaY;
            }
        }
        if (deltaY == 0) {
            if (deltaX < 0) {
                return 0 - deltaX;
            } else {
                return deltaX;
            }
        }
        final int length = (int) ((deltaX * deltaX) + (deltaY * deltaY));
        /* begin computeSqrt: */
        if (length < 32) {
            return (smallSqrtTable())[length];
        } else {
            return ((long) ((Math.sqrt(length)) + 0.5));
        }
    }

    /* BalloonEngineBase>>#addEdgeToGET: */
    static void addEdgeToGET(final long edge) {
        if (!(allocateGETEntry(1))) {
            return;
        }
        getBuffer(getUsedGet(), edge);
        getUsedPut((getUsedGet()) + 1);
    }

    /*
     * NOTE: This method is (hopefully) obsolete due to unrolling the fill loops to deal with full
     * pixels.
     */
    /*
     * Adjust the span buffers values by the appropriate color offset for anti-aliasing. We do this
     * by replicating the top bits of each color in the lower bits. The idea is that we can scale
     * each color value uniquely from 0 to 255 and thus fill the entire range of colors.
     */

    /* BalloonEngineBase>>#adjustAALevel */
    static void adjustAALevel() {
        final long adjustMask;
        final long adjustShift;
        long pixelValue;
        int x0;
        final int x1;

        adjustShift = 8 - (aaColorShiftGet());
        adjustMask = ~(aaColorMaskGet());
        x0 = ((spanStartGet())) >> (aaShiftGet());
        x1 = (int) (((long) (spanEndGet())) >> (aaShiftGet()));
        while (x0 < x1) {
            pixelValue = spanBuffer[x0];
            spanBuffer[x0] = (int) (pixelValue | (((pixelValue) >> adjustShift) & adjustMask));
            x0 += 1;
        }
    }

    /*
     * Adjust the wide bezier curve (dx < 0) to start/end at the right point[] /
     *
     * /* BalloonEnginePlugin>>#adjustWideBezierLeft:width:offset:endX:
     */
    static void adjustWideBezierLeftwidthoffsetendX(final long bezier, final long lineWidth, final long lineOffset, final long endX) {
        final int lastX;
        final int lastY;

        bezierUpdateDataOf(bezier, GBUpdateX, bezierUpdateDataOf(bezier, GBUpdateX) - (lineOffset * 256));
        lastX = wideBezierUpdateDataOf(bezier, GBUpdateX);
        wideBezierUpdateDataOf(bezier, GBUpdateX, lastX + ((lineWidth - lineOffset) * 256));
        lastY = wideBezierUpdateDataOf(bezier, GBUpdateY);
        wideBezierUpdateDataOf(bezier, GBUpdateY, lastY + (lineWidth * 256));
        bezierFinalXOfput(bezier, endX - lineOffset);
    }

    /*
     * Adjust the wide bezier curve (dx >= 0) to start/end at the right point[] /
     *
     * /* BalloonEnginePlugin>>#adjustWideBezierRight:width:offset:endX:
     */
    static void adjustWideBezierRightwidthoffsetendX(final long bezier, final long lineWidth, final long lineOffset, final long endX) {
        final int lastX;
        final int lastY;

        bezierUpdateDataOf(bezier, GBUpdateX, bezierUpdateDataOf(bezier, GBUpdateX) + (lineOffset * 256));
        lastX = wideBezierUpdateDataOf(bezier, GBUpdateX);
        wideBezierUpdateDataOf(bezier, GBUpdateX, lastX - ((lineWidth - lineOffset) * 256));
        /* Set lineWidth pixels down */
        lastY = wideBezierUpdateDataOf(bezier, GBUpdateY);
        wideBezierUpdateDataOf(bezier, GBUpdateY, lastY + (lineWidth * 256));
        bezierFinalXOfput(bezier, (endX - lineOffset) + lineWidth);
    }

    /*
     * Adjust the wide line after it has been stepped from lastX to nextX. Special adjustments of
     * line width and start position are made here to simulate a rectangular brush
     */

    /* BalloonEnginePlugin>>#adjustWideLine:afterSteppingFrom:to: */
    static long adjustWideLineafterSteppingFromto(final long line, final long lastX, final long nextX) {
        final long baseWidth;
        final long deltaX;
        final long lineOffset;
        long lineWidth;
        final long xDir;
        final long yEntry;
        final long yExit;

        /* Don't inline this */
        /* Fetch the values the adjustment decisions are based on */
        yEntry = wideLineEntryOf(line);
        yExit = wideLineExitOf(line);
        baseWidth = wideLineExtentOf(line);
        lineOffset = offsetFromWidth(baseWidth);
        lineWidth = wideLineWidthOf(line);
        xDir = lineXDirectionOf(line);

        /* Adjust the start of the line to fill an entire rectangle */
        deltaX = nextX - lastX;
        if (yEntry < baseWidth) {
            if (xDir < 0) {

                /* effectively adding */
                lineWidth -= deltaX;
            } else {
                lineWidth += deltaX;
                edgeXValueOfput(line, lastX);
            }
        }
        if ((yExit + lineOffset) == 0) {
            if (xDir > 0) {
                lineWidth -= lineXIncrementOf(line);
            } else {

                /* effectively subtracting */
                lineWidth += lineXIncrementOf(line);
                edgeXValueOfput(line, lastX);
            }
        }
        if ((yExit + lineOffset) > 0) {
            if (xDir < 0) {

                /* effectively subtracting */
                lineWidth += deltaX;
                edgeXValueOfput(line, lastX);
            } else {
                lineWidth -= deltaX;
            }
        }
        wideLineWidthOfput(line, lineWidth);
        return 0;
    }

    /* BalloonEngineBase>>#aetStartGet */
    static int aetStartGet() {
        return workBuffer[GWAETStart];
    }

    /* BalloonEngineBase>>#aetStartPut: */
    static long aetStartPut(final long value) {
        return workBuffer[GWAETStart] = (int) value;
    }

    /* BalloonEngineBase>>#aetUsedGet */
    static int aetUsedGet() {
        return workBuffer[GWAETUsed];
    }

    /* BalloonEngineBase>>#aetUsedPut: */
    static long aetUsedPut(final long value) {
        return workBuffer[GWAETUsed] = (int) value;
    }

    /* Allocate n slots in the active edge table */

    /* BalloonEngineBase>>#allocateAETEntry: */
    static boolean allocateAETEntry(final long nSlots) {
        return needAvailableSpace(nSlots);
    }

    /* BalloonEnginePlugin>>#allocateBezier */
    static long allocateBezier() {
        final int bezier;

        if (!(allocateObjEntry(GBBaseSize))) {
            return 0;
        }
        bezier = objUsed;
        objUsed = bezier + GBBaseSize;
        objectTypeOfput(bezier, GEPrimitiveBezier);
        objectIndexOfput(bezier, 0);
        objectLengthOfput(bezier, GBBaseSize);
        return bezier;
    }

    /* BalloonEnginePlugin>>#allocateBezierStackEntry */
    static long allocateBezierStackEntry() {
        wbStackPush(6);
        return wbStackSize();
    }

    /* BalloonEnginePlugin>>#allocateBitmapFill:colormap: */
    static long allocateBitmapFillcolormap(final long cmSize, final int[] cmBits) {
        final int fill;
        final int fillSize;

        fillSize = GBMBaseSize + (int) cmSize;
        if (!(allocateObjEntry(fillSize))) {
            return 0;
        }
        fill = objUsed;
        objUsed = fill + fillSize;
        objectTypeOfput(fill, GEPrimitiveClippedBitmapFill);
        objectIndexOfput(fill, 0);
        objectLengthOfput(fill, fillSize);
        if (hasColorTransform()) {
            for (int i = 0; i < cmSize; i += 1) {
                colormapOf(fill, i, transformColor(cmBits[i]));
            }
        } else {
            for (int i = 0; i < cmSize; i += 1) {
                colormapOf(fill, i, cmBits[i]);
            }
        }
        objatput(fill, GBColormapSize, cmSize);
        return fill;
    }

    /* Allocate n slots in the global edge table */

    /* BalloonEngineBase>>#allocateGETEntry: */
    static boolean allocateGETEntry(final long nSlots) {
        long dstIndex;
        long i;
        long iLimiT;
        long srcIndex;

        /* First allocate nSlots in the AET */
        if (!(allocateAETEntry(nSlots))) {
            return false;
        }
        if (!((aetUsedGet()) == 0)) {
            /* Then move the AET upwards */
            srcIndex = aetUsedGet();
            dstIndex = (aetUsedGet()) + nSlots;
            for (i = 1, iLimiT = (aetUsedGet()); i <= iLimiT; i += 1) {
                aetBuffer(dstIndex -= 1, aetBuffer(srcIndex -= 1));
            }
        }
        aetBufferIndex += nSlots;
        return true;
    }

    /* BalloonEnginePlugin>>#allocateGradientFill:rampWidth:isRadial: */
    static long allocateGradientFillrampWidthisRadial(final int[] ramp, final long rampWidth, final boolean isRadial) {
        final int fill;
        final int fillSize;
        final int rampPtr;

        fillSize = GGBaseSize + (int) rampWidth;
        if (!(allocateObjEntry(fillSize))) {
            return 0;
        }
        fill = objUsed;
        objUsed = fill + fillSize;
        if (isRadial) {
            objectTypeOfput(fill, GEPrimitiveRadialGradientFill);
        } else {
            objectTypeOfput(fill, GEPrimitiveLinearGradientFill);
        }
        objectIndexOfput(fill, 0);
        objectLengthOfput(fill, fillSize);
        rampPtr = gradientRampIndexOf(fill);
        if (hasColorTransform()) {
            for (int i = 0; i < rampWidth; i += 1) {
                workBuffer[rampPtr + i] = (int) (transformColor(ramp[i]));
            }
        } else {
            for (int i = 0; i < rampWidth; i += 1) {
                workBuffer[rampPtr + i] = (ramp[i]);
            }
        }
        objatput(fill, GFRampLength, rampWidth);
        return fill;
    }

    /* BalloonEnginePlugin>>#allocateLine */
    static long allocateLine() {
        final int line;

        if (!(allocateObjEntry(GLBaseSize))) {
            return 0;
        }
        line = objUsed;
        objUsed = line + GLBaseSize;
        objectTypeOfput(line, GEPrimitiveLine);
        objectIndexOfput(line, 0);
        objectLengthOfput(line, GLBaseSize);
        return line;
    }

    /* Allocate n slots in the object buffer */

    /* BalloonEngineBase>>#allocateObjEntry: */
    static boolean allocateObjEntry(final long nSlots) {
        int dstIndex;
        long i;
        long iLimiT;
        int srcIndex;

        /* First allocate nSlots in the GET */
        if (!(allocateGETEntry(nSlots))) {
            return false;
        }
        if (!((getUsedGet()) == 0)) {
            /* Then move the GET upwards */
            srcIndex = getUsedGet();
            dstIndex = (int) ((getUsedGet()) + nSlots);
            for (i = 1, iLimiT = (getUsedGet()); i <= iLimiT; i += 1) {
                getBuffer((dstIndex -= 1), getBuffer((srcIndex -= 1)));
            }
        }
        getBufferIndex += nSlots;
        return true;
    }

    /* AET and Stack allocation are symmetric */

    /* BalloonEngineBase>>#allocateStackEntry: */
    static boolean allocateStackEntry(final long nSlots) {
        return needAvailableSpace(nSlots);
    }

    /* BalloonEngineBase>>#allocateStackFillEntry */
    static boolean allocateStackFillEntry() {
        return wbStackPush(stackFillEntryLength());
    }

    /* BalloonEnginePlugin>>#allocateWideBezier */
    static long allocateWideBezier() {
        final int bezier;

        if (!(allocateObjEntry(GBWideSize))) {
            return 0;
        }
        bezier = objUsed;
        objUsed = bezier + GBWideSize;
        objectTypeOfput(bezier, GEPrimitiveWideBezier);
        objectIndexOfput(bezier, 0);
        objectLengthOfput(bezier, GBWideSize);
        return bezier;
    }

    /* BalloonEnginePlugin>>#allocateWideLine */
    static long allocateWideLine() {
        final int line;

        if (!(allocateObjEntry(GLWideSize))) {
            return 0;
        }
        line = objUsed;
        objUsed = line + GLWideSize;
        objectTypeOfput(line, GEPrimitiveWideLine);
        objectIndexOfput(line, 0);
        objectLengthOfput(line, GLWideSize);
        return line;
    }

    /* BalloonEngineBase>>#areEdgeFillsValid: */
    static boolean areEdgeFillsValid(final long edge) {
        return ((makeUnsignedFrom(objat(edge, GEObjectType))) & GEEdgeFillsInvalid) == 0;
    }

    /* Make sure that val1 is between val2 and val3. */

    /* BalloonEnginePlugin>>#assureValue:between:and: */
    static long assureValuebetweenand(final long val1, final long val2, final long val3) {
        if (val2 > val3) {
            if (val1 > val2) {
                return val2;
            }
            if (val1 < val3) {
                return val3;
            }
        } else {
            if (val1 < val2) {
                return val2;
            }
            if (val1 > val3) {
                return val3;
            }
        }
        return val1;
    }

    /* BalloonEnginePlugin>>#bezierEndXOf: */
    static long bezierEndXOf(final long bezier) {
        return objat(bezier, GBEndX);
    }

    /* BalloonEnginePlugin>>#bezierEndXOf:put: */
    static void bezierEndXOfput(final long bezier, final long value) {
        objatput(bezier, GBEndX, value);
    }

    /* BalloonEnginePlugin>>#bezierEndYOf: */
    static long bezierEndYOf(final long bezier) {
        return objat(bezier, GBEndY);
    }

    /* BalloonEnginePlugin>>#bezierEndYOf:put: */
    static void bezierEndYOfput(final long bezier, final long value) {
        objatput(bezier, GBEndY, value);
    }

    /* BalloonEnginePlugin>>#bezierFinalXOf: */
    static long bezierFinalXOf(final long bezier) {
        return objat(bezier, GBFinalX);
    }

    /* BalloonEnginePlugin>>#bezierFinalXOf:put: */
    static void bezierFinalXOfput(final long bezier, final long value) {
        objatput(bezier, GBFinalX, value);
    }

    /* BalloonEnginePlugin>>#bezierUpdateDataOf: */
    static int bezierUpdateDataOf(final long bezier, final long offset) {
        return workBuffer[bezierUpdateDataIndexOf(bezier) + (int) offset];
    }

    static int bezierUpdateDataIndexOf(final long bezier) {
        return objBufferIndex + (int) bezier + GBUpdateData;
    }

    static void bezierUpdateDataOf(final long bezier, final long offset, final long value) {
        workBuffer[bezierUpdateDataIndexOf(bezier) + (int) offset] = (int) value;
    }

    /* BalloonEnginePlugin>>#bezierViaXOf: */
    static long bezierViaXOf(final long bezier) {
        return objat(bezier, GBViaX);
    }

    /* BalloonEnginePlugin>>#bezierViaXOf:put: */
    static void bezierViaXOfput(final long bezier, final long value) {
        objatput(bezier, GBViaX, value);
    }

    /* BalloonEnginePlugin>>#bezierViaYOf: */
    static long bezierViaYOf(final long bezier) {
        return objat(bezier, GBViaY);
    }

    /* BalloonEnginePlugin>>#bezierViaYOf:put: */
    static void bezierViaYOfput(final long bezier, final long value) {
        objatput(bezier, GBViaY, value);
    }

    /* BalloonEnginePlugin>>#bitmapCmSizeOf: */
    static long bitmapCmSizeOf(final long bmFill) {
        return objat(bmFill, GBColormapSize);
    }

    /* BalloonEnginePlugin>>#bitmapCmSizeOf:put: */
    static void bitmapCmSizeOfput(final long bmFill, final long value) {
        objatput(bmFill, GBColormapSize, value);
    }

    /* BalloonEnginePlugin>>#bitmapDepthOf: */
    static long bitmapDepthOf(final long bmFill) {
        return objat(bmFill, GBBitmapDepth);
    }

    /* BalloonEnginePlugin>>#bitmapDepthOf:put: */
    static void bitmapDepthOfput(final long bmFill, final long value) {
        objatput(bmFill, GBBitmapDepth, value);
    }

    /* BalloonEnginePlugin>>#bitmapHeightOf: */
    static long bitmapHeightOf(final long bmFill) {
        return objat(bmFill, GBBitmapHeight);
    }

    /* BalloonEnginePlugin>>#bitmapHeightOf:put: */
    static void bitmapHeightOfput(final long bmFill, final long value) {
        objatput(bmFill, GBBitmapHeight, value);
    }

    /* BalloonEnginePlugin>>#bitmapRasterOf: */
    static long bitmapRasterOf(final long bmFill) {
        return objat(bmFill, GBBitmapRaster);
    }

    /* BalloonEnginePlugin>>#bitmapRasterOf:put: */
    static void bitmapRasterOfput(final long bmFill, final long value) {
        objatput(bmFill, GBBitmapRaster, value);
    }

    /* BalloonEnginePlugin>>#bitmapSizeOf: */
    static long bitmapSizeOf(final long bmFill) {
        return objat(bmFill, GBBitmapSize);
    }

    /* BalloonEnginePlugin>>#bitmapSizeOf:put: */
    static void bitmapSizeOfput(final long bmFill, final long value) {
        objatput(bmFill, GBBitmapSize, value);
    }

    /* BalloonEnginePlugin>>#bitmapTileFlagOf: */
    static long bitmapTileFlagOf(final long bmFill) {
        return objat(bmFill, GBTileFlag);
    }

    /* BalloonEnginePlugin>>#bitmapTileFlagOf:put: */
    static void bitmapTileFlagOfput(final long bmFill, final long value) {
        objatput(bmFill, GBTileFlag, value);
    }

    /* BalloonEnginePlugin>>#bitmapValue:bits:atX:y: */
    static long bitmapValuebitsatXy(final long bmFill, final int[] bits, final long xp, final long yp) {
        final long a;
        long b;
        final int bmDepth;
        final int bmRaster;
        final int cMask;
        long g;
        long r;
        int rShift;
        long value;

        bmDepth = objat(bmFill, GBBitmapDepth);
        bmRaster = objat(bmFill, GBBitmapRaster);
        if (bmDepth == 32) {
            value = bits[(int) ((bmRaster * yp) + xp)];
            if ((value != 0) && ((value & 0xFF000000L) == 0)) {
                value = value | 0xFF000000;
            }
            return uncheckedTransformColor(value);
        }
        rShift = (rShiftTable())[bmDepth];
        /* cMask - mask out the pixel from the word */
        value = makeUnsignedFrom(bits[(int) ((bmRaster * yp) + ((xp) >> rShift))]);
        /* rShift - shift value to move the pixel in the word to the lowest bit position */
        cMask = (int) ((1L << bmDepth) - 1);
        rShift = (int) ((32 - bmDepth) - ((xp & ((1L << rShift) - 1)) * bmDepth));
        value = ((value) >> rShift) & cMask;
        if (bmDepth == 16) {
            /* Must convert by expanding bits */
            if (!(value == 0)) {
                b = (((value & 0x1F)) << 3);
                b += (b) >> 5;
                g = (((((value) >> 5) & 0x1F)) << 3);
                g += (g) >> 5;
                r = (((((value) >> 10) & 0x1F)) << 3);
                r += (r) >> 5;
                a = 0xFF;
                value = ((b + (((g) << 8))) + (((r) << 16))) + (((a) << 24));
            }
        } else {
            /* Must convert by using color map */
            if ((objat(bmFill, GBColormapSize)) == 0) {
                value = 0;
            } else {
                value = Integer.toUnsignedLong(colormapOf(bmFill, value));
            }
        }
        return uncheckedTransformColor(value);
    }

    /* BalloonEnginePlugin>>#bitmapWidthOf: */
    static long bitmapWidthOf(final long bmFill) {
        return objat(bmFill, GBBitmapWidth);
    }

    /* BalloonEnginePlugin>>#bitmapWidthOf:put: */
    static void bitmapWidthOfput(final long bmFill, final long value) {
        objatput(bmFill, GBBitmapWidth, value);
    }

    /* BalloonEnginePlugin>>#bzEndX: */
    static long bzEndX(final long index) {
        return wbStackValue(((wbStackSize()) - index) + 4);
    }

    /* BalloonEnginePlugin>>#bzEndX:put: */
    static long bzEndXput(final long index, final long value) {
        return wbStackValueput(((wbStackSize()) - index) + 4, value);
    }

    /* BalloonEnginePlugin>>#bzEndY: */
    static long bzEndY(final long index) {
        return wbStackValue(((wbStackSize()) - index) + 5);
    }

    /* BalloonEnginePlugin>>#bzEndY:put: */
    static long bzEndYput(final long index, final long value) {
        return wbStackValueput(((wbStackSize()) - index) + 5, value);
    }

    /* BalloonEnginePlugin>>#bzStartX: */
    static long bzStartX(final long index) {
        return wbStackValue(((wbStackSize()) - index));
    }

    /* BalloonEnginePlugin>>#bzStartX:put: */
    static long bzStartXput(final long index, final long value) {
        return wbStackValueput(((wbStackSize()) - index), value);
    }

    /* BalloonEnginePlugin>>#bzStartY: */
    static long bzStartY(final long index) {
        return wbStackValue(((wbStackSize()) - index) + 1);
    }

    /* BalloonEnginePlugin>>#bzStartY:put: */
    static long bzStartYput(final long index, final long value) {
        return wbStackValueput(((wbStackSize()) - index) + 1, value);
    }

    /* BalloonEnginePlugin>>#bzViaX: */
    static long bzViaX(final long index) {
        return wbStackValue(((wbStackSize()) - index) + 2);
    }

    /* BalloonEnginePlugin>>#bzViaX:put: */
    static long bzViaXput(final long index, final long value) {
        return wbStackValueput(((wbStackSize()) - index) + 2, value);
    }

    /* BalloonEnginePlugin>>#bzViaY: */
    static long bzViaY(final long index) {
        return wbStackValue(((wbStackSize()) - index) + 3);
    }

    /* BalloonEnginePlugin>>#bzViaY:put: */
    static long bzViaYput(final long index, final long value) {
        return wbStackValueput(((wbStackSize()) - index) + 3, value);
    }

    /* Check the fill indexes in the run-length encoded fillList */

    /* BalloonEnginePlugin>>#checkCompressedFillIndexList:max:segments: */
    static boolean checkCompressedFillIndexListmaxsegments(final NativeObject fillList, final long maxIndex, final long nSegs) {
        long nFills;
        long runLength;
        long runValue;

        final int[] fillPtr = fillList.getIntStorage();
        final long length = fillPtr.length;
        nFills = 0;
        for (int i = 0; i < length; i += 1) {
            runLength = shortRunLengthAtfrom(i, fillPtr);
            runValue = shortRunValueAtfrom(i, fillPtr);
            if (!((runValue >= 0) && (runValue <= maxIndex))) {
                return false;
            }
            nFills += runLength;
        }
        return nFills == nSegs;
    }

    /* Check if the indexList (containing fill handles) is okay. */

    /* BalloonEnginePlugin>>#checkCompressedFills: */
    static boolean checkCompressedFills(final NativeObject indexList) {
        final int[] fillPtr = indexList.getIntStorage();
        final long length = fillPtr.length;
        for (int i = 0; i < length; i += 1) {
            /* Make sure the fill is okay */
            if (!(isFillOkay(fillPtr[i]))) {
                return false;
            }
        }
        return true;
    }

    /* Check the run-length encoded lineWidthList matches nSegments */

    /* BalloonEnginePlugin>>#checkCompressedLineWidths:segments: */
    static boolean checkCompressedLineWidthssegments(final NativeObject lineWidthList, final long nSegments) {
        final long length;
        long nItems;
        final int[] ptr;
        long runLength;

        ptr = lineWidthList.getIntStorage();
        length = ptr.length;
        nItems = 0;
        for (int i = 0; i < length; i += 1) {
            runLength = shortRunLengthAtfrom(i, ptr);
            nItems += runLength;
        }
        return nItems == nSegments;
    }

    /* Check if the given point array can be handled by the engine. */

    /* BalloonEnginePlugin>>#checkCompressedPoints:segments: */
    static boolean checkCompressedPointssegments(final NativeObject points, final long nSegments) {
        final long pSize;

        assert points.isIntType();

        /*
         * The points must be either in PointArray format or ShortPointArray format. Also, we
         * currently handle only quadratic segments (e.g., 3 points each) and thus either pSize =
         * nSegments * 3, for ShortPointArrays or, pSize = nSegments * 6, for PointArrays
         */
        pSize = slotSizeOf(points);
        if (!((pSize == (nSegments * 3)) || (pSize == (nSegments * 6)))) {
            return false;
        }
        return true;
    }

    /*
     * Check if the given shape can be handled by the engine. Since there are a number of
     * requirements this is an extra method.
     */

    /*
     * BalloonEnginePlugin>>#checkCompressedShape:segments:leftFills:rightFills:lineWidths:lineFills
     * :fillIndexList:
     */
    static boolean checkCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexList(final NativeObject points, final long nSegments, final NativeObject leftFills,
                    final NativeObject rightFills, final NativeObject lineWidths, final NativeObject lineFills, final NativeObject fillIndexList) {
        if (!(checkCompressedPointssegments(points, nSegments))) {
            return false;
        }
        if (!(checkCompressedFills(fillIndexList))) {
            return false;
        }
        final long maxFillIndex = slotSizeOf(fillIndexList);
        if (!(checkCompressedFillIndexListmaxsegments(leftFills, maxFillIndex, nSegments))) {
            return false;
        }
        if (!(checkCompressedFillIndexListmaxsegments(rightFills, maxFillIndex, nSegments))) {
            return false;
        }
        if (!(checkCompressedFillIndexListmaxsegments(lineFills, maxFillIndex, nSegments))) {
            return false;
        }
        if (!(checkCompressedLineWidthssegments(lineWidths, nSegments))) {
            return false;
        }
        return true;
    }

    /*
     * Add the bezier to the global edge table if it intersects the clipping region
     */

    /* BalloonEnginePlugin>>#checkedAddBezierToGET: */
    static void checkedAddBezierToGET(final long bezier) {
        final long lineWidth;

        if (isWide(bezier)) {
            lineWidth = wideBezierExtentOf(bezier);
        } else {
            lineWidth = 0;
        }
        if (((bezierEndYOf(bezier)) + lineWidth) < (fillMinYGet())) {
            return;
        }
        if ((((edgeXValueOf(bezier)) - lineWidth) >= (fillMaxXGet())) && (((bezierEndXOf(bezier)) - lineWidth) >= (fillMaxXGet()))) {
            return;
        }
        addEdgeToGET(bezier);
    }

    /*
     * Add the edge to the global edge table. For known edge types, check if the edge intersects the
     * visible region
     */

    /* BalloonEnginePlugin>>#checkedAddEdgeToGET: */
    static void checkedAddEdgeToGET(final long edge) {
        if (isLine(edge)) {
            checkedAddLineToGET(edge);
            return;
        }
        if (isBezier(edge)) {
            checkedAddBezierToGET(edge);
            return;
        }
        addEdgeToGET(edge);
    }

    /* Add the line to the global edge table if it intersects the clipping region */

    /* BalloonEnginePlugin>>#checkedAddLineToGET: */
    static void checkedAddLineToGET(final long line) {
        final long lineWidth;

        if (isWide(line)) {
            lineWidth = wideLineExtentOf(line);
        } else {
            lineWidth = 0;
        }
        if (((lineEndYOf(line)) + lineWidth) < (fillMinYGet())) {
            return;
        }
        if ((((edgeXValueOf(line)) - lineWidth) >= (fillMaxXGet())) && (((lineEndXOf(line)) - lineWidth) >= (fillMaxXGet()))) {
            return;
        }
        addEdgeToGET(line);
    }

    /* BalloonEnginePlugin>>#circleCosTable */
    static double[] circleCosTable() {
        final double[] theTable = new double[]{1.0, 0.98078528040323, 0.923879532511287, 0.831469612302545,
                        0.7071067811865475, 0.555570233019602, 0.38268343236509, 0.1950903220161286,
                        0.0, -0.1950903220161283, -0.3826834323650896, -0.555570233019602,
                        -0.707106781186547, -0.831469612302545, -0.9238795325112865, -0.98078528040323,
                        -1.0, -0.98078528040323, -0.923879532511287, -0.831469612302545,
                        -0.707106781186548, -0.555570233019602, -0.3826834323650903, -0.1950903220161287,
                        0.0, 0.1950903220161282, 0.38268343236509, 0.555570233019602,
                        0.707106781186547, 0.831469612302545, 0.9238795325112865, 0.98078528040323,
                        1.0};

        return theTable;
    }

    /* BalloonEnginePlugin>>#circleSinTable */
    static double[] circleSinTable() {
        final double[] theTable = new double[]{0.0, 0.1950903220161282, 0.3826834323650897, 0.555570233019602,
                        0.707106781186547, 0.831469612302545, 0.923879532511287, 0.98078528040323,
                        1.0, 0.98078528040323, 0.923879532511287, 0.831469612302545,
                        0.7071067811865475, 0.555570233019602, 0.38268343236509, 0.1950903220161286,
                        0.0, -0.1950903220161283, -0.3826834323650896, -0.555570233019602,
                        -0.707106781186547, -0.831469612302545, -0.9238795325112865, -0.98078528040323,
                        -1.0, -0.98078528040323, -0.923879532511287, -0.831469612302545,
                        -0.707106781186548, -0.555570233019602, -0.3826834323650903, -0.1950903220161287,
                        0.0};

        return theTable;
    }

    /* BalloonEnginePlugin>>#clampValue:max: */
    static long clampValuemax(final long value, final long maxValue) {
        if (value < 0) {
            return 0;
        } else {
            if (value >= maxValue) {
                return maxValue - 1;
            } else {
                return value;
            }
        }
    }

    /*
     * Clear the current span buffer. The span buffer is only cleared in the area that has been used
     * by the previous scan line.
     */

    /* BalloonEngineBase>>#clearSpanBuffer */
    static long clearSpanBuffer() {
        int x0;
        int x1;

        x0 = ((spanStartGet())) >> (aaShiftGet());
        x1 = (((spanEndGet())) >> (aaShiftGet())) + 1;
        if (x0 < 0) {
            x0 = 0;
        }
        if (x1 > (spanSizeGet())) {
            x1 = spanSizeGet();
        }
        while (x0 < x1) {
            spanBuffer[x0] = 0;
            x0 += 1;
        }
        spanStartPut(spanSizeGet());
        spanEndPut(0);
        return 0;
    }

    /* BalloonEngineBase>>#clearSpanBufferGet */
    static long clearSpanBufferGet() {
        return workBuffer[GWClearSpanBuffer];
    }

    /* BalloonEngineBase>>#clearSpanBufferPut: */
    static long clearSpanBufferPut(final long value) {
        return workBuffer[GWClearSpanBuffer] = (int) value;
    }

    /* BalloonEngineBase>>#clipMaxXGet */
    static int clipMaxXGet() {
        return workBuffer[GWClipMaxX];
    }

    /* BalloonEngineBase>>#clipMaxXPut: */
    static long clipMaxXPut(final long value) {
        return workBuffer[GWClipMaxX] = (int) value;
    }

    /* BalloonEngineBase>>#clipMaxYGet */
    static long clipMaxYGet() {
        return workBuffer[GWClipMaxY];
    }

    /* BalloonEngineBase>>#clipMaxYPut: */
    static long clipMaxYPut(final long value) {
        return workBuffer[GWClipMaxY] = (int) value;
    }

    /* BalloonEngineBase>>#clipMinXGet */
    static int clipMinXGet() {
        return workBuffer[GWClipMinX];
    }

    /* BalloonEngineBase>>#clipMinXPut: */
    static long clipMinXPut(final long value) {
        return workBuffer[GWClipMinX] = (int) value;
    }

    /* BalloonEngineBase>>#clipMinYGet */
    static long clipMinYGet() {
        return workBuffer[GWClipMinY];
    }

    /* BalloonEngineBase>>#clipMinYPut: */
    static long clipMinYPut(final long value) {
        return workBuffer[GWClipMinY] = (int) value;
    }

    /* BalloonEnginePlugin>>#colormapOf: */
    static int colormapOf(final long bmFill, final long index) {
        return workBuffer[colormapIndexOf(bmFill) + (int) index];
    }

    static void colormapOf(final long bmFill, final int index, final long value) {
        workBuffer[colormapIndexOf(bmFill) + index] = (int) value;
    }

    static int colormapIndexOf(final long bmFill) {
        return (objBufferIndex + (int) bmFill) + GBColormapOffset;
    }

    /* BalloonEngineBase>>#colorTransform */
    static int colorTransformGet(final int index) {
        return workBuffer[GWColorTransform + index];
    }

    static void colorTransformSet(final int index, final float value) {
        workBuffer[GWColorTransform + index] = (int) value;
    }

    /* Split the bezier curve at 0.5. */

    /* BalloonEnginePlugin>>#computeBezierSplitAtHalf: */
    static long computeBezierSplitAtHalf(final long index) {
        final long endX;
        final long endY;
        long leftViaX;
        long leftViaY;
        final long newIndex;
        long rightViaX;
        final long rightViaY;
        final long sharedX;
        long sharedY = 0;
        final long startX;
        final long startY;
        final long viaX;
        final long viaY;

        newIndex = allocateBezierStackEntry();
        if (engineStopped) {
            return 0;
        }
        leftViaX = (startX = bzStartX(index));
        leftViaY = (startY = bzStartY(index));
        rightViaX = (viaX = bzViaX(index));
        rightViaY = (viaY = bzViaY(index));
        endX = bzEndX(index);

        /* Compute intermediate points */
        endY = bzEndY(index);
        leftViaX += (viaX - startX) / 2;
        leftViaY += (viaY - startY) / 2;
        sharedX = (rightViaX += (endX - viaX) / 2);

        /*
         * Compute new shared point[] / sharedY = (rightViaY += (endY - viaY) / 2); sharedX +=
         * (leftViaX - rightViaX) / 2;
         *
         * /* Store the first part back
         */
        sharedY += (leftViaY - rightViaY) / 2;
        bzViaXput(index, leftViaX);
        bzViaYput(index, leftViaY);
        bzEndXput(index, sharedX);
        bzEndYput(index, sharedY);
        bzStartXput(newIndex, sharedX);
        bzStartYput(newIndex, sharedY);
        bzViaXput(newIndex, rightViaX);
        bzViaYput(newIndex, rightViaY);
        bzEndXput(newIndex, endX);
        bzEndYput(newIndex, endY);
        return newIndex;
    }

    /*
     * Split the bezier curve at the given parametric value. Note: Since this method is only invoked
     * to make non-monoton beziers monoton we must check for the resulting y values to be *really*
     * between the start and end value.
     */

    /* BalloonEnginePlugin>>#computeBezier:splitAt: */
    static long computeBeziersplitAt(final long index, final double param) {
        final long endX;
        final long endY;
        long leftViaX;
        long leftViaY;
        final long newIndex;
        long rightViaX;
        long rightViaY;
        final long sharedX;
        long sharedY;
        final long startX;
        final long startY;
        final long viaX;
        final long viaY;

        leftViaX = (startX = bzStartX(index));
        leftViaY = (startY = bzStartY(index));
        rightViaX = (viaX = bzViaX(index));
        rightViaY = (viaY = bzViaY(index));
        endX = bzEndX(index);

        /* Compute intermediate points */
        endY = bzEndY(index);
        sharedX = (leftViaX += ((long) (((viaX - startX)) * param)));
        sharedY = (leftViaY += ((long) (((viaY - startY)) * param)));
        rightViaX += ((long) (((endX - viaX)) * param));

        /*
         * Compute new shared point[] / rightViaY += ((long) ((((double) (endY - viaY))) * param));
         * sharedX += ((long) ((((double) (rightViaX - leftViaX))) * param));
         *
         * /* Check the new via points
         */
        sharedY += ((long) (((rightViaY - leftViaY)) * param));
        leftViaY = assureValuebetweenand(leftViaY, startY, sharedY);
        rightViaY = assureValuebetweenand(rightViaY, sharedY, endY);
        newIndex = allocateBezierStackEntry();
        if (engineStopped) {
            return 0;
        }
        bzViaXput(index, leftViaX);
        bzViaYput(index, leftViaY);
        bzEndXput(index, sharedX);
        bzEndYput(index, sharedY);
        bzStartXput(newIndex, sharedX);
        bzStartYput(newIndex, sharedY);
        bzViaXput(newIndex, rightViaX);
        bzViaYput(newIndex, rightViaY);
        bzEndXput(newIndex, endX);
        bzEndYput(newIndex, endY);
        return newIndex;
    }

    /*
     * Get both values from the two boundaries of the given bezier and compute the actual
     * position/width of the line
     */

    /* BalloonEnginePlugin>>#computeFinalWideBezierValues:width: */
    static void computeFinalWideBezierValueswidth(final long bezier, final long lineWidth) {
        int leftX;
        int rightX;
        final int temp;

        leftX = bezierUpdateDataOf(bezier, GBUpdateX) / 256;
        rightX = wideBezierUpdateDataOf(bezier, GBUpdateX) / 256;
        if (leftX > rightX) {
            temp = leftX;
            leftX = rightX;
            rightX = temp;
        }
        edgeXValueOfput(bezier, leftX);
        if ((rightX - leftX) > lineWidth) {
            wideBezierWidthOfput(bezier, rightX - leftX);
        } else {
            wideBezierWidthOfput(bezier, lineWidth);
        }
    }

    /* BalloonEngineBase>>#computeSqrt: */
    static long computeSqrt(final int length2) {
        if (length2 < 32) {
            return (smallSqrtTable())[length2];
        } else {
            return ((long) ((Math.sqrt((length2))) + 0.5));
        }
    }

    /* BalloonEngineBase>>#copyBitsFrom:to:at: */
    static void copyBitsFromtoat(final int x0, final int x1, final int yValue) {
        BitBlt.copyBitsFromtoat(x0, x1, yValue);
    }

    /* Create the global edge table */

    /* BalloonEngineBase>>#createGlobalEdgeTable */
    static void createGlobalEdgeTable() {
        final long end;
        long object;

        object = 0;
        end = objUsed;
        while (object < end) {
            /* Note: addEdgeToGET: may fail on insufficient space but that's not a problem here */
            if (isEdge(object)) {
                /* Check if the edge starts below fillMaxY. */
                if (!((edgeYValueOf(object)) >= (fillMaxYGet()))) {
                    checkedAddEdgeToGET(object);
                }
            }
            object += objat(object, GEObjectLength);
        }
    }

    /* BalloonEngineBase>>#currentYGet */
    static int currentYGet() {
        return workBuffer[GWCurrentY];
    }

    /* BalloonEngineBase>>#currentYPut: */
    static long currentYPut(final long value) {
        return workBuffer[GWCurrentY] = (int) value;
    }

    /* BalloonEngineBase>>#currentZGet */
    static int currentZGet() {
        return workBuffer[GWCurrentZ];
    }

    /* BalloonEngineBase>>#currentZPut: */
    static long currentZPut(final long value) {
        return workBuffer[GWCurrentZ] = (int) value;
    }

    /* BalloonEngineBase>>#destOffsetXGet */
    static int destOffsetXGet() {
        return workBuffer[GWDestOffsetX];
    }

    /* BalloonEngineBase>>#destOffsetXPut: */
    static long destOffsetXPut(final long value) {
        return workBuffer[GWDestOffsetX] = (int) value;
    }

    /* BalloonEngineBase>>#destOffsetYGet */
    static int destOffsetYGet() {
        return workBuffer[GWDestOffsetY];
    }

    /* BalloonEngineBase>>#destOffsetYPut: */
    static long destOffsetYPut(final long value) {
        return workBuffer[GWDestOffsetY] = (int) value;
    }

    /* Display the span buffer at the current scan line. */

    /* BalloonEngineBase>>#displaySpanBufferAt: */
    static void displaySpanBufferAt(final long y) {
        int targetX0;
        int targetX1;
        final int targetY;

        /* self aaLevelGet > 1 ifTrue:[self adjustAALevel]. */
        targetX0 = (int) (((long) (spanStartGet())) >> (aaShiftGet()));
        if (targetX0 < (clipMinXGet())) {
            targetX0 = clipMinXGet();
        }
        targetX1 = (int) ((((spanEndGet()) + (aaLevelGet())) - 1) >> (aaShiftGet()));
        if (targetX1 > (clipMaxXGet())) {
            targetX1 = clipMaxXGet();
        }
        targetY = (int) ((y) >> (aaShiftGet()));
        if ((targetY < (clipMinYGet())) || ((targetY >= (clipMaxYGet())) || ((targetX1 < (clipMinXGet())) || (targetX0 >= (clipMaxXGet()))))) {
            return;
        }
        copyBitsFromtoat(targetX0, targetX1, targetY);
    }

    /*
     * Draw the given edge starting from leftX with the edge's fill. Return the end value of the
     * drawing operation.
     */

    /* BalloonEngineBase>>#drawWideEdge:from: */
    static long drawWideEdgefrom(final long edge, final long leftX) {
        final long fill;
        final long lineWidth;
        final long rightX;
        final int type;

        /* Not for the moment */
        type = edgeTypeOf(edge);
        dispatchedValue = edge;
        switch (type) {
            case 0:
            case 1:
                errorWrongIndex();
                break;
            case 2:
                returnWideLineWidth();
                break;
            case 3:
                returnWideBezierWidth();
                break;
        }
        lineWidth = dispatchReturnValue;
        switch (type) {
            case 0:
            case 1:
                errorWrongIndex();
                break;
            case 2:
                returnWideLineFill();
                break;
            case 3:
                returnWideBezierFill();
                break;
        }
        fill = makeUnsignedFrom(dispatchReturnValue);
        if (fill == 0) {
            return leftX;
        }
        rightX = leftX + lineWidth;
        fillSpanfromto(fill, leftX, rightX);
        return rightX;
    }

    /* BalloonEngineBase>>#edgeFillsInvalidate: */
    static void edgeFillsInvalidate(final long edge) {
        objectTypeOfput(edge, (objectTypeOf(edge)) | GEEdgeFillsInvalid);
    }

    /* BalloonEngineBase>>#edgeFillsValidate: */
    static void edgeFillsValidate(final long edge) {
        objectTypeOfput(edge, (objectTypeOf(edge)) & ((long) ~GEEdgeFillsInvalid));
    }

    /* BalloonEngineBase>>#edgeLeftFillOf: */
    static long edgeLeftFillOf(final long edge) {
        return objat(edge, GEFillIndexLeft);
    }

    /* BalloonEngineBase>>#edgeLeftFillOf:put: */
    static void edgeLeftFillOfput(final long edge, final long value) {
        objatput(edge, GEFillIndexLeft, value);
    }

    /* BalloonEngineBase>>#edgeNumLinesOf: */
    static long edgeNumLinesOf(final long edge) {
        return objat(edge, GENumLines);
    }

    /* BalloonEngineBase>>#edgeNumLinesOf:put: */
    static void edgeNumLinesOfput(final long edge, final long value) {
        objatput(edge, GENumLines, value);
    }

    /* BalloonEngineBase>>#edgeRightFillOf: */
    static long edgeRightFillOf(final long edge) {
        return objat(edge, GEFillIndexRight);
    }

    /* BalloonEngineBase>>#edgeRightFillOf:put: */
    static void edgeRightFillOfput(final long edge, final long value) {
        objatput(edge, GEFillIndexRight, value);
    }

    /* BalloonEngineBase>>#edgeTransform */
    static float edgeTransformGet(final int index) {
        return Float.intBitsToFloat(workBuffer[GWEdgeTransform + index]);
    }

    static void edgeTransformSet(final int index, final float value) {
        workBuffer[GWEdgeTransform + index] = Float.floatToRawIntBits(value);
    }

    /* Return the edge type (e.g., witout the wide edge flag) */

    /* BalloonEngineBase>>#edgeTypeOf: */
    static int edgeTypeOf(final long edge) {
        return ((objectTypeOf(edge))) >> 1;
    }

    /* BalloonEngineBase>>#edgeXValueOf: */
    static long edgeXValueOf(final long edge) {
        return objat(edge, GEXValue);
    }

    /* BalloonEngineBase>>#edgeXValueOf:put: */
    static void edgeXValueOfput(final long edge, final long value) {
        objatput(edge, GEXValue, value);
    }

    /* BalloonEngineBase>>#edgeYValueOf: */
    static int edgeYValueOf(final long edge) {
        return objat(edge, GEYValue);
    }

    /* BalloonEngineBase>>#edgeYValueOf:put: */
    static void edgeYValueOfput(final long edge, final long value) {
        objatput(edge, GEYValue, value);
    }

    /* BalloonEngineBase>>#edgeZValueOf: */
    static long edgeZValueOf(final long edge) {
        return objat(edge, GEZValue);
    }

    /* BalloonEngineBase>>#edgeZValueOf:put: */
    static void edgeZValueOfput(final long edge, final long value) {
        objatput(edge, GEZValue, value);
    }

    /*
     * Ignore dispatch errors when translating to C (since we have no entry point for #error in the
     * VM proxy)
     */

    /* BalloonEngineBase>>#errorWrongIndex */
    static long errorWrongIndex() {
        return 0;
    }

    /*
     * Estimate the length of the vector described by deltaX and deltaY. This method may be
     * extremely inaccurate - use it only if you know exactly that this doesn't matter. Otherwise
     * use #accurateLengthOf:width:
     */

    /* BalloonEngineBase>>#estimatedLengthOf:with: */
    static long estimatedLengthOfwith(final long deltaX, final long deltaY) {
        final long absDx;
        final long absDy;

        if (deltaX >= 0) {
            absDx = deltaX;
        } else {
            absDx = 0 - deltaX;
        }
        if (deltaY >= 0) {
            absDy = deltaY;
        } else {
            absDy = 0 - deltaY;
        }
        if (absDx > absDy) {
            return absDx + (absDy / 2);
        } else {
            return absDy + (absDx / 2);
        }
    }

    /* Fill the span buffer from leftX to rightX with the given fill. */

    /* BalloonEngineBase>>#fillAllFrom:to: */
    static boolean fillAllFromto(final long leftX, final long rightX) {
        long fill;
        long startX;
        long stopX;

        fill = topFill();
        startX = leftX;
        stopX = topRightX();
        while (stopX < rightX) {
            fill = makeUnsignedFrom(topFill());
            if (!(fill == 0)) {
                if (fillSpanfromto(fill, startX, stopX)) {
                    return true;
                }
            }
            quickRemoveInvalidFillsAt(stopX);
            startX = stopX;
            stopX = topRightX();
        }
        fill = makeUnsignedFrom(topFill());
        if (!(fill == 0)) {
            return fillSpanfromto(fill, startX, rightX);
        }
        return false;
    }

    /* BalloonEnginePlugin>>#fillBitmapSpan */
    static void fillBitmapSpan() {
        fillBitmapSpanfromtoat(lastExportedFillGet(), lastExportedLeftXGet(), lastExportedRightXGet(), currentYGet());
    }

    /* BalloonEnginePlugin>>#fillBitmapSpanAA:from:to:at: */
    static void fillBitmapSpanAAfromtoat(final long bmFill, final long leftX, final long rightX, final long yValue) {
        final long aaLevel;
        final long baseShift;
        final int[] bits;
        final long bmHeight;
        final long bmWidth;
        long cMask;
        long cShift;
        final long deltaX;
        final long deltaY;
        long ds;
        final long dsX;
        long dt;
        final long dtX;
        long fillValue;
        final long firstPixel;
        int idx;
        final long lastPixel;
        final boolean tileFlag;
        long x;
        long xp;
        long yp;

        bits = loadBitsFrom(bmFill);
        if (bits == null) {
            return;
        }
        bmWidth = bitmapWidthOf(bmFill);
        bmHeight = bitmapHeightOf(bmFill);
        tileFlag = (bitmapTileFlagOf(bmFill)) == 1;
        deltaX = leftX - (fillOriginXOf(bmFill));
        deltaY = yValue - (fillOriginYOf(bmFill));
        dsX = fillDirectionXOf(bmFill);
        dtX = fillNormalXOf(bmFill);
        ds = (deltaX * dsX) + (deltaY * (fillDirectionYOf(bmFill)));
        dt = (deltaX * dtX) + (deltaY * (fillNormalYOf(bmFill)));
        aaLevel = aaLevelGet();
        firstPixel = aaFirstPixelFromto(leftX, rightX);
        lastPixel = aaLastPixelFromto(leftX, rightX);
        baseShift = aaShiftGet();
        cMask = aaColorMaskGet();
        cShift = aaColorShiftGet();
        x = leftX;
        while (x < firstPixel) {
            if (tileFlag) {
                ds = repeatValuemax(ds, ((bmWidth) << 16));
                dt = repeatValuemax(dt, ((bmHeight) << 16));
            }
            xp = ds / 65536;
            yp = dt / 65536;
            if (!tileFlag) {
                xp = clampValuemax(xp, bmWidth);
                yp = clampValuemax(yp, bmHeight);
            }
            if ((xp >= 0) && ((yp >= 0) && ((xp < bmWidth) && (yp < bmHeight)))) {
                fillValue = bitmapValuebitsatXy(bmFill, bits, xp, yp);
                fillValue = (fillValue & cMask) >> cShift;
                idx = (int) ((x) >> baseShift);
                spanBuffer[idx] = (int) ((spanBuffer[idx]) + fillValue);
            }
            ds += dsX;
            dt += dtX;
            x += 1;
        }
        cMask = (((aaColorMaskGet())) >> (aaShiftGet())) | 4042322160L;
        cShift = aaShiftGet();
        while (x < lastPixel) {
            if (tileFlag) {
                ds = repeatValuemax(ds, ((bmWidth) << 16));
                dt = repeatValuemax(dt, ((bmHeight) << 16));
            }
            xp = ds / 65536;
            yp = dt / 65536;
            if (!tileFlag) {
                xp = clampValuemax(xp, bmWidth);
                yp = clampValuemax(yp, bmHeight);
            }
            if ((xp >= 0) && ((yp >= 0) && ((xp < bmWidth) && (yp < bmHeight)))) {
                fillValue = bitmapValuebitsatXy(bmFill, bits, xp, yp);
                fillValue = (fillValue & cMask) >> cShift;
                idx = (int) ((x) >> baseShift);
                spanBuffer[idx] = (int) ((spanBuffer[idx]) + fillValue);
            }
            ds += ((dsX) << cShift);
            dt += ((dtX) << cShift);
            x += aaLevel;
        }
        cMask = aaColorMaskGet();
        cShift = aaColorShiftGet();
        while (x < rightX) {
            if (tileFlag) {
                ds = repeatValuemax(ds, ((bmWidth) << 16));
                dt = repeatValuemax(dt, ((bmHeight) << 16));
            }
            xp = ds / 65536;
            yp = dt / 65536;
            if (!tileFlag) {
                xp = clampValuemax(xp, bmWidth);
                yp = clampValuemax(yp, bmHeight);
            }
            if ((xp >= 0) && ((yp >= 0) && ((xp < bmWidth) && (yp < bmHeight)))) {
                fillValue = bitmapValuebitsatXy(bmFill, bits, xp, yp);
                fillValue = (fillValue & cMask) >> cShift;
                idx = (int) ((x) >> baseShift);
                spanBuffer[idx] = (int) ((spanBuffer[idx]) + fillValue);
            }
            ds += dsX;
            dt += dtX;
            x += 1;
        }
    }

    /*
     * Fill the span buffer between leftEdge and rightEdge using the given bits. Note: We always
     * start from zero - this avoids using huge bitmap buffers if the bitmap is to be displayed at
     * the very far right hand side and also gives us a chance of using certain bitmaps (e.g., those
     * with depth 32) directly.
     */

    /* BalloonEngineBase>>#fillBitmapSpan:from:to: */
    static void fillBitmapSpanfromto(final int[] bits, final long leftX, final long rightX) {
        final long baseShift;
        int bitX;
        final long colorMask;
        final long colorShift;
        int fillValue;
        int x;
        int x0;
        final int x1;

        x0 = (int) leftX;
        x1 = (int) rightX;

        /* Hack for pre-increment */
        bitX = -1;
        if ((aaLevelGet()) == 1) {
            /* Speedy version for no anti-aliasing */
            while (x0 < x1) {
                fillValue = bits[(bitX += 1)];
                spanBuffer[x0] = fillValue;
                x0 += 1;
            }
        } else {
            /* Generic version with anti-aliasing */
            colorMask = aaColorMaskGet();
            colorShift = aaColorShiftGet();
            baseShift = aaShiftGet();
            while (x0 < x1) {
                x = (x0) >> baseShift;
                fillValue = bits[(bitX += 1)];
                fillValue = (int) ((fillValue & colorMask) >> colorShift);
                spanBuffer[x] = ((spanBuffer[x]) + fillValue);
                x0 += 1;
            }
        }
        if (x1 > (spanEndGet())) {
            spanEndPut(x1);
        }
        if (x1 > (spanEndAAGet())) {
            spanEndAAPut(x1);
        }
    }

    /* BalloonEnginePlugin>>#fillBitmapSpan:from:to:at: */
    static void fillBitmapSpanfromtoat(final long bmFill, final long leftX, final long rightX, final long yValue) {
        final int[] bits;
        final long bmHeight;
        final long bmWidth;
        final long deltaX;
        final long deltaY;
        long ds;
        final long dsX;
        long dt;
        final long dtX;
        long fillValue;
        final boolean tileFlag;
        int x;
        final long x1;
        long xp;
        long yp;

        if (!((aaLevelGet()) == 1)) {
            fillBitmapSpanAAfromtoat(bmFill, leftX, rightX, yValue);
            return;
        }
        bits = loadBitsFrom(bmFill);
        if (bits == null) {
            return;
        }
        bmWidth = bitmapWidthOf(bmFill);
        bmHeight = bitmapHeightOf(bmFill);
        tileFlag = (bitmapTileFlagOf(bmFill)) == 1;
        deltaX = leftX - (fillOriginXOf(bmFill));
        deltaY = yValue - (fillOriginYOf(bmFill));
        dsX = fillDirectionXOf(bmFill);
        dtX = fillNormalXOf(bmFill);
        ds = (deltaX * dsX) + (deltaY * (fillDirectionYOf(bmFill)));
        dt = (deltaX * dtX) + (deltaY * (fillNormalYOf(bmFill)));
        x = (int) leftX;
        x1 = rightX;
        while (x < x1) {
            if (tileFlag) {
                ds = repeatValuemax(ds, ((bmWidth) << 16));
                dt = repeatValuemax(dt, ((bmHeight) << 16));
            }
            xp = ds / 65536;
            yp = dt / 65536;
            if (!tileFlag) {
                xp = clampValuemax(xp, bmWidth);
                yp = clampValuemax(yp, bmHeight);
            }
            if ((xp >= 0) && ((yp >= 0) && ((xp < bmWidth) && (yp < bmHeight)))) {
                fillValue = bitmapValuebitsatXy(bmFill, bits, xp, yp);
                spanBuffer[x] = (int) fillValue;
            }
            ds += dsX;
            dt += dtX;
            x += 1;
        }
        return;
    }

    /*
     * This is the inner loop for solid color fills with anti-aliasing. This loop has been unrolled
     * for speed and quality into three parts: a) copy all pixels that fall into the first full
     * pixel. b) copy aaLevel pixels between the first and the last full pixel c) copy all pixels
     * that fall in the last full pixel
     */

    /* BalloonEngineBase>>#fillColorSpanAA:x0:x1: */
    static void fillColorSpanAAx0x1(final long pixelValue32, final long leftX, final long rightX) {
        final long aaLevel;
        final long baseShift;
        final long colorMask;
        final long firstPixel;
        int idx;
        final long lastPixel;
        long pv32;
        int x;

        /* Not now -- maybe later */
        /* Compute the pixel boundaries. */
        firstPixel = aaFirstPixelFromto(leftX, rightX);
        lastPixel = aaLastPixelFromto(leftX, rightX);
        aaLevel = aaLevelGet();
        baseShift = aaShiftGet();
        /* Part a: Deal with the first n sub-pixels */
        x = (int) leftX;
        if (x < firstPixel) {
            pv32 = (pixelValue32 & (aaColorMaskGet())) >> (aaColorShiftGet());
            while (x < firstPixel) {
                idx = (x) >> baseShift;
                spanBuffer[idx] = (int) ((spanBuffer[idx]) + pv32);
                x += 1;
            }
        }
        if (x < lastPixel) {
            colorMask = (((aaColorMaskGet())) >> (aaShiftGet())) | 4042322160L;
            pv32 = (pixelValue32 & colorMask) >> (aaShiftGet());
            while (x < lastPixel) {
                idx = (x) >> baseShift;
                spanBuffer[idx] = (int) ((spanBuffer[idx]) + pv32);
                x += aaLevel;
            }
        }
        if (x < rightX) {
            pv32 = (pixelValue32 & (aaColorMaskGet())) >> (aaColorShiftGet());
            while (x < rightX) {
                idx = (x) >> baseShift;
                spanBuffer[idx] = (int) ((spanBuffer[idx]) + pv32);
                x += 1;
            }
        }
    }

    /*
     * Fill the span buffer between leftEdge and rightEdge with the given pixel value.
     */

    /* BalloonEngineBase>>#fillColorSpan:from:to: */
    static void fillColorSpanfromto(final int pixelValue32, final long leftX, final long rightX) {
        int x0;
        final int x1;

        /* Use a unrolled version for anti-aliased fills... */
        if (!((aaLevelGet()) == 1)) {
            fillColorSpanAAx0x1(pixelValue32, leftX, rightX);
            return;
        }
        x0 = (int) leftX;
        /* Unroll the inner loop four times, since we're only storing data. */
        x1 = (int) rightX;
        while ((x0 + 4) < x1) {
            spanBuffer[x0] = pixelValue32;
            spanBuffer[x0 + 1] = pixelValue32;
            spanBuffer[x0 + 2] = pixelValue32;
            spanBuffer[x0 + 3] = pixelValue32;
            x0 += 4;
        }
        while (x0 < x1) {
            spanBuffer[x0] = pixelValue32;
            x0 += 1;
        }
    }

    /* BalloonEnginePlugin>>#fillDirectionXOf: */
    static long fillDirectionXOf(final long fill) {
        return objat(fill, GFDirectionX);
    }

    /* BalloonEnginePlugin>>#fillDirectionXOf:put: */
    static void fillDirectionXOfput(final long fill, final long value) {
        objatput(fill, GFDirectionX, value);
    }

    /* BalloonEnginePlugin>>#fillDirectionYOf: */
    static long fillDirectionYOf(final long fill) {
        return objat(fill, GFDirectionY);
    }

    /* BalloonEnginePlugin>>#fillDirectionYOf:put: */
    static void fillDirectionYOfput(final long fill, final long value) {
        objatput(fill, GFDirectionY, value);
    }

    /* BalloonEnginePlugin>>#fillLinearGradient */
    static void fillLinearGradient() {
        fillLinearGradientfromtoat(lastExportedFillGet(), lastExportedLeftXGet(), lastExportedRightXGet(), currentYGet());
    }

    /* This is the AA version of linear gradient filling. */

    /* BalloonEnginePlugin>>#fillLinearGradientAA:ramp:ds:dsX:from:to: */
    static long fillLinearGradientAArampdsdsXfromto(final long fill, final int rampPtr, final long deltaS, final long dsX, final long leftX, final long rightX) {
        final long aaLevel;
        final long baseShift;
        long colorMask;
        long colorShift;
        long ds;
        final long firstPixel;
        int idx;
        final long lastPixel;
        int rampIndex;
        final long rampSize;
        long rampValue;
        int x;

        aaLevel = aaLevelGet();
        baseShift = aaShiftGet();
        rampSize = gradientRampLengthOf(fill);
        ds = deltaS;
        x = (int) leftX;
        rampIndex = (int) (ds / 65536);
        firstPixel = aaFirstPixelFromto(leftX, rightX);

        /* Deal with the first n sub-pixels */
        lastPixel = aaLastPixelFromto(leftX, rightX);
        colorMask = aaColorMaskGet();
        colorShift = aaColorShiftGet();
        while ((x < firstPixel) && ((rampIndex < rampSize) && (rampIndex >= 0))) {
            rampValue = unsignedAt(rampPtr + rampIndex);
            /* Copy as many pixels as possible */
            rampValue = (rampValue & colorMask) >> colorShift;
            while ((x < firstPixel) && ((ds / 65536) == rampIndex)) {
                idx = (x) >> baseShift;
                spanBuffer[idx] = (int) ((spanBuffer[idx]) + rampValue);
                x += 1;
                ds += dsX;
            }
            rampIndex = (int) (ds / 65536);
        }
        colorMask = (((aaColorMaskGet())) >> (aaShiftGet())) | 4042322160L;
        colorShift = aaShiftGet();
        while ((x < lastPixel) && ((rampIndex < rampSize) && (rampIndex >= 0))) {
            rampValue = unsignedAt(rampPtr + rampIndex);
            /* Copy as many pixels as possible */
            rampValue = (rampValue & colorMask) >> colorShift;
            while ((x < lastPixel) && ((ds / 65536) == rampIndex)) {
                idx = (x) >> baseShift;
                spanBuffer[idx] = (int) ((spanBuffer[idx]) + rampValue);
                x += aaLevel;
                ds += ((dsX) << colorShift);
            }
            rampIndex = (int) (ds / 65536);
        }
        colorMask = aaColorMaskGet();
        colorShift = aaColorShiftGet();
        while ((x < rightX) && ((rampIndex < rampSize) && (rampIndex >= 0))) {
            rampValue = unsignedAt(rampPtr + rampIndex);
            /* Copy as many pixels as possible */
            rampValue = (rampValue & colorMask) >> colorShift;
            while ((x < rightX) && ((ds / 65536) == rampIndex)) {
                idx = (x) >> baseShift;
                spanBuffer[idx] = (int) ((spanBuffer[idx]) + rampValue);
                x += 1;
                ds += dsX;
            }
            rampIndex = (int) (ds / 65536);
        }
        return x;
    }

    /* Draw a linear gradient fill. */

    /* BalloonEnginePlugin>>#fillLinearGradient:from:to:at: */
    static void fillLinearGradientfromtoat(final long fill, final long leftX, final long rightX, final long yValue) {
        long ds;
        final long dsX;
        final int rampPtr;
        int rampIndex;
        final int rampSize;
        int x;
        final long x0;
        final long x1;

        rampPtr = gradientRampIndexOf(fill);
        rampSize = (int) gradientRampLengthOf(fill);
        dsX = fillDirectionXOf(fill);
        ds = ((leftX - (fillOriginXOf(fill))) * dsX) + ((yValue - (fillOriginYOf(fill))) * (fillDirectionYOf(fill)));
        x = (int) (x0 = leftX);
        /* Note: The inner loop has been divided into three parts for speed */
        /* Part one: Fill everything outside the left boundary */
        x1 = rightX;
        while (((((rampIndex = (int) (ds / 65536))) < 0) || (rampIndex >= rampSize)) && (x < x1)) {
            x += 1;
            ds += dsX;
        }
        if (x > x0) {
            if (rampIndex < 0) {
                rampIndex = 0;
            }
            if (rampIndex >= rampSize) {
                rampIndex = rampSize - 1;
            }
            fillColorSpanfromto(workBuffer[rampPtr + rampIndex], x0, x);
        }
        if ((aaLevelGet()) == 1) {
            /* Fast version w/o anti-aliasing */
            while (((((rampIndex = (int) (ds / 65536))) < rampSize) && (rampIndex >= 0)) && (x < x1)) {
                spanBuffer[x] = (int) (unsignedAt(rampPtr + rampIndex));
                x += 1;
                ds += dsX;
            }
        } else {
            x = (int) fillLinearGradientAArampdsdsXfromto(fill, rampPtr, ds, dsX, x, rightX);
        }
        if (x < x1) {
            if (rampIndex < 0) {
                rampIndex = 0;
            }
            if (rampIndex >= rampSize) {
                rampIndex = rampSize - 1;
            }
            fillColorSpanfromto(workBuffer[rampPtr + rampIndex], x, x1);
        }
    }

    /* BalloonEngineBase>>#fillMaxXGet */
    static int fillMaxXGet() {
        return workBuffer[GWFillMaxX];
    }

    /* BalloonEngineBase>>#fillMaxXPut: */
    static long fillMaxXPut(final long value) {
        return workBuffer[GWFillMaxX] = (int) value;
    }

    /* BalloonEngineBase>>#fillMaxYGet */
    static int fillMaxYGet() {
        return workBuffer[GWFillMaxY];
    }

    /* BalloonEngineBase>>#fillMaxYPut: */
    static long fillMaxYPut(final long value) {
        return workBuffer[GWFillMaxY] = (int) value;
    }

    /* BalloonEngineBase>>#fillMinXGet */
    static int fillMinXGet() {
        return workBuffer[GWFillMinX];
    }

    /* BalloonEngineBase>>#fillMinXPut: */
    static long fillMinXPut(final long value) {
        return workBuffer[GWFillMinX] = (int) value;
    }

    /* BalloonEngineBase>>#fillMinYGet */
    static int fillMinYGet() {
        return workBuffer[GWFillMinY];
    }

    /* BalloonEngineBase>>#fillMinYPut: */
    static long fillMinYPut(final long value) {
        return workBuffer[GWFillMinY] = (int) value;
    }

    /* BalloonEnginePlugin>>#fillNormalXOf: */
    static long fillNormalXOf(final long fill) {
        return objat(fill, GFNormalX);
    }

    /* BalloonEnginePlugin>>#fillNormalXOf:put: */
    static void fillNormalXOfput(final long fill, final long value) {
        objatput(fill, GFNormalX, value);
    }

    /* BalloonEnginePlugin>>#fillNormalYOf: */
    static long fillNormalYOf(final long fill) {
        return objat(fill, GFNormalY);
    }

    /* BalloonEnginePlugin>>#fillNormalYOf:put: */
    static void fillNormalYOfput(final long fill, final long value) {
        objatput(fill, GFNormalY, value);
    }

    /* BalloonEngineBase>>#fillOffsetXGet */
    static long fillOffsetXGet() {
        return workBuffer[GWFillOffsetX];
    }

    /* BalloonEngineBase>>#fillOffsetXPut: */
    static long fillOffsetXPut(final long value) {
        return workBuffer[GWFillOffsetX] = (int) value;
    }

    /* BalloonEngineBase>>#fillOffsetYGet */
    static int fillOffsetYGet() {
        return workBuffer[GWFillOffsetY];
    }

    /* BalloonEngineBase>>#fillOffsetYPut: */
    static long fillOffsetYPut(final long value) {
        return workBuffer[GWFillOffsetY] = (int) value;
    }

    /* BalloonEnginePlugin>>#fillOriginXOf: */
    static long fillOriginXOf(final long fill) {
        return objat(fill, GFOriginX);
    }

    /* BalloonEnginePlugin>>#fillOriginXOf:put: */
    static void fillOriginXOfput(final long fill, final long value) {
        objatput(fill, GFOriginX, value);
    }

    /* BalloonEnginePlugin>>#fillOriginYOf: */
    static long fillOriginYOf(final long fill) {
        return objat(fill, GFOriginY);
    }

    /* BalloonEnginePlugin>>#fillOriginYOf:put: */
    static void fillOriginYOfput(final long fill, final long value) {
        objatput(fill, GFOriginY, value);
    }

    /* Part 2a) Compute the decreasing part of the ramp */

    /* BalloonEnginePlugin>>#fillRadialDecreasingAA:ramp:deltaST:dsX:dtX:from:to: */
    static long fillRadialDecreasingAArampdeltaSTdsXdtXfromto(final long fill, final int rampPtr, final long dsX, final long dtX, final long leftX, final long rightX) {
        final long aaLevel;
        final long baseShift;
        long colorMask;
        long colorShift;
        int ds;
        int dt;
        final long firstPixel;
        int index;
        final long lastPixel;
        long length2;
        long nextLength;
        int rampIndex;
        long rampValue;
        int x;
        long x1;

        ds = point1GetX();
        dt = point1GetY();
        aaLevel = aaLevelGet();
        baseShift = aaShiftGet();
        rampIndex = (int) accurateLengthOfwith(ds / 65536, dt / 65536);
        length2 = (rampIndex - 1) * (rampIndex - 1);
        x = (int) leftX;
        x1 = fillOriginXOf(fill);
        if (x1 > rightX) {
            x1 = rightX;
        }
        firstPixel = aaFirstPixelFromto(leftX, x1);

        /* Deal with the first n sub-pixels */
        lastPixel = aaLastPixelFromto(leftX, x1);
        if (x < firstPixel) {
            colorMask = aaColorMaskGet();
            colorShift = aaColorShiftGet();
            rampValue = unsignedAt(rampPtr + rampIndex);
            rampValue = (rampValue & colorMask) >> colorShift;
            while (x < firstPixel) {
                /* Try to copy the current value more than just once */
                while ((x < firstPixel) && ((squaredLengthOfwith(ds / 65536, dt / 65536)) >= length2)) {
                    index = (x) >> baseShift;
                    spanBuffer[index] = (int) ((spanBuffer[index]) + rampValue);
                    x += 1;
                    ds += dsX;
                    dt += dtX;
                }
                nextLength = squaredLengthOfwith(ds / 65536, dt / 65536);
                while (nextLength < length2) {
                    rampIndex -= 1;
                    rampValue = unsignedAt(rampPtr + rampIndex);
                    rampValue = (rampValue & colorMask) >> colorShift;
                    length2 = (rampIndex - 1) * (rampIndex - 1);
                }
            }
        }
        if (x < lastPixel) {
            colorMask = (((aaColorMaskGet())) >> (aaShiftGet())) | 4042322160L;
            colorShift = aaShiftGet();
            rampValue = unsignedAt(rampPtr + rampIndex);
            rampValue = (rampValue & colorMask) >> colorShift;
            while (x < lastPixel) {
                /* Try to copy the current value more than just once */
                while ((x < lastPixel) && ((squaredLengthOfwith(ds / 65536, dt / 65536)) >= length2)) {
                    index = (x) >> baseShift;
                    spanBuffer[index] = (int) ((spanBuffer[index]) + rampValue);
                    x += aaLevel;
                    ds += ((dsX) << colorShift);
                    dt += ((dtX) << colorShift);
                }
                nextLength = squaredLengthOfwith(ds / 65536, dt / 65536);
                while (nextLength < length2) {
                    rampIndex -= 1;
                    rampValue = unsignedAt(rampPtr + rampIndex);
                    rampValue = (rampValue & colorMask) >> colorShift;
                    length2 = (rampIndex - 1) * (rampIndex - 1);
                }
            }
        }
        if (x < x1) {
            colorMask = aaColorMaskGet();
            colorShift = aaColorShiftGet();
            rampValue = unsignedAt(rampPtr + rampIndex);
            rampValue = (rampValue & colorMask) >> colorShift;
            while (x < x1) {
                /* Try to copy the current value more than just once */
                while ((x < x1) && ((squaredLengthOfwith(ds / 65536, dt / 65536)) >= length2)) {
                    index = (x) >> baseShift;
                    spanBuffer[index] = (int) ((spanBuffer[index]) + rampValue);
                    x += 1;
                    ds += dsX;
                    dt += dtX;
                }
                nextLength = squaredLengthOfwith(ds / 65536, dt / 65536);
                while (nextLength < length2) {
                    rampIndex -= 1;
                    rampValue = unsignedAt(rampPtr + rampIndex);
                    rampValue = (rampValue & colorMask) >> colorShift;
                    length2 = (rampIndex - 1) * (rampIndex - 1);
                }
            }
        }
        point1SetX(ds);
        point1SetY(dt);
        return x;
    }

    /* Part 2a) Compute the decreasing part of the ramp */

    /* BalloonEnginePlugin>>#fillRadialDecreasing:ramp:deltaST:dsX:dtX:from:to: */
    static long fillRadialDecreasingrampdeltaSTdsXdtXfromto(final long fill, final int rampPtr, final long dsX, final long dtX, final long leftX, final long rightX) {
        int ds;
        int dt;
        long length2;
        long nextLength;
        int rampIndex;
        long rampValue;
        int x;
        long x1;

        ds = point1GetX();
        dt = point1GetY();
        rampIndex = (int) accurateLengthOfwith(ds / 65536, dt / 65536);
        rampValue = unsignedAt(rampPtr + rampIndex);
        length2 = (rampIndex - 1) * (rampIndex - 1);
        x = (int) leftX;
        x1 = rightX;
        if (x1 > (fillOriginXOf(fill))) {
            x1 = fillOriginXOf(fill);
        }
        while (x < x1) {
            /* Try to copy the current value more than just once */
            while ((x < x1) && ((squaredLengthOfwith(ds / 65536, dt / 65536)) >= length2)) {
                spanBuffer[x] = (int) rampValue;
                x += 1;
                ds += dsX;
                dt += dtX;
            }
            nextLength = squaredLengthOfwith(ds / 65536, dt / 65536);
            while (nextLength < length2) {
                rampIndex -= 1;
                rampValue = unsignedAt(rampPtr + rampIndex);
                length2 = (rampIndex - 1) * (rampIndex - 1);
            }
        }
        point1SetX(ds);
        point1SetY(dt);
        return x;
    }

    /* BalloonEnginePlugin>>#fillRadialGradient */
    static void fillRadialGradient() {
        fillRadialGradientfromtoat(lastExportedFillGet(), lastExportedLeftXGet(), lastExportedRightXGet(), currentYGet());
    }

    /* Draw a radial gradient fill. */

    /* BalloonEnginePlugin>>#fillRadialGradient:from:to:at: */
    static void fillRadialGradientfromtoat(final long fill, final long leftX, final long rightX, final long yValue) {
        final long deltaX;
        final long deltaY;
        long ds;
        final long dsX;
        long dt;
        final long dtX;
        final long length2;
        final int rampPtr;
        final int rampSize;
        long x;
        final long x1;

        rampPtr = gradientRampIndexOf(fill);
        rampSize = (int) gradientRampLengthOf(fill);
        deltaX = leftX - (fillOriginXOf(fill));
        deltaY = yValue - (fillOriginYOf(fill));
        dsX = fillDirectionXOf(fill);
        dtX = fillNormalXOf(fill);
        ds = (deltaX * dsX) + (deltaY * (fillDirectionYOf(fill)));
        dt = (deltaX * dtX) + (deltaY * (fillNormalYOf(fill)));
        x = leftX;

        /* Note: The inner loop has been divided into three parts for speed */
        /* Part one: Fill everything outside the left boundary */
        x1 = rightX;
        /* This is the upper bound */
        length2 = (rampSize - 1) * (rampSize - 1);
        while (((squaredLengthOfwith(ds / 65536, dt / 65536)) >= length2) && (x < x1)) {
            x += 1;
            ds += dsX;
            dt += dtX;
        }
        if (x > leftX) {
            fillColorSpanfromto(workBuffer[rampPtr + rampSize - 1], leftX, x);
        }
        point1SetX(ds);
        point1SetY(dt);
        if (x < (fillOriginXOf(fill))) {
            /* Draw the decreasing part */
            if ((aaLevelGet()) == 1) {
                x = fillRadialDecreasingrampdeltaSTdsXdtXfromto(fill, rampPtr, dsX, dtX, x, x1);
            } else {
                x = fillRadialDecreasingAArampdeltaSTdsXdtXfromto(fill, rampPtr, dsX, dtX, x, x1);
            }
        }
        if (x < x1) {
            /* Draw the increasing part */
            if ((aaLevelGet()) == 1) {
                x = fillRadialIncreasingrampdeltaSTdsXdtXfromto(fill, rampPtr, dsX, dtX, x, x1);
            } else {
                x = fillRadialIncreasingAArampdeltaSTdsXdtXfromto(fill, rampPtr, dsX, dtX, x, x1);
            }
        }
        if (x < rightX) {
            fillColorSpanfromto(workBuffer[rampPtr + rampSize - 1], x, rightX);
        }
    }

    /* Part 2b) Compute the increasing part of the ramp */

    /* BalloonEnginePlugin>>#fillRadialIncreasingAA:ramp:deltaST:dsX:dtX:from:to: */
    static long fillRadialIncreasingAArampdeltaSTdsXdtXfromto(final long fill, final int rampPtr, final long dsX, final long dtX, final long leftX, final long rightX) {
        final long aaLevel;
        final long baseShift;
        long colorMask;
        long colorShift;
        int ds;
        int dt;
        final long firstPixel;
        int index;
        long lastLength;
        final long lastPixel;
        final long length2;
        long nextLength;
        int rampIndex;
        final long rampSize;
        long rampValue;
        int x;

        ds = point1GetX();
        dt = point1GetY();
        aaLevel = aaLevelGet();
        baseShift = aaShiftGet();
        rampIndex = (int) accurateLengthOfwith(ds / 65536, dt / 65536);
        rampSize = gradientRampLengthOf(fill);
        /* This is the upper bound */
        length2 = (rampSize - 1) * (rampSize - 1);
        nextLength = (rampIndex + 1) * (rampIndex + 1);
        lastLength = squaredLengthOfwith(ds / 65536, dt / 65536);
        x = (int) leftX;
        firstPixel = aaFirstPixelFromto(leftX, rightX);
        /* Deal with the first n subPixels */
        lastPixel = aaLastPixelFromto(leftX, rightX);
        if ((x < firstPixel) && (lastLength < length2)) {
            colorMask = aaColorMaskGet();
            colorShift = aaColorShiftGet();
            rampValue = unsignedAt(rampPtr + rampIndex);
            rampValue = (rampValue & colorMask) >> colorShift;
            while ((x < firstPixel) && (lastLength < length2)) {
                /* Try to copy the current value more than once */
                while ((x < firstPixel) && ((squaredLengthOfwith(ds / 65536, dt / 65536)) <= nextLength)) {
                    index = (x) >> baseShift;
                    spanBuffer[index] = (int) ((spanBuffer[index]) + rampValue);
                    x += 1;
                    ds += dsX;
                    dt += dtX;
                }
                lastLength = squaredLengthOfwith(ds / 65536, dt / 65536);
                while (lastLength > nextLength) {
                    rampIndex += 1;
                    rampValue = unsignedAt(rampPtr + rampIndex);
                    rampValue = (rampValue & colorMask) >> colorShift;
                    nextLength = (rampIndex + 1) * (rampIndex + 1);
                }
            }
        }
        if ((x < lastPixel) && (lastLength < length2)) {
            colorMask = (((aaColorMaskGet())) >> (aaShiftGet())) | 4042322160L;
            colorShift = aaShiftGet();
            rampValue = unsignedAt(rampPtr + rampIndex);
            rampValue = (rampValue & colorMask) >> colorShift;
            while ((x < lastPixel) && (lastLength < length2)) {
                /* Try to copy the current value more than once */
                while ((x < lastPixel) && ((squaredLengthOfwith(ds / 65536, dt / 65536)) <= nextLength)) {
                    index = (x) >> baseShift;
                    spanBuffer[index] = (int) ((spanBuffer[index]) + rampValue);
                    x += aaLevel;
                    ds += ((dsX) << colorShift);
                    dt += ((dtX) << colorShift);
                }
                lastLength = squaredLengthOfwith(ds / 65536, dt / 65536);
                while (lastLength > nextLength) {
                    rampIndex += 1;
                    rampValue = unsignedAt(rampPtr + rampIndex);
                    rampValue = (rampValue & colorMask) >> colorShift;
                    nextLength = (rampIndex + 1) * (rampIndex + 1);
                }
            }
        }
        if ((x < rightX) && (lastLength < length2)) {
            colorMask = aaColorMaskGet();
            colorShift = aaColorShiftGet();
            rampValue = unsignedAt(rampPtr + rampIndex);
            rampValue = (rampValue & colorMask) >> colorShift;
            while ((x < rightX) && (lastLength < length2)) {
                /* Try to copy the current value more than once */
                while ((x < rightX) && ((squaredLengthOfwith(ds / 65536, dt / 65536)) <= nextLength)) {
                    index = (x) >> baseShift;
                    spanBuffer[index] = (int) ((spanBuffer[index]) + rampValue);
                    x += 1;
                    ds += dsX;
                    dt += dtX;
                }
                lastLength = squaredLengthOfwith(ds / 65536, dt / 65536);
                while (lastLength > nextLength) {
                    rampIndex += 1;
                    rampValue = unsignedAt(rampPtr + rampIndex);
                    rampValue = (rampValue & colorMask) >> colorShift;
                    nextLength = (rampIndex + 1) * (rampIndex + 1);
                }
            }
        }
        point1SetX(ds);
        point1SetY(dt);
        return x;
    }

    /* Part 2b) Compute the increasing part of the ramp */

    /* BalloonEnginePlugin>>#fillRadialIncreasing:ramp:deltaST:dsX:dtX:from:to: */
    static long fillRadialIncreasingrampdeltaSTdsXdtXfromto(final long fill, final int rampPtr, final long dsX, final long dtX, final long leftX, final long rightX) {
        int ds;
        int dt;
        long lastLength;
        final long length2;
        long nextLength;
        int rampIndex;
        final long rampSize;
        long rampValue;
        int x;
        final long x1;

        ds = point1GetX();
        dt = point1GetY();
        rampIndex = (int) accurateLengthOfwith(ds / 65536, dt / 65536);
        rampValue = unsignedAt(rampPtr + rampIndex);
        rampSize = gradientRampLengthOf(fill);

        /* This is the upper bound */
        length2 = (rampSize - 1) * (rampSize - 1);
        nextLength = (rampIndex + 1) * (rampIndex + 1);
        lastLength = squaredLengthOfwith(ds / 65536, dt / 65536);
        x = (int) leftX;
        x1 = rightX;
        while ((x < x1) && (lastLength < length2)) {
            /* Try to copy the current value more than once */
            while ((x < x1) && ((squaredLengthOfwith(ds / 65536, dt / 65536)) <= nextLength)) {
                spanBuffer[x] = (int) rampValue;
                x += 1;
                ds += dsX;
                dt += dtX;
            }
            lastLength = squaredLengthOfwith(ds / 65536, dt / 65536);
            while (lastLength > nextLength) {
                rampIndex += 1;
                rampValue = unsignedAt(rampPtr + rampIndex);
                nextLength = (rampIndex + 1) * (rampIndex + 1);
            }
        }
        point1SetX(ds);
        point1SetY(dt);
        return x;
    }

    /* Return true if fillEntry1 should be drawn before fillEntry2 */

    /* BalloonEngineBase>>#fillSorts:before: */
    static boolean fillSortsbefore(final long fillEntry1, final long fillEntry2) {
        final long diff;

        /* First check the depth value */
        diff = (stackFillDepth(fillEntry1)) - (stackFillDepth(fillEntry2));
        if (!(diff == 0)) {
            return diff > 0;
        }
        return (((makeUnsignedFrom(stackFillValue(fillEntry1))))) < (((makeUnsignedFrom(stackFillValue(fillEntry2)))));
    }

    /*
     * Fill the span buffer from leftX to rightX with the given fill. Clip before performing any
     * operations. Return true if the fill must be handled by some Smalltalk code.
     */

    /* BalloonEngineBase>>#fillSpan:from:to: */
    static boolean fillSpanfromto(final long fill, final long leftX, final long rightX) {
        final int type;
        long x0;
        long x1;

        if (fill == 0) {
            return false;
        }
        if (leftX < (spanEndAAGet())) {
            x0 = spanEndAAGet();
        } else {
            x0 = leftX;
        }
        if (rightX > (((long) ((spanSizeGet())) << (aaShiftGet())))) {
            x1 = ((long) ((spanSizeGet())) << (aaShiftGet()));
        } else {
            x1 = rightX;
        }
        if (x0 < (fillMinXGet())) {
            x0 = fillMinXGet();
        }
        if (x1 > (fillMaxXGet())) {
            x1 = fillMaxXGet();
        }
        if (x0 < (spanStartGet())) {
            spanStartPut(x0);
        }
        if (x1 > (spanEndGet())) {
            spanEndPut(x1);
        }
        if (x1 > (spanEndAAGet())) {
            spanEndAAPut(x1);
        }
        if (x0 >= x1) {
            return false;
        }
        if (isFillColor(fill)) {
            fillColorSpanfromto((int) fill, x0, x1);
        } else {
            /* Store the values for the dispatch */
            workBuffer[GWLastExportedFill] = (int) fill;
            workBuffer[GWLastExportedLeftX] = (int) x0;
            workBuffer[GWLastExportedRightX] = (int) x1;
            type = (int) (((long) ((objectTypeOf(fill)) & GEPrimitiveFillMask)) >> 8);
            if (type <= 1) {
                return true;
            }
            switch (type) {
                case 0:
                case 1:
                    errorWrongIndex();
                    break;
                case 2:
                    fillLinearGradient();
                    break;
                case 3:
                    fillRadialGradient();
                    break;
                case 4:
                case 5:
                    fillBitmapSpan();
                    break;
            }
        }
        return false;
    }

    /* BalloonEngineBase>>#fillTypeOf: */
    static long fillTypeOf(final long fill) {
        return ((long) ((objectTypeOf(fill)) & GEPrimitiveFillMask)) >> 8;
    }

    /* BalloonEngineBase>>#findNextAETEdgeFrom: -> has no senders */

    /*
     * Check the global edge table for any entries that cannot be handled by the engine itself. If
     * there are any, return true. Otherwise, initialize the the edge and add it to the AET
     */

    /* BalloonEngineBase>>#findNextExternalEntryFromGET */
    static boolean findNextExternalEntryFromGET() {
        int edge;
        int type;
        final long yValue;

        /* As long as we have entries in the GET */
        yValue = currentYGet();
        while ((getStartGet()) < (getUsedGet())) {
            edge = getBuffer(getStartGet());
            if ((edgeYValueOf(edge)) > yValue) {
                return false;
            }
            type = objectTypeOf(edge);
            if ((type & GEPrimitiveWideMask) == GEPrimitiveEdge) {
                return true;
            }
            if (!(needAvailableSpace(1))) {
                return false;
            }
            switch (type) {
                case 0:
                case 1:
                case 2:
                case 3:
                    errorWrongIndex();
                    break;
                case 4:
                    stepToFirstLine();
                    break;
                case 5:
                    stepToFirstWideLine();
                    break;
                case 6:
                    stepToFirstBezier();
                    break;
                case 7:
                    stepToFirstWideBezier();
                    break;
            }
            insertEdgeIntoAET(edge);
            getStartPut((getStartGet()) + 1);
        }
        return false;
    }

    /*
     * Scan the active edge table. If there is any fill that cannot be handled by the engine itself,
     * return true. Otherwise handle the fills and return false.
     */
    /*
     * self currentYGet >= 680 ifTrue:[ self printAET. self halt. ].
     */

    /* BalloonEngineBase>>#findNextExternalFillFromAET */
    static boolean findNextExternalFillFromAET() {
        int leftEdge;
        long leftX;
        int rightEdge;
        long rightX;

        leftX = (rightX = fillMaxXGet());
        while ((aetStartGet()) < (aetUsedGet())) {
            /*
             * TODO: We should check if leftX from last operation is greater than leftX from next
             * edge. Currently, we rely here on spanEndAA from the span buffer fill.
             */
            leftEdge = (rightEdge = aetBuffer(aetStartGet()));
            leftX = (rightX = edgeXValueOf(leftEdge));
            if (leftX >= (fillMaxXGet())) {
                return false;
            }
            quickRemoveInvalidFillsAt(leftX);
            if (isWide(leftEdge)) {
                toggleWideFillOf(leftEdge);
            }
            if (((makeUnsignedFrom(objat(leftEdge, GEObjectType))) & GEEdgeFillsInvalid) == 0) {
                toggleFillsOf(leftEdge);
                if (engineStopped) {
                    return false;
                }
            }
            aetStartPut((aetStartGet()) + 1);
            if ((aetStartGet()) < (aetUsedGet())) {
                rightEdge = aetBuffer(aetStartGet());
                rightX = edgeXValueOf(rightEdge);
                if (rightX >= (fillMinXGet())) {
                    /* This is the visible portion */
                    fillAllFromto(leftX, rightX);
                }
            }
        }
        if (rightX < (fillMaxXGet())) {
            fillAllFromto(rightX, fillMaxXGet());
        }
        return false;
    }

    /*
     * Check the active edge table for any entries that cannot be handled by the engine itself. If
     * there are any, return true. Otherwise, step the the edge to the next y value.
     */

    /* BalloonEngineBase>>#findNextExternalUpdateFromAET */
    static boolean findNextExternalUpdateFromAET() {
        long count;
        int edge;
        int type;

        while ((aetStartGet()) < (aetUsedGet())) {
            edge = aetBuffer(aetStartGet());
            count = (edgeNumLinesOf(edge)) - 1;
            if (count == 0) {
                /* Edge at end -- remove it */
                removeFirstAETEntry();
            } else {
                /* Store remaining lines back */
                edgeNumLinesOfput(edge, count);
                type = objectTypeOf(edge);
                if ((type & GEPrimitiveWideMask) == GEPrimitiveEdge) {
                    return true;
                }
                switch (type) {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        errorWrongIndex();
                        break;
                    case 4:
                        stepToNextLine();
                        break;
                    case 5:
                        stepToNextWideLine();
                        break;
                    case 6:
                        stepToNextBezier();
                        break;
                    case 7:
                        stepToNextWideBezier();
                        break;
                }
                resortFirstAETEntry();
                aetStartPut((aetStartGet()) + 1);
            }
        }
        return false;
    }

    /* BalloonEngineBase>>#findStackFill:depth: */
    static long findStackFilldepth(final long fillIndex, final long depth) {
        long index;

        index = 0;
        while ((index < (stackFillSize())) && (((stackFillValue(index)) != fillIndex) || ((stackFillDepth(index)) != depth))) {
            index += stackFillEntryLength();
        }
        if (index >= (stackFillSize())) {
            return -1;
        } else {
            return index;
        }
    }

    /* Return true if processing is finished */

    /* BalloonEngineBase>>#finishedProcessing */
    static boolean finishedProcessing() {
        return (stateGet()) == GEStateCompleted;
    }

    /* BalloonEngineBase>>#firstPointListGet */
    static int firstPointListGet() {
        return workBuffer[GWPointListFirst];
    }

    /* BalloonEngineBase>>#firstPointListPut: */
    static long firstPointListPut(final long value) {
        return workBuffer[GWPointListFirst] = (int) value;
    }

    /* BalloonEngineBase>>#freeStackFillEntry */
    static long freeStackFillEntry() {
        final long nItems;

        /* begin wbStackPop: */
        nItems = stackFillEntryLength();
        wbTopPut((wbTopGet()) + nItems);
        return 0;
    }

    /*
     * Note: This is hardcoded so it can be run from Squeak. The module name is used for validating
     * a module *after* it is loaded to check if it does really contain the module we're thinking it
     * contains. This is important!
     */

    /* InterpreterPlugin>>#getModuleName */
    public static String getModuleName() {
        return moduleName;
    }

    /* Return true if the edge at index i should sort before the edge at index j. */

    /* BalloonEngineBase>>#getSorts:before: */
    static boolean getSortsbefore(final long edge1, final long edge2) {
        long diff;

        if (edge1 == edge2) {
            return true;
        }
        diff = (edgeYValueOf(edge1)) - (edgeYValueOf(edge2));
        if (!(diff == 0)) {
            return diff < 0;
        }
        diff = (edgeXValueOf(edge1)) - (edgeXValueOf(edge2));
        return diff < 0;
    }

    /* BalloonEngineBase>>#getStartGet */
    static int getStartGet() {
        return workBuffer[GWGETStart];
    }

    /* BalloonEngineBase>>#getStartPut: */
    static long getStartPut(final long value) {
        return workBuffer[GWGETStart] = (int) value;
    }

    /* BalloonEngineBase>>#getUsedGet */
    static int getUsedGet() {
        return workBuffer[GWGETUsed];
    }

    /* BalloonEngineBase>>#getUsedPut: */
    static long getUsedPut(final long value) {
        return workBuffer[GWGETUsed] = (int) value;
    }

    /* BalloonEnginePlugin>>#gradientRampLengthOf: */
    static long gradientRampLengthOf(final long fill) {
        return objat(fill, GFRampLength);
    }

    /* BalloonEnginePlugin>>#gradientRampLengthOf:put: */
    static void gradientRampLengthOfput(final long fill, final long value) {
        objatput(fill, GFRampLength, value);
    }

    /* BalloonEnginePlugin>>#gradientRampOf: */
    static int gradientRampIndexOf(final long fill) {
        return (objBufferIndex + (int) fill) + GFRampOffset;
    }

    /* BalloonEngineBase>>#hasColorTransform */
    static boolean hasColorTransform() {
        return (workBuffer[GWHasColorTransform]) != 0;
    }

    /* BalloonEngineBase>>#hasColorTransformGet */
    static int hasColorTransformGet() {
        return workBuffer[GWHasColorTransform];
    }

    /* BalloonEngineBase>>#hasColorTransformPut: */
    static long hasColorTransformPut(final long value) {
        return workBuffer[GWHasColorTransform] = (int) value;
    }

    /* BalloonEngineBase>>#hasEdgeTransform */
    static boolean hasEdgeTransform() {
        return (workBuffer[GWHasEdgeTransform]) != 0;
    }

    /* BalloonEngineBase>>#hasEdgeTransformGet */
    static int hasEdgeTransformGet() {
        return workBuffer[GWHasEdgeTransform];
    }

    /* BalloonEngineBase>>#hasEdgeTransformPut: */
    static long hasEdgeTransformPut(final long value) {
        return workBuffer[GWHasEdgeTransform] = (int) value;
    }

    /* Make the fill style with the given index invisible */

    /* BalloonEngineBase>>#hideFill:depth: */
    static boolean hideFilldepth(final long fillIndex, final long depth) {
        long index;
        final long newDepth;
        final long newRightX;
        final long newTop;
        long newTopIndex;

        index = findStackFilldepth(fillIndex, depth);
        if (index == -1) {
            return false;
        }
        if (index == 0) {
            freeStackFillEntry();
            return true;
        }
        stackFillValueput(index, stackFillValue(0));
        stackFillDepthput(index, stackFillDepth(0));
        stackFillRightXput(index, stackFillRightX(0));
        freeStackFillEntry();
        if ((stackFillSize()) <= (stackFillEntryLength())) {
            return true;
        }
        newTopIndex = 0;
        index = stackFillEntryLength();
        while (index < (stackFillSize())) {
            if (fillSortsbefore(index, newTopIndex)) {
                newTopIndex = index;
            }
            index += stackFillEntryLength();
        }
        if ((newTopIndex + (stackFillEntryLength())) == (stackFillSize())) {
            return true;
        }
        newTop = stackFillValue(newTopIndex);
        stackFillValueput(newTopIndex, topFillValue());
        topFillValuePut(newTop);
        newDepth = stackFillDepth(newTopIndex);
        stackFillDepthput(newTopIndex, topFillDepth());
        topFillDepthPut(newDepth);
        newRightX = stackFillRightX(newTopIndex);
        stackFillRightXput(newTopIndex, topFillRightX());
        topFillRightXPut(newRightX);
        return true;
    }

    /* BalloonEngineBase>>#incrementPoint:by: */
    static void incrementPointby(final int[] point, final long delta) {
        point[0] = ((point[0]) + (int) delta);
        point[1] = ((point[1]) + (int) delta);
    }

    /* BalloonEngineBase>>#incrementStat:by: */
    static long incrementStatby(final long statIndex, final long value) {
        return workBuffer[(int) statIndex] = ((workBuffer[(int) statIndex]) + (int) value);
    }

    /* Find insertion point for the given edge in the AET */

    /* BalloonEngineBase>>#indexForInsertingIntoAET: */
    static long indexForInsertingIntoAET(final long edge) {
        int index;
        final long initialX;

        initialX = edgeXValueOf(edge);
        index = 0;
        while ((index < (aetUsedGet())) && ((edgeXValueOf(aetBuffer(index))) < initialX)) {
            index += 1;
        }
        while ((index < (aetUsedGet())) && (((edgeXValueOf(aetBuffer(index))) == initialX) && (getSortsbefore(aetBuffer(index), edge)))) {
            index += 1;
        }
        return index;
    }

    /* BalloonEngineBase>>#initColorTransform */
    static void initColorTransform() {
        colorTransformSet(0, 1.0f);
        colorTransformSet(1, 0.0f);
        colorTransformSet(2, 1.0f);
        colorTransformSet(3, 0.0f);
        colorTransformSet(4, 1.0f);
        colorTransformSet(5, 0.0f);
        colorTransformSet(6, 1.0f);
        colorTransformSet(7, 0.0f);
        hasColorTransformPut(0);
    }

    /* BalloonEngineBase>>#initEdgeTransform */
    static void initEdgeTransform() {
        edgeTransformSet(0, 1.0f);
        edgeTransformSet(1, 0.0f);
        edgeTransformSet(2, 0.0f);
        edgeTransformSet(3, 0.0f);
        edgeTransformSet(4, 1.0f);
        edgeTransformSet(5, 0.0f);
        hasEdgeTransformPut(0);
    }

    /* BalloonEngineBase>>#initialiseModule */
    public static void initialiseModule() {
        // Nothing to do.
    }

    /*
     * Initialization stuff that needs to be done before any processing can take place.
     */
    /* Make sure aaLevel is initialized */

    /* BalloonEngineBase>>#initializeGETProcessing */
    static void initializeGETProcessing() {
        final long value;
        final long value1;
        final long value2;
        final long value3;

        setAALevel(aaLevelGet());
        if ((clipMinXGet()) < 0) {
            clipMinXPut(0);
        }
        if ((clipMaxXGet()) > (spanSizeGet())) {
            clipMaxXPut(spanSizeGet());
        }
        /* begin fillMinXPut: */
        value = ((long) ((clipMinXGet())) << (aaShiftGet()));
        workBuffer[GWFillMinX] = (int) value;
        /* begin fillMinYPut: */
        value1 = (((clipMinYGet())) << (aaShiftGet()));
        workBuffer[GWFillMinY] = (int) value1;
        /* begin fillMaxXPut: */
        value2 = ((long) ((clipMaxXGet())) << (aaShiftGet()));
        workBuffer[GWFillMaxX] = (int) value2;
        /* begin fillMaxYPut: */
        value3 = (((clipMaxYGet())) << (aaShiftGet()));
        workBuffer[GWFillMaxY] = (int) value3;
        getUsedPut(0);
        aetUsedPut(0);
        getBufferIndex = objBufferIndex + objUsed;

        /* Create the global edge table */
        aetBufferIndex = objBufferIndex + objUsed;
        createGlobalEdgeTable();
        if (engineStopped) {
            return;
        }
        if ((getUsedGet()) == 0) {
            /* Nothing to do */
            currentYPut(fillMaxYGet());
        }
        sortGlobalEdgeTable();
        currentYPut(edgeYValueOf(getBuffer(0)));
        if ((currentYGet()) < (fillMinYGet())) {
            currentYPut(fillMinYGet());
        }
        spanStartPut(0);
        spanEndPut((((long) ((spanSizeGet())) << (aaShiftGet()))) - 1);
        clearSpanBuffer();
    }

    /*
     * Insert the edge with the given index from the global edge table into the active edge table.
     * The edge has already been stepped to the initial yValue -- thus remainingLines and rasterX
     * are both set.
     */

    /* BalloonEngineBase>>#insertEdgeIntoAET: */
    static void insertEdgeIntoAET(final long edge) {
        final long index;

        /* Check for the number of lines remaining */
        if ((edgeNumLinesOf(edge)) <= 0) {
            return;
        }

        /* And insert edge */
        index = indexForInsertingIntoAET(edge);
        insertToAETbeforeIndex(edge, index);
    }

    /* Insert the given edge into the AET. */

    /* BalloonEngineBase>>#insertToAET:beforeIndex: */
    static void insertToAETbeforeIndex(final long edge, final long index) {
        int i;

        /* Make sure we have space in the AET */
        if (!(allocateAETEntry(1))) {
            return;
        }
        i = (aetUsedGet()) - 1;
        while (!(i < index)) {
            aetBuffer(i + 1, aetBuffer(i));
            i -= 1;
        }
        aetBuffer(index, edge);
        aetUsedPut((aetUsedGet()) + 1);
    }

    /* BalloonEnginePlugin>>#isBezier: */
    static boolean isBezier(final long bezier) {
        return ((objectTypeOf(bezier)) & GEPrimitiveWideMask) == GEPrimitiveBezier;
    }

    /* BalloonEngineBase>>#isEdge: */
    static boolean isEdge(final long edge) {
        final long type;

        type = objectTypeOf(edge);
        if (type > GEPrimitiveEdgeMask) {
            return false;
        }
        return ((objectTypeOf(edge)) & GEPrimitiveEdgeMask) != 0;
    }

    /* BalloonEngineBase>>#isFillColor: */
    static boolean isFillColor(final long fill) {
        return ((makeUnsignedFrom(fill)) & 0xFF000000L) != 0;
    }

    /* BalloonEnginePlugin>>#isFillOkay: */
    static boolean isFillOkay(final long fill) {
        return (fill == 0) || ((isFillColor(fill)) || (((fill >= 0) && (fill < objUsed)) && ((isFillColor(fill)) || (((objectTypeOf(fill)) & GEPrimitiveFillMask) != 0))));
    }

    /* BalloonEngineBase>>#isFill: */
    static boolean isFill(final long fill) {
        return (isFillColor(fill)) || (((objectTypeOf(fill)) & GEPrimitiveFillMask) != 0);
    }

    /* BalloonEnginePlugin>>#isLine: */
    static boolean isLine(final long line) {
        return ((objectTypeOf(line)) & GEPrimitiveWideMask) == GEPrimitiveLine;
    }

    /* BalloonEngineBase>>#isObject: */
    static boolean isObject(final long obj) {
        return (obj >= 0) && (obj < objUsed);
    }

    /* BalloonEngineBase>>#isRealFill: */
    static boolean isRealFill(final long fill) {
        return ((objectTypeOf(fill)) & GEPrimitiveFillMask) != 0;
    }

    /* BalloonEngineBase>>#isStackEntry: */
    static boolean isStackEntry(final long entry) {
        return (entry >= (wbTopGet())) && (entry < (wbSizeGet()));
    }

    /* BalloonEngineBase>>#isStackIndex: */
    static boolean isStackIndex(final long index) {
        return (index >= 0) && (index < (wbStackSize()));
    }

    /* BalloonEnginePlugin>>#isWideBezier: */
    static boolean isWideBezier(final long bezier) {
        return (isBezier(bezier)) && (isWide(bezier));
    }

    /* BalloonEnginePlugin>>#isWideLine: */
    static boolean isWideLine(final long line) {
        return (isLine(line)) && (isWide(line));
    }

    /* BalloonEngineBase>>#isWide: */
    static boolean isWide(final long object) {
        return ((objectTypeOf(object)) & GEPrimitiveWide) != 0;
    }

    /* BalloonEngineBase>>#lastExportedEdgeGet */
    static int lastExportedEdgeGet() {
        return workBuffer[GWLastExportedEdge];
    }

    /* BalloonEngineBase>>#lastExportedEdgePut: */
    static int lastExportedEdgePut(final long value) {
        return workBuffer[GWLastExportedEdge] = (int) value;
    }

    /* BalloonEngineBase>>#lastExportedFillGet */
    static int lastExportedFillGet() {
        return workBuffer[GWLastExportedFill];
    }

    /* BalloonEngineBase>>#lastExportedFillPut: */
    static long lastExportedFillPut(final long value) {
        return workBuffer[GWLastExportedFill] = (int) value;
    }

    /* BalloonEngineBase>>#lastExportedLeftXGet */
    static int lastExportedLeftXGet() {
        return workBuffer[GWLastExportedLeftX];
    }

    /* BalloonEngineBase>>#lastExportedLeftXPut: */
    static long lastExportedLeftXPut(final long value) {
        return workBuffer[GWLastExportedLeftX] = (int) value;
    }

    /* BalloonEngineBase>>#lastExportedRightXGet */
    static int lastExportedRightXGet() {
        return workBuffer[GWLastExportedRightX];
    }

    /* BalloonEngineBase>>#lastExportedRightXPut: */
    static long lastExportedRightXPut(final long value) {
        return workBuffer[GWLastExportedRightX] = (int) value;
    }

    /* BalloonEnginePlugin>>#lineEndXOf: */
    static long lineEndXOf(final long line) {
        return objat(line, GLEndX);
    }

    /* BalloonEnginePlugin>>#lineEndXOf:put: */
    static void lineEndXOfput(final long line, final long value) {
        objatput(line, GLEndX, value);
    }

    /* BalloonEnginePlugin>>#lineEndYOf: */
    static long lineEndYOf(final long line) {
        return objat(line, GLEndY);
    }

    /* BalloonEnginePlugin>>#lineEndYOf:put: */
    static void lineEndYOfput(final long line, final long value) {
        objatput(line, GLEndY, value);
    }

    /* BalloonEnginePlugin>>#lineErrorAdjDownOf: */
    static long lineErrorAdjDownOf(final long line) {
        return objat(line, GLErrorAdjDown);
    }

    /* BalloonEnginePlugin>>#lineErrorAdjDownOf:put: */
    static void lineErrorAdjDownOfput(final long line, final long value) {
        objatput(line, GLErrorAdjDown, value);
    }

    /* BalloonEnginePlugin>>#lineErrorAdjUpOf: */
    static long lineErrorAdjUpOf(final long line) {
        return objat(line, GLErrorAdjUp);
    }

    /* BalloonEnginePlugin>>#lineErrorAdjUpOf:put: */
    static void lineErrorAdjUpOfput(final long line, final long value) {
        objatput(line, GLErrorAdjUp, value);
    }

    /* BalloonEnginePlugin>>#lineErrorOf: */
    static long lineErrorOf(final long line) {
        return objat(line, GLError);
    }

    /* BalloonEnginePlugin>>#lineErrorOf:put: */
    static void lineErrorOfput(final long line, final long value) {
        objatput(line, GLError, value);
    }

    /* BalloonEnginePlugin>>#lineXDirectionOf: */
    static long lineXDirectionOf(final long line) {
        return objat(line, GLXDirection);
    }

    /* BalloonEnginePlugin>>#lineXDirectionOf:put: */
    static void lineXDirectionOfput(final long line, final long value) {
        objatput(line, GLXDirection, value);
    }

    /* BalloonEnginePlugin>>#lineXIncrementOf: */
    static long lineXIncrementOf(final long line) {
        return objat(line, GLXIncrement);
    }

    /* BalloonEnginePlugin>>#lineXIncrementOf:put: */
    static void lineXIncrementOfput(final long line, final long value) {
        objatput(line, GLXIncrement, value);
    }

    /* BalloonEnginePlugin>>#lineYDirectionOf: */
    static long lineYDirectionOf(final long line) {
        return objat(line, GLYDirection);
    }

    /* BalloonEnginePlugin>>#lineYDirectionOf:put: */
    static void lineYDirectionOfput(final long line, final long value) {
        objatput(line, GLYDirection, value);
    }

    /*
     * Load and subdivide the bezier curve from point1/point2/point3. If wideFlag is set then make
     * sure the curve is monoton in X.
     */

    /* BalloonEnginePlugin>>#loadAndSubdivideBezierFrom:via:to:isWide: */
    static long loadAndSubdivideBezierFromviatoisWide(final boolean wideFlag) {
        final long bz1;
        final long bz2;
        long index;
        long index1;
        long index2;

        bz1 = allocateBezierStackEntry();
        if (engineStopped) {
            return 0;
        }
        bzStartXput(bz1, point1GetX());
        bzStartYput(bz1, point1GetY());
        bzViaXput(bz1, point2GetX());
        bzViaYput(bz1, point2GetY());
        bzEndXput(bz1, point3GetX());
        bzEndYput(bz1, point3GetY());
        index2 = (bz2 = subdivideToBeMonotoninX(bz1, wideFlag));
        for (index = bz1; index <= bz2; index += 6) {
            index1 = subdivideBezierFrom(index);
            if (index1 > index2) {
                index2 = index1;
            }
            if (engineStopped) {
                return 0;
            }
        }
        return div(index2, 6);
    }

    /* BalloonEnginePlugin>>#loadArrayPolygon:nPoints:fill:lineWidth:lineFill: */
    static void loadArrayPolygonnPointsfilllineWidthlineFill(final ArrayObject points, final long nPoints, final long fillIndex, final long lineWidth, final long lineFill) {
        int x0;
        int x1;
        int y0;
        int y1;

        loadPointfrom(GWPoint1, fetchPointerofObject(0, points));
        if (failed()) {
            return;
        }
        x0 = point1GetX();
        y0 = point1GetY();
        for (int i = 1; i < nPoints; i += 1) {
            loadPointfrom(GWPoint1, fetchPointerofObject(i, points));
            if (failed()) {
                return;
            }
            x1 = point1GetX();
            y1 = point1GetY();
            point1SetX(x0);
            point1SetY(y0);
            point2SetX(x1);
            point2SetY(y1);
            transformPoints(2);
            loadWideLinefromtolineFillleftFillrightFill(lineWidth, GWPoint1, GWPoint2, lineFill, fillIndex, 0);
            if (engineStopped) {
                return;
            }
            x0 = x1;
            y0 = y1;
        }
    }

    /* BalloonEnginePlugin>>#loadArrayShape:nSegments:fill:lineWidth:lineFill: */
    static void loadArrayShapenSegmentsfilllineWidthlineFill(final ArrayObject points, final long nSegments, final long fillIndex, final long lineWidth, final long lineFill) {
        PointersObject pointOop;
        long segs;
        int x0;
        int x1;
        int x2;
        int y0;
        int y1;
        int y2;

        for (int i = 0; i < nSegments; i += 1) {
            pointOop = fetchPointerofObject(i * 3, points);
            loadPointfrom(GWPoint1, pointOop);
            pointOop = fetchPointerofObject((i * 3) + 1, points);
            loadPointfrom(GWPoint2, pointOop);
            pointOop = fetchPointerofObject((i * 3) + 2, points);
            loadPointfrom(GWPoint3, pointOop);
            if (failed()) {
                return;
            }
            transformPoints(3);
            x0 = point1GetX();
            y0 = point1GetY();
            x1 = point2GetX();
            y1 = point2GetY();
            x2 = point3GetX();
            /* Check if we can use a line */
            y2 = point3GetY();
            if (((x0 == y0) && (x1 == y1)) || ((x1 == x2) && (y1 == y2))) {
                loadWideLinefromtolineFillleftFillrightFill(lineWidth, GWPoint1, GWPoint3, lineFill, fillIndex, 0);
            } else {
                /* Need bezier */
                segs = loadAndSubdivideBezierFromviatoisWide((lineWidth != 0) && (lineFill != 0));
                if (engineStopped) {
                    return;
                }
                loadWideBezierlineFillleftFillrightFilln(lineWidth, lineFill, fillIndex, 0, segs);
            }
            if (engineStopped) {
                return;
            }
        }
    }

    /* Load a transformation from the given array. */

    /* BalloonEngineBase>>#loadArrayTransformFrom:into:length: */
    static void loadArrayTransformFromintolength(final ArrayObject transformOop, final int destPtr, final long n) {
        Object value;

        for (int i = 0; i < n; i += 1) {
            value = transformOop.at0Object(i);
            if (!((isIntegerObject(value)) || (isFloatObject(value)))) {
                CompilerDirectives.transferToInterpreter();
                throw new PrimitiveFailed();
            }
            if (value instanceof Long) {
                workbufferAtput(destPtr + i, ((((long) value))));
            } else if (value instanceof FloatObject) {
                workbufferAtput(destPtr + i, ((float) (((FloatObject) value).getValue())));
            } else {
                workbufferAtput(destPtr + i, ((float) ((double) (value))));
            }
        }
    }

    /* Initialize the bezier segment stored on the stack */

    /* BalloonEnginePlugin>>#loadBezier:segment:leftFill:rightFill:offset: */
    static long loadBeziersegmentleftFillrightFilloffset(final long bezier, final long index, final long leftFillIndex, final long rightFillIndex, final long yOffset) {
        if ((bzEndY(index)) >= (bzStartY(index))) {
            /* Top to bottom */
            edgeXValueOfput(bezier, bzStartX(index));
            edgeYValueOfput(bezier, (bzStartY(index)) - yOffset);
            bezierViaXOfput(bezier, bzViaX(index));
            bezierViaYOfput(bezier, (bzViaY(index)) - yOffset);
            bezierEndXOfput(bezier, bzEndX(index));
            bezierEndYOfput(bezier, (bzEndY(index)) - yOffset);
        } else {
            edgeXValueOfput(bezier, bzEndX(index));
            edgeYValueOfput(bezier, (bzEndY(index)) - yOffset);
            bezierViaXOfput(bezier, bzViaX(index));
            bezierViaYOfput(bezier, (bzViaY(index)) - yOffset);
            bezierEndXOfput(bezier, bzStartX(index));
            bezierEndYOfput(bezier, (bzStartY(index)) - yOffset);
        }
        edgeZValueOfput(bezier, currentZGet());
        edgeLeftFillOfput(bezier, leftFillIndex);
        edgeRightFillOfput(bezier, rightFillIndex);
        return 0;
    }

    /* BalloonEngineBase>>#loadBitBltFrom: */
    static void loadBitBltFrom(final PointersObject bbObj) {
        BitBlt.loadBitBltFrom(bbObj);
    }

    /* Load the bitmap fill. */

    /* BalloonEnginePlugin>>#loadBitmapFill:colormap:tile:from:along:normal:xIndex: */
    static long loadBitmapFillcolormaptilefromalongnormalxIndex(final PointersObject formOop, final AbstractSqueakObject cmOop, final boolean tileFlag, final long xIndex) {
        final NativeObject bmBits;
        final long bmBitsSize;
        final long bmDepth;
        final long bmFill;
        final long bmHeight;
        final long bmRaster;
        final long bmWidth;
        final int[] cmBits;
        final long cmSize;
        final long ppw;

        if (cmOop.isNil()) {
            cmSize = 0;
            cmBits = null;
        } else {
            if (!cmOop.isBitmap()) {
                CompilerDirectives.transferToInterpreter();
                throw new PrimitiveFailed();
            }
            cmBits = ((NativeObject) cmOop).getIntStorage();
            cmSize = cmBits.length;
        }
        if (!(isPointers(formOop))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed();
        }
        if ((slotSizeOf(formOop)) < 5) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed();
        }
        bmBits = fetchNativeofObject(0, formOop);
        if (!bmBits.isBitmap()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed();
        }
        bmBitsSize = slotSizeOf(bmBits);
        bmWidth = fetchIntegerofObject(1, formOop);
        bmHeight = fetchIntegerofObject(2, formOop);
        bmDepth = fetchIntegerofObject(3, formOop);
        if (failed()) {
            throw new SqueakException("return null");
        }
        if (!((bmWidth >= 0) && (bmHeight >= 0))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed();
        }
        if (!((((((bmDepth == 32) || (bmDepth == 8)) || (bmDepth == 16)) || (bmDepth == 1)) || (bmDepth == 2)) || (bmDepth == 4))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed();
        }
        if (!((cmSize == 0) || (cmSize == (1L << bmDepth)))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed();
        }
        ppw = div(32, bmDepth);
        bmRaster = div(bmWidth + (ppw - 1), ppw);
        if (!(bmBitsSize == (bmRaster * bmHeight))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed();
        }
        bmFill = allocateBitmapFillcolormap(cmSize, cmBits);
        if (engineStopped) {
            throw new SqueakException("return null");
        }
        objatput(bmFill, GBBitmapWidth, bmWidth);
        objatput(bmFill, GBBitmapHeight, bmHeight);
        objatput(bmFill, GBBitmapDepth, bmDepth);
        objatput(bmFill, GBBitmapRaster, bmRaster);
        objatput(bmFill, GBBitmapSize, bmBitsSize);
        objatput(bmFill, GBTileFlag, tileFlag ? 1 : 0);
        objectIndexOfput(bmFill, xIndex);
        loadFillOrientationfromalongnormalwidthheight(bmFill, bmWidth, bmHeight);
        return bmFill;
    }

    /* Note: Assumes that the contents of formArray has been checked before */

    /* BalloonEnginePlugin>>#loadBitsFrom: */
    static int[] loadBitsFrom(final long bmFill) {
        final long bitsLen;
        final NativeObject bitsOop;
        final PointersObject formOop;
        final int xIndex;

        xIndex = objectIndexOf(bmFill);
        if (xIndex > (slotSizeOf(formArray))) {
            return null;
        }
        formOop = fetchPointerofObject(xIndex, formArray);
        bitsOop = fetchNativeofObject(0, formOop);
        final int[] words = bitsOop.getIntStorage();
        bitsLen = words.length;
        if (!(bitsLen == (objat(bmFill, GBBitmapSize)))) {
            return null;
        }
        return words;
    }

    /*
     * Load a 2x3 transformation matrix from the given oop. Return true if the matrix is not nil,
     * false otherwise
     */

    /* BalloonEngineBase>>#loadColorTransformFrom: */
    static boolean loadColorTransformFrom(final AbstractSqueakObject transformOop) {
        final boolean okay;

        hasColorTransformPut(0);
        okay = loadTransformFromintolength(transformOop, GWColorTransform, 8);
        if (!okay) {
            return false;
        }
        hasColorTransformPut(1);
        colorTransformSet(1, (colorTransformGet(1)) * (256.0f));
        colorTransformSet(3, (colorTransformGet(3)) * (256.0f));
        colorTransformSet(5, (colorTransformGet(5)) * (256.0f));
        colorTransformSet(7, (colorTransformGet(7)) * (256.0f));
        return okay;
    }

    /* Load the compressed segment identified by segment index */

    /*
     * BalloonEnginePlugin>>#loadCompressedSegment:from:short:leftFill:rightFill:lineWidth:
     * lineColor:
     */
    static void loadCompressedSegmentfromshortleftFillrightFilllineWidthlineColor(final long segmentIndex, final int[] points, final boolean pointsShort, final long leftFill, final long rightFill,
                    final long lineWidth, final long lineFill) {
        final long index;
        final long segs;
        final long x0;
        final long x1;
        final long x2;
        final long y0;
        final long y1;
        final long y2;

        /* Check if have anything to do at all */
        if ((leftFill == rightFill) && ((lineWidth == 0) || (lineFill == 0))) {
            return;
        }
        /* 3 points with x/y each */
        index = segmentIndex * 6;
        if (pointsShort) {
            /* Load short points */
            x0 = loadPointShortAtfrom(index, points);
            y0 = loadPointShortAtfrom(index + 1, points);
            x1 = loadPointShortAtfrom(index + 2, points);
            y1 = loadPointShortAtfrom(index + 3, points);
            x2 = loadPointShortAtfrom(index + 4, points);
            y2 = loadPointShortAtfrom(index + 5, points);
        } else {
            x0 = loadPointIntAtfrom(index, points);
            y0 = loadPointIntAtfrom(index + 1, points);
            x1 = loadPointIntAtfrom(index + 2, points);
            y1 = loadPointIntAtfrom(index + 3, points);
            x2 = loadPointIntAtfrom(index + 4, points);
            y2 = loadPointIntAtfrom(index + 5, points);
        }
        if (((x0 == x1) && (y0 == y1)) || ((x1 == x2) && (y1 == y2))) {
            /* We can use a line from x0/y0 to x2/y2 */
            if ((x0 == x2) && (y0 == y2)) {
                return;
            }
            point1SetX(x0);
            point1SetY(y0);
            point2SetX(x2);
            point2SetY(y2);
            transformPoints(2);
            loadWideLinefromtolineFillleftFillrightFill(lineWidth, GWPoint1, GWPoint2, lineFill, leftFill, rightFill);
            return;
        }
        point1SetX(x0);
        point1SetY(y0);
        point2SetX(x1);
        point2SetY(y1);
        point3SetX(x2);
        point3SetY(y2);
        transformPoints(3);
        segs = loadAndSubdivideBezierFromviatoisWide((lineWidth != 0) && (lineFill != 0));
        if (engineStopped) {
            return;
        }
        loadWideBezierlineFillleftFillrightFilln(lineWidth, lineFill, leftFill, rightFill, segs);
    }

    /*
     * Load a compressed shape into the engine. WARNING: THIS METHOD NEEDS THE FULL FRAME SIZE!!!!
     */

    /*
     * BalloonEnginePlugin>>#loadCompressedShape:segments:leftFills:rightFills:lineWidths:lineFills:
     * fillIndexList:pointShort:
     */
    static void loadCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexListpointShort(final int[] points, final long nSegments, final int[] leftFills, final int[] rightFills,
                    final int[] lineWidths, final int[] lineFills, final int[] fillIndexList, final boolean pointsShort) {
        long leftLength;
        long leftRun;
        long leftValue;
        long lineFillLength;
        long lineFillRun;
        long lineFillValue;
        long rightLength;
        long rightRun;
        long rightValue;
        long widthLength;
        long widthRun;
        long widthValue;

        if (nSegments == 0) {
            return;
        }
        leftRun = (rightRun = (widthRun = (lineFillRun = -1)));
        leftLength = (rightLength = (widthLength = (lineFillLength = 1)));
        leftValue = (rightValue = (widthValue = (lineFillValue = 0)));
        for (int i = 1; i <= nSegments; i += 1) {
            /* Decrement current run length and load new stuff */
            if (((leftLength -= 1)) <= 0) {
                leftRun += 1;
                leftLength = shortRunLengthAtfrom(leftRun, leftFills);
                leftValue = shortRunValueAtfrom(leftRun, leftFills);
                if (!(leftValue == 0)) {
                    leftValue = fillIndexList[(int) (leftValue - 1)];
                    leftValue = transformColor(leftValue);
                    if (engineStopped) {
                        return;
                    }
                }
            }
            if (((rightLength -= 1)) <= 0) {
                rightRun += 1;
                rightLength = shortRunLengthAtfrom(rightRun, rightFills);
                rightValue = shortRunValueAtfrom(rightRun, rightFills);
                if (!(rightValue == 0)) {
                    rightValue = fillIndexList[(int) (rightValue - 1)];
                    rightValue = transformColor(rightValue);
                }
            }
            if (((widthLength -= 1)) <= 0) {
                widthRun += 1;
                widthLength = shortRunLengthAtfrom(widthRun, lineWidths);
                widthValue = shortRunValueAtfrom(widthRun, lineWidths);
                if (!(widthValue == 0)) {
                    widthValue = transformWidth(widthValue);
                }
            }
            if (((lineFillLength -= 1)) <= 0) {
                lineFillRun += 1;
                lineFillLength = shortRunLengthAtfrom(lineFillRun, lineFills);
                lineFillValue = shortRunValueAtfrom(lineFillRun, lineFills);
                if (!(lineFillValue == 0)) {
                    lineFillValue = fillIndexList[(int) (lineFillValue - 1)];
                }
            }
            loadCompressedSegmentfromshortleftFillrightFilllineWidthlineColor(i - 1, points, pointsShort, leftValue, rightValue, widthValue, lineFillValue);
            if (engineStopped) {
                return;
            }
        }
    }

    /* BalloonEngineBase>>#loadEdgeStateFrom: */
    static long loadEdgeStateFrom(final PointersObject edgeOop) {
        final long edge;

        /* begin lastExportedEdgeGet */
        edge = workBuffer[GWLastExportedEdge];
        if ((slotSizeOf(edgeOop)) < ETBalloonEdgeDataSize) {
            throw new PrimitiveFailed(GEFEdgeDataTooSmall);
        }
        edgeXValueOfput(edge, fetchIntegerofObject(ETXValueIndex, edgeOop));
        edgeYValueOfput(edge, fetchIntegerofObject(ETYValueIndex, edgeOop));
        edgeZValueOfput(edge, fetchIntegerofObject(ETZValueIndex, edgeOop));
        edgeNumLinesOfput(edge, fetchIntegerofObject(ETLinesIndex, edgeOop));
        return edge;
    }

    /*
     * Load a 2x3 transformation matrix from the given oop. Return true if the matrix is not nil,
     * false otherwise
     */

    /* BalloonEngineBase>>#loadEdgeTransformFrom: */
    static boolean loadEdgeTransformFrom(final AbstractSqueakObject transformOop) {
        final boolean okay;

        hasEdgeTransformPut(0);
        okay = loadTransformFromintolength(transformOop, GWEdgeTransform, 6);
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new SqueakException("return null");
        }
        if (!okay) {
            return false;
        }
        hasEdgeTransformPut(1);
        edgeTransformSet(2, ((float) ((edgeTransformGet(2)) + (((double) (destOffsetXGet()))))));
        edgeTransformSet(5, ((float) ((edgeTransformGet(5)) + (((double) (destOffsetYGet()))))));
        return true;
    }

    /* Transform the points */

    /* BalloonEnginePlugin>>#loadFillOrientation:from:along:normal:width:height: */
    static void loadFillOrientationfromalongnormalwidthheight(final long fill, final long fillWidth, final long fillHeight) {
        final int dirX;
        final int dirY;
        final int dsLength2;
        final long dsX;
        final long dsY;
        final int dtLength2;
        final long dtX;
        final long dtY;
        final int nrmX;
        final int nrmY;

        point2SetX((point2GetX()) + (point1GetX()));
        point2SetY((point2GetY()) + (point1GetY()));
        point3SetX((point3GetX()) + (point1GetX()));
        point3SetY((point3GetY()) + (point1GetY()));
        transformPoint(GWPoint1);
        transformPoint(GWPoint2);
        transformPoint(GWPoint3);
        dirX = (point2GetX()) - (point1GetX());
        dirY = (point2GetY()) - (point1GetY());
        nrmX = (point3GetX()) - (point1GetX());
        /* Compute the scale from direction/normal into ramp size */
        nrmY = (point3GetY()) - (point1GetY());
        dsLength2 = (dirX * dirX) + (dirY * dirY);
        if (dsLength2 > 0) {
            dsX = ((long) ((((((double) dirX)) * (((double) fillWidth))) * 65536.0) / ((dsLength2))));
            dsY = ((long) ((((((double) dirY)) * (((double) fillWidth))) * 65536.0) / ((dsLength2))));
        } else {
            dsX = 0;
            dsY = 0;
        }
        dtLength2 = (nrmX * nrmX) + (nrmY * nrmY);
        if (dtLength2 > 0) {
            dtX = ((long) ((((((double) nrmX)) * (((double) fillHeight))) * 65536.0) / ((dtLength2))));
            dtY = ((long) ((((((double) nrmY)) * (((double) fillHeight))) * 65536.0) / ((dtLength2))));
        } else {
            dtX = 0;
            dtY = 0;
        }
        objatput(fill, GFOriginX, point1GetX());
        objatput(fill, GFOriginY, point1GetY());
        objatput(fill, GFDirectionX, dsX);
        objatput(fill, GFDirectionY, dsY);
        objatput(fill, GFNormalX, dtX);
        objatput(fill, GFNormalY, dtY);
    }

    /* Check all the forms from arrayOop. */

    /* BalloonEngineBase>>#loadFormsFrom: */
    static boolean loadFormsFrom(final ArrayObject arrayOop) {
        NativeObject bmBits;
        long bmBitsSize;
        long bmDepth;
        long bmHeight;
        long bmRaster;
        long bmWidth;
        PointersObject formOop;
        long ppw;

        formArray = arrayOop;
        for (int i = 0, iLimiT = ((slotSizeOf(formArray)) - 1); i <= iLimiT; i += 1) {
            formOop = fetchPointerofObject(i, formArray);
            if (!(isPointers(formOop))) {
                return false;
            }
            if ((slotSizeOf(formOop)) < 5) {
                return false;
            }
            bmBits = fetchNativeofObject(0, formOop);
            if (!bmBits.isBitmap()) {
                return false;
            }
            bmBitsSize = slotSizeOf(bmBits);
            bmWidth = fetchIntegerofObject(1, formOop);
            bmHeight = fetchIntegerofObject(2, formOop);
            bmDepth = fetchIntegerofObject(3, formOop);
            if (failed()) {
                return false;
            }
            if (!((bmWidth >= 0) && (bmHeight >= 0))) {
                return false;
            }
            ppw = div(32, bmDepth);
            bmRaster = div(bmWidth + (ppw - 1), ppw);
            if (!(bmBitsSize == (bmRaster * bmHeight))) {
                return false;
            }
        }
        return true;
    }

    /* Load the gradient fill as defined by the color ramp. */

    /* BalloonEnginePlugin>>#loadGradientFill:from:along:normal:isRadial: */
    static long loadGradientFillfromalongnormalisRadial(final NativeObject rampOop, final boolean isRadial) {
        final long fill;
        final long rampWidth;

        assert rampOop.isBitmap();
        rampWidth = slotSizeOf(rampOop);
        fill = allocateGradientFillrampWidthisRadial(rampOop.getIntStorage(), rampWidth, isRadial);
        if (engineStopped) {
            CompilerDirectives.transferToInterpreter();
            throw new SqueakException("return null");
        }
        loadFillOrientationfromalongnormalwidthheight(fill, rampWidth, rampWidth);
        return fill;
    }

    /* Load the line defined by point1 and point2. */

    /* BalloonEnginePlugin>>#loadLine:from:to:offset:leftFill:rightFill: */
    static long

                    loadLinefromtooffsetleftFillrightFill(final long line, final int[] point1, final int[] point2, final long yOffset, final long leftFill, final long rightFill) {
        final int[] p1;
        final int[] p2;
        final long yDir;

        if ((point1[1]) <= (point2[1])) {
            p1 = point1;
            p2 = point2;
            yDir = 1;
        } else {
            p1 = point2;
            p2 = point1;
            yDir = -1;
        }
        edgeXValueOfput(line, p1[0]);
        edgeYValueOfput(line, (p1[1]) - yOffset);
        edgeZValueOfput(line, currentZGet());
        edgeLeftFillOfput(line, leftFill);
        edgeRightFillOfput(line, rightFill);
        objatput(line, GLEndX, p2[0]);
        objatput(line, GLEndY, (p2[1]) - yOffset);
        objatput(line, GLYDirection, yDir);
        return 0;
    }

    /* BalloonEnginePlugin>>#loadOvalSegment:w:h:cx:cy: */
    static void loadOvalSegmentwhcxcy(final int seg, final long w, final long h, final long cx, final long cy) {
        final long x0;
        long x1;
        final long x2;
        final long y0;
        long y1;
        final long y2;

        /* Load start point of segment */
        x0 = ((long) ((((circleCosTable())[(seg * 2)]) * ((w))) + cx));
        y0 = ((long) ((((circleSinTable())[(seg * 2)]) * ((h))) + cy));
        point1SetX(x0);
        point1SetY(y0);
        x2 = ((long) ((((circleCosTable())[(seg * 2) + 2]) * ((w))) + cx));
        y2 = ((long) ((((circleSinTable())[(seg * 2) + 2]) * ((h))) + cy));
        point3SetX(x2);
        point3SetY(y2);
        x1 = ((long) ((((circleCosTable())[(seg * 2) + 1]) * ((w))) + cx));
        /*
         * NOTE: The intermediate point is the point ON the curve and not yet the control point
         * (which is OFF the curve)
         */
        y1 = ((long) ((((circleSinTable())[(seg * 2) + 1]) * ((h))) + cy));
        x1 = (x1 * 2) - ((x0 + x2) / 2);
        y1 = (y1 * 2) - ((y0 + y2) / 2);
        point2SetX(x1);
        point2SetY(y1);
    }

    /* Load a rectangular oval currently defined by point1/point2 */

    /* BalloonEnginePlugin>>#loadOval:lineFill:leftFill:rightFill: */
    static void loadOvallineFillleftFillrightFill(final long lineWidth, final long lineFill, final long leftFill, final long rightFill) {
        final int cx;
        final int cy;
        final int h;
        long nSegments;
        final int w;

        w = (((point2GetX())) - ((point1GetX()))) / 2;
        h = (((point2GetX())) - ((point1GetY()))) / 2;
        cx = (((point2GetX())) + ((point1GetX()))) / 2;
        cy = (((point2GetY())) + ((point1GetY()))) / 2;
        for (int i = 0; i <= 15; i += 1) {
            loadOvalSegmentwhcxcy(i, w, h, cx, cy);
            transformPoints(3);
            nSegments = loadAndSubdivideBezierFromviatoisWide((lineWidth != 0) && (lineFill != 0));
            if (engineStopped) {
                return;
            }
            loadWideBezierlineFillleftFillrightFilln(lineWidth, lineFill, leftFill, rightFill, nSegments);
            if (engineStopped) {
                return;
            }
        }
    }

    /* Load the int value from the given index in intArray */

    /* BalloonEnginePlugin>>#loadPointIntAt:from: */
    static int loadPointIntAtfrom(final long index, final int[] intArray) {
        return intArray[(int) index];
    }

    /* Load the short value from the given index in shortArray */

    /* BalloonEnginePlugin>>#loadPointShortAt:from: */
    static short loadPointShortAtfrom(final long index, final int[] shortArray) {
        final int value = shortArray[(int) (index / 2)];
        if (index % 2 == 0) { // TODO: verify order!
            return (short) value;
        } else {
            return (short) (value >> 16);
        }
    }

    /* Load the contents of pointOop into pointArray */

    /* BalloonEngineBase>>#loadPoint:from: */
    static void loadPointfrom(final int pointIndex, final PointersObject pointOop) {
        Object value;

        if (!pointOop.isPoint()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed();
        }
        value = fetchObjectofObject(0, pointOop);
        if (!((isIntegerObject(value)) || (isFloatObject(value)))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed();
        }
        if (isIntegerObject(value)) {
            pointSetX(pointIndex, integerValueOf(value));
        } else {
            pointSetX(pointIndex, ((long) (floatValueOf(value))));
        }
        value = fetchObjectofObject(1, pointOop);
        if (!((isIntegerObject(value)) || (isFloatObject(value)))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed();
        }
        if (isIntegerObject(value)) {
            pointSetY(pointIndex, integerValueOf(value));
        } else {
            pointSetY(pointIndex, ((long) (floatValueOf(value))));
        }
    }

    /* BalloonEnginePlugin>>#loadPolygon:nPoints:fill:lineWidth:lineFill:pointsShort: */
    static void loadPolygonnPointsfilllineWidthlineFillpointsShort(final int[] points, final long nPoints, final long fillIndex, final long lineWidth, final long lineFill, final boolean isShort) {
        long i;
        long x0;
        long x1;
        long y0;
        long y1;

        if (isShort) {
            x0 = loadPointShortAtfrom(0, points);
            y0 = loadPointShortAtfrom(1, points);
        } else {
            x0 = loadPointIntAtfrom(0, points);
            y0 = loadPointIntAtfrom(1, points);
        }
        for (i = 1; i < nPoints; i += 1) {
            if (isShort) {
                x1 = loadPointShortAtfrom(i * 2, points);
                y1 = loadPointShortAtfrom((i * 2) + 1, points);
            } else {
                x1 = loadPointIntAtfrom(i * 2, points);
                y1 = loadPointIntAtfrom((i * 2) + 1, points);
            }
            point1SetX(x0);
            point1SetY(y0);
            point2SetX(x1);
            point2SetY(y1);
            transformPoints(2);
            loadWideLinefromtolineFillleftFillrightFill(lineWidth, GWPoint1, GWPoint2, lineFill, fillIndex, 0);
            if (engineStopped) {
                return;
            }
            x0 = x1;
            y0 = y1;
        }
    }

    /* Load a rectangle currently defined by point1-point4 */

    /* BalloonEnginePlugin>>#loadRectangle:lineFill:leftFill:rightFill: */
    static void loadRectanglelineFillleftFillrightFill(final long lineWidth, final long lineFill, final long leftFill, final long rightFill) {
        loadWideLinefromtolineFillleftFillrightFill(lineWidth, GWPoint1, GWPoint2, lineFill, leftFill, rightFill);
        loadWideLinefromtolineFillleftFillrightFill(lineWidth, GWPoint2, GWPoint3, lineFill, leftFill, rightFill);
        loadWideLinefromtolineFillleftFillrightFill(lineWidth, GWPoint3, GWPoint4, lineFill, leftFill, rightFill);
        loadWideLinefromtolineFillleftFillrightFill(lineWidth, GWPoint4, GWPoint1, lineFill, leftFill, rightFill);
    }

    /*
     * Load the entire state from the interpreter for the rendering primitives. Answer 0 on success
     * or a non-zero failure code on failure.
     */

    /* BalloonEngineBase>>#loadRenderingState */
    static long loadRenderingState(final PointersObject receiver, final PointersObject edgeOop, final PointersObject fillOop) {
        long failCode;
        final long state;

        if (((failCode = quickLoadEngineFrom(receiver))) != 0) {
            return failCode;
        }
        if (!(((failCode = loadSpanBufferFrom(fetchNativeofObject(BESpanIndex, engine)))) == 0)) {
            return failCode;
        }
        loadBitBltFrom(fetchPointerofObject(BEBitBltIndex, engine));
        if (!(loadFormsFrom(fetchArrayofObject(BEFormsIndex, engine)))) {
            return GEFFormLoadFailed;
        }
        if ((slotSizeOf(edgeOop)) < ETBalloonEdgeDataSize) {
            return GEFEdgeDataTooSmall;
        }
        if ((slotSizeOf(fillOop)) < FTBalloonFillDataSize) {
            return GEFFillDataTooSmall;
        }
        state = stateGet();
        if ((state == GEStateWaitingForEdge) || ((state == GEStateWaitingForFill) || (state == GEStateWaitingChange))) {
            return GEFWrongState;
        }
        return 0;
    }

    /* BalloonEnginePlugin>>#loadShape:nSegments:fill:lineWidth:lineFill:pointsShort: */
    static void loadShapenSegmentsfilllineWidthlineFillpointsShort(final int[] points, final long nSegments, final long fillIndex, final long lineWidth, final long lineFill,
                    final boolean pointsShort) {
        for (int i = 1; i <= nSegments; i += 1) {
            loadCompressedSegmentfromshortleftFillrightFilllineWidthlineColor(i - 1, points, pointsShort, fillIndex, 0, lineWidth, lineFill);
            if (engineStopped) {
                return;
            }
        }
    }

    /*
     * Load the span buffer from the given oop. Answer 0 on success or a non-zero failure code on
     * failure.
     */

    /* BalloonEngineBase>>#loadSpanBufferFrom: */
    static long loadSpanBufferFrom(final NativeObject spanOop) {
        final int value;

        if (!spanOop.isBitmap()) {
            return GEFClassMismatch;
        }

        /* Leave last entry unused to avoid complications */
        spanBuffer = spanOop.getIntStorage();
        /* begin spanSizePut: */
        value = (slotSizeOf(spanOop)) - 1;
        workBuffer[GWSpanSize] = value;
        return 0;
    }

    /*
     * Load a transformation from transformOop into the float array defined by destPtr. The
     * transformation is assumed to be either an array or a FloatArray of length n.
     */

    /* BalloonEngineBase>>#loadTransformFrom:into:length: */
    static boolean loadTransformFromintolength(final AbstractSqueakObject transformOop, final int destPtr, final long n) {
        if (transformOop.isNil()) {
            return false;
        }

        if (transformOop instanceof NativeObject) {
            final NativeObject transformNative = (NativeObject) transformOop;
            if (!((slotSizeOf(transformNative)) == n)) {
                CompilerDirectives.transferToInterpreter();
                throw new PrimitiveFailed();
            }
            loadWordTransformFromintolength(transformNative, destPtr, n);
        } else {
            final ArrayObject transformArray = (ArrayObject) transformOop;
            if (!((slotSizeOf(transformArray)) == n)) {
                CompilerDirectives.transferToInterpreter();
                throw new PrimitiveFailed();
            }
            loadArrayTransformFromintolength(transformArray, destPtr, n);
        }
        return true;
    }

    /*
     * Load the (possibly wide) bezier from the segments currently on the bezier stack.
     */

    /* BalloonEnginePlugin>>#loadWideBezier:lineFill:leftFill:rightFill:n: */
    static void loadWideBezierlineFillleftFillrightFilln(final long lineWidth, final long lineFill, final long leftFill, final long rightFill, final long nSegments) {
        long bezier;
        long index;
        final long offset;
        final boolean wide;

        if ((lineWidth == 0) || (lineFill == 0)) {
            wide = false;
            offset = 0;
        } else {
            wide = true;
            offset = offsetFromWidth(lineWidth);
        }
        index = nSegments * 6;
        while (index > 0) {
            if (wide) {
                bezier = allocateWideBezier();
            } else {
                bezier = allocateBezier();
            }
            if (engineStopped) {
                return;
            }
            loadBeziersegmentleftFillrightFilloffset(bezier, index, leftFill, rightFill, offset);
            if (wide) {
                objatput(bezier, GBWideFill, lineFill);
                wideBezierWidthOfput(bezier, lineWidth);
                objatput(bezier, GBWideExtent, lineWidth);
            }
            index -= 6;
        }
        wbStackClear();
    }

    /* Load a (possibly wide) line defined by the points p1 and p2 */

    /* BalloonEnginePlugin>>#loadWideLine:from:to:lineFill:leftFill:rightFill: */
    static void loadWideLinefromtolineFillleftFillrightFill(final long lineWidth, final int point1Index, final int point2Index, final long lineFill, final long leftFill, final long rightFill) {
        final long line;
        final long offset;
        final int p3Index;
        final int p4Index;
        final long yDir;

        if ((lineWidth == 0) || (lineFill == 0)) {
            line = allocateLine();
            offset = 0;
        } else {
            line = allocateWideLine();
            offset = offsetFromWidth(lineWidth);
        }
        if (engineStopped) {
            return;
        }
        /* begin loadLine:from:to:offset:leftFill:rightFill: */
        if ((pointGetY(point1Index)) <= (pointGetY(point2Index))) {
            p3Index = point1Index;
            p4Index = point2Index;
            yDir = 1;
        } else {
            p3Index = point2Index;
            p4Index = point1Index;
            yDir = -1;
        }
        edgeXValueOfput(line, pointGetX(p3Index));
        edgeYValueOfput(line, pointGetY(p3Index) - offset);
        edgeZValueOfput(line, currentZGet());
        edgeLeftFillOfput(line, leftFill);
        edgeRightFillOfput(line, rightFill);
        objatput(line, GLEndX, pointGetX(p4Index));
        objatput(line, GLEndY, pointGetY(p4Index) - offset);
        objatput(line, GLYDirection, yDir);
        if (isWide(line)) {
            objatput(line, GLWideFill, lineFill);
            wideLineWidthOfput(line, lineWidth);
            objatput(line, GLWideExtent, lineWidth);
        }
    }

    /* Load a float array transformation from the given oop */

    /* BalloonEngineBase>>#loadWordTransformFrom:into:length: */
    static void loadWordTransformFromintolength(final NativeObject transformOop, final int destPtr, final long n) {
        final int[] srcPtr = transformOop.getIntStorage();
        for (int i = 0; i < n; i += 1) {
            workbufferAtput(destPtr + i, srcPtr[i]);
        }
    }

    /* Load the working buffer from the given oop */

    /* BalloonEngineBase>>#loadWorkBufferFrom: */
    static long loadWorkBufferFrom(final NativeObject wbOop) {
        if (!(isWords(wbOop))) {
            return GEFWorkBufferIsPointers;
        }
        if ((slotSizeOf(wbOop)) < GWMinimalSize) {
            return GEFWorkBufferTooSmall;
        }
        workBufferPut(wbOop);
        if (!((workBuffer[GWMagicIndex]) == GWMagicNumber)) {
            return GEFWorkBufferBadMagic;
        }
        if (!((wbSizeGet()) == (slotSizeOf(wbOop)))) {
            return GEFWorkBufferWrongSize;
        }
        if (!((objStartGet()) == GWHeaderSize)) {
            return GEFWorkBufferStartWrong;
        }
        objBufferIndex = objStartGet();
        getBufferIndex = objBufferIndex + (objUsedGet());
        /* Make sure we don't exceed the work buffer */
        aetBufferIndex = getBufferIndex + (getUsedGet());
        if ((((GWHeaderSize + (objUsedGet())) + (getUsedGet())) + (aetUsedGet())) > (wbSizeGet())) {
            return GEFWorkTooBig;
        }
        return 0;
    }

    /* BalloonEngineBase>>#magicNumberGet */
    static int magicNumberGet() {
        return workBuffer[GWMagicIndex];
    }

    /* BalloonEngineBase>>#magicNumberPut: */
    static long magicNumberPut(final long value) {
        return workBuffer[GWMagicIndex] = (int) value;
    }

    /* BalloonEnginePlugin>>#makeRectFromPoints */
    static void makeRectFromPoints() {
        point2SetX(point3GetX());
        point2SetY(point1GetY());
        point4SetX(point1GetX());
        point4SetY(point3GetY());
    }

    /* BalloonEngineBase>>#makeUnsignedFrom: */
    static long makeUnsignedFrom(final long someIntegerValue) {
        return someIntegerValue;
    }

    /* BalloonEngineBase>>#moduleUnloaded: omitted */

    /*
     * The entry at index is not in the right position of the AET. Move it to the left until the
     * position is okay.
     */

    /* BalloonEngineBase>>#moveAETEntryFrom:edge:x: */
    static void moveAETEntryFromedgex(final long index, final long edge, final long xValue) {
        int newIndex = (int) index;
        while ((newIndex > 0) && ((edgeXValueOf(aetBuffer(newIndex - 1))) > xValue)) {
            aetBuffer(newIndex, aetBuffer(newIndex - 1));
            newIndex -= 1;
        }
        aetBuffer(newIndex, edge);
    }

    /* Check if we have n slots available */

    /* BalloonEngineBase>>#needAvailableSpace: */
    static boolean needAvailableSpace(final long nSlots) {
        if (((((GWHeaderSize + objUsed) + (getUsedGet())) + (aetUsedGet())) + nSlots) > (wbTopGet())) {
            stopBecauseOf(GErrorNoMoreSpace);
            return false;
        }
        return true;
    }

    /* BalloonEngineBase>>#needsFlush */
    static boolean needsFlush() {
        return (workBuffer[GWNeedsFlush]) != 0;
    }

    /* BalloonEngineBase>>#needsFlushGet */
    static int needsFlushGet() {
        return workBuffer[GWNeedsFlush];
    }

    /* BalloonEngineBase>>#needsFlushPut: */
    static long needsFlushPut(final long value) {
        return workBuffer[GWNeedsFlush] = (int) value;
    }

    /* BalloonEngineBase>>#objectHeaderOf: */
    static long objectHeaderOf(final long obj) {
        return makeUnsignedFrom(objat(obj, GEObjectType));
    }

    /* BalloonEngineBase>>#objectIndexOf: */
    static int objectIndexOf(final long obj) {
        return objat(obj, GEObjectIndex);
    }

    /* BalloonEngineBase>>#objectIndexOf:put: */
    static void objectIndexOfput(final long obj, final long value) {
        objatput(obj, GEObjectIndex, value);
    }

    /* BalloonEngineBase>>#objectLengthOf: */
    static long objectLengthOf(final long obj) {
        return objat(obj, GEObjectLength);
    }

    /* BalloonEngineBase>>#objectLengthOf:put: */
    static void objectLengthOfput(final long obj, final long value) {
        objatput(obj, GEObjectLength, value);
    }

    /* BalloonEngineBase>>#objectTypeOf: */
    static int objectTypeOf(final long obj) {
        return (int) ((makeUnsignedFrom(objat(obj, GEObjectType))) & GEPrimitiveTypeMask);
    }

    /* BalloonEngineBase>>#objectTypeOf:put: */
    static void objectTypeOfput(final long obj, final long value) {
        objatput(obj, GEObjectType, value);
    }

    /* BalloonEngineBase>>#objStartGet */
    static int objStartGet() {
        return workBuffer[GWObjStart];
    }

    /* BalloonEngineBase>>#objStartPut: */
    static long objStartPut(final long value) {
        return workBuffer[GWObjStart] = (int) value;
    }

    /* BalloonEngineBase>>#objUsedGet */
    static int objUsedGet() {
        return workBuffer[GWObjUsed];
    }

    /* BalloonEngineBase>>#objUsedPut: */
    static long objUsedPut(final long value) {
        return workBuffer[GWObjUsed] = (int) value;
    }

    /* BalloonEngineBase>>#obj:at: */
    static int objat(final long object, final long index) {
        return workBuffer[(int) (objBufferIndex + object + index)];
    }

    /* BalloonEngineBase>>#obj:at:put: */
    static void objatput(final long object, final long index, final long value) {
        workBuffer[(int) (objBufferIndex + object + index)] = (int) value;
    }

    /*
     * Common function so that we don't compute that wrong in any place and can easily find all the
     * places where we deal with one-pixel offsets.
     */

    /* BalloonEnginePlugin>>#offsetFromWidth: */
    static long offsetFromWidth(final long lineWidth) {
        return lineWidth / 2;
    }

    /* Point helper */
    static int pointGetX(final int index) {
        return workBuffer[index];
    }

    static int pointGetY(final int index) {
        return workBuffer[index + 1];
    }

    static int pointSetX(final int index, final long value) {
        return workBuffer[index] = (int) value;
    }

    static int pointSetY(final int index, final long value) {
        return workBuffer[index + 1] = (int) value;
    }

    /* BalloonEngineBase>>#point1Get */
    static int point1GetX() {
        return workBuffer[GWPoint1];
    }

    static int point1GetY() {
        return workBuffer[GWPoint1 + 1];
    }

    static int point1SetX(final long value) {
        return workBuffer[GWPoint1] = (int) value;
    }

    static int point1SetY(final long value) {
        return workBuffer[GWPoint1 + 1] = (int) value;
    }

    /* BalloonEngineBase>>#point2Get */
    static int point2GetX() {
        return workBuffer[GWPoint2];
    }

    static int point2GetY() {
        return workBuffer[GWPoint2 + 1];
    }

    static int point2SetX(final long value) {
        return workBuffer[GWPoint2] = (int) value;
    }

    static int point2SetY(final long value) {
        return workBuffer[GWPoint2 + 1] = (int) value;
    }

    /* BalloonEngineBase>>#point3Get */
    static int point3GetX() {
        return workBuffer[GWPoint3];
    }

    static int point3GetY() {
        return workBuffer[GWPoint3 + 1];
    }

    static int point3SetX(final long value) {
        return workBuffer[GWPoint3] = (int) value;
    }

    static int point3SetY(final long value) {
        return workBuffer[GWPoint3 + 1] = (int) value;
    }

    /* BalloonEngineBase>>#point4Get */
    static int point4GetX() {
        return workBuffer[GWPoint4];
    }

    /* BalloonEngineBase>>#point4Get */
    static int point4GetY() {
        return workBuffer[GWPoint4 + 1];
    }

    static int point4SetX(final long value) {
        return workBuffer[GWPoint4] = (int) value;
    }

    static int point4SetY(final long value) {
        return workBuffer[GWPoint4 + 1] = (int) value;
    }

    /*
     * We have just blitted a scan line to the screen. Do whatever seems to be a good idea here.
     */
    /*
     * Note: In the future we may check the time needed for this scan line and interrupt processing
     * to give the Smalltalk code a chance to run at a certain time.
     */
    /* Check if there is any more work to do. */

    /* BalloonEngineBase>>#postDisplayAction */
    static long postDisplayAction() {
        if (((getStartGet()) >= (getUsedGet())) && ((aetUsedGet()) == 0)) {

            /* No more entries to process */
            statePut(GEStateCompleted);
        }
        if ((currentYGet()) >= (fillMaxYGet())) {

            /* Out of clipping range */
            statePut(GEStateCompleted);
        }
        return 0;
    }

    /* BalloonEngineBase>>#primitiveAbortProcessing -> no senders */

    /* Note: No need to load either bitBlt or spanBuffer */

    /* BalloonEngineBase>>#primitiveAddActiveEdgeEntry */
    public static PointersObject primitiveAddActiveEdgeEntry(final PointersObject receiver, final PointersObject edgeEntry) {
        final long edge;
        final long failureCode;

        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateWaitingForEdge))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        edge = loadEdgeStateFrom(edgeEntry);
        if (!(needAvailableSpace(1))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWorkTooBig);
        }
        if ((edgeNumLinesOf(edge)) > 0) {
            insertEdgeIntoAET(edge);
        }
        if (engineStopped) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineStopped);
        }
        statePut(GEStateAddingFromGET);
        storeEngineStateInto(engine);
        if (doProfileStats) {
            incrementStatby(GWCountAddAETEntry, 1);
            incrementStatby(GWTimeAddAETEntry, (ioMicroMSecs()) - geProfileTime);
        }
        return receiver;
    }

    /* BalloonEnginePlugin>>#primitiveAddBezier */
    public static PointersObject primitiveAddBezier(final PointersObject receiver, final PointersObject start, final PointersObject end, final PointersObject via, final long leftFillValue,
                    final long rightFillValue) {
        final long failureCode;
        final long nSegments;
        long leftFill = leftFillValue;
        long rightFill = rightFillValue;

        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        if (!((isFillOkay(leftFill)) && (isFillOkay(rightFill)))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWrongFill);
        }
        // if ((leftFill == rightFill) && false) {
        // return receiver;
        // }
        loadPointfrom(GWPoint1, start);
        loadPointfrom(GWPoint2, via);
        loadPointfrom(GWPoint3, end);
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(PrimErrBadArgument);
        }
        transformPoints(3);
        nSegments = loadAndSubdivideBezierFromviatoisWide(false);
        needAvailableSpace(nSegments * GBBaseSize);
        if (!engineStopped) {
            leftFill = transformColor(leftFill);
            rightFill = transformColor(rightFill);
        }
        if (!engineStopped) {
            loadWideBezierlineFillleftFillrightFilln(0, 0, leftFill, rightFill, nSegments);
        }
        if (engineStopped) {
            /* Make sure the stack is okay */
            wbStackClear();
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineStopped);
        }
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEntityLoadFailed);
        }
        storeEngineStateInto(engine);
        return receiver;
    }

    /* BalloonEnginePlugin>>#primitiveAddBezierShape */
    public static PointersObject primitiveAddBezierShape(final PointersObject receiver, final AbstractSqueakObject points, final long nSegments, final long fillIndexValue, final long lineWidthValue,
                    final long lineFillValue) {
        final long failureCode;
        final long length;
        final boolean pointsIsArray;
        final long segSize;
        long lineFill = lineFillValue;
        long fillIndex = fillIndexValue;
        long lineWidth = lineWidthValue;

        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        if (isWords(points)) {
            /* Either PointArray or ShortPointArray */
            pointsIsArray = false;
            length = slotSizeOf((NativeObject) points);
            if (!((length == (nSegments * 3)) || (length == (nSegments * 6)))) {
                CompilerDirectives.transferToInterpreter();
                throw new PrimitiveFailed(PrimErrBadArgument);
            }
        } else {
            /* Must be Array of points */
            if (!(isArray(points))) {
                CompilerDirectives.transferToInterpreter();
                throw new PrimitiveFailed(PrimErrBadArgument);
            }
            length = slotSizeOf((ArrayObject) points);
            if (!(length == (nSegments * 3))) {
                CompilerDirectives.transferToInterpreter();
                throw new PrimitiveFailed(PrimErrBadArgument);
            }
            pointsIsArray = true;
        }
        if ((lineWidth == 0) || (lineFill == 0)) {
            segSize = GLBaseSize;
        } else {
            segSize = GLWideSize;
        }
        if (!(needAvailableSpace(segSize * nSegments))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWorkTooBig);
        }
        if (!((isFillOkay(lineFill)) && (isFillOkay(fillIndex)))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWrongFill);
        }
        lineFill = transformColor(lineFill);
        fillIndex = transformColor(fillIndex);
        if (engineStopped) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineStopped);
        }
        if (((lineFill == 0) || (lineWidth == 0)) && (fillIndex == 0)) {
            return receiver;
        }
        if (!(lineWidth == 0)) {
            lineWidth = transformWidth(lineWidth);
            if (lineWidth < 1) {
                lineWidth = 1;
            }
        }
        if (pointsIsArray) {
            loadArrayShapenSegmentsfilllineWidthlineFill((ArrayObject) points, nSegments, fillIndex, lineWidth, lineFill);
        } else {
            loadShapenSegmentsfilllineWidthlineFillpointsShort(((NativeObject) points).getIntStorage(), nSegments, fillIndex, lineWidth, lineFill, (nSegments * 3) == length);
        }
        if (engineStopped) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineStopped);
        }
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEntityLoadFailed);
        }
        needsFlushPut(1);
        storeEngineStateInto(engine);
        return receiver;
    }

    /* BalloonEnginePlugin>>#primitiveAddBitmapFill */
    public static long primitiveAddBitmapFill(final PointersObject receiver, final PointersObject formOop, final AbstractSqueakObject cmOop, final boolean tileFlag, final PointersObject origin,
                    final PointersObject direction, final PointersObject normal, final long xIndex) {
        final long failureCode;
        final long fill;

        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        loadPointfrom(GWPoint1, origin);
        loadPointfrom(GWPoint2, direction);
        loadPointfrom(GWPoint3, normal);
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFBadPoint);
        }
        fill = loadBitmapFillcolormaptilefromalongnormalxIndex(formOop, cmOop, tileFlag, xIndex - 1);
        if (engineStopped) {
            /* Make sure the stack is okay */
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineStopped);
        }
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEntityLoadFailed);
        }
        storeEngineStateInto(engine);
        return fill;
    }

    /* BalloonEnginePlugin>>#primitiveAddCompressedShape */
    public static PointersObject primitiveAddCompressedShape(final PointersObject receiver, final NativeObject points, final long nSegments, final NativeObject leftFills,
                    final NativeObject rightFills, final NativeObject lineWidths, final NativeObject lineFills, final NativeObject fillIndexList) {
        final long failureCode;
        final boolean pointsShort;

        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(PrimErrBadArgument);
        }
        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        if (!(checkCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexList(points, nSegments, leftFills, rightFills, lineWidths, lineFills, fillIndexList))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEntityCheckFailed);
        }
        if (!(needAvailableSpace(GLBaseSize * nSegments))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWorkTooBig);
        }

        /* Then actually load the compressed shape */
        pointsShort = (slotSizeOf(points)) == (nSegments * 3);
        loadCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexListpointShort(points.getIntStorage(), nSegments, leftFills.getIntStorage(), rightFills.getIntStorage(),
                        lineWidths.getIntStorage(), lineFills.getIntStorage(), fillIndexList.getIntStorage(), pointsShort);
        if (engineStopped) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineStopped);
        }
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEntityLoadFailed);
        }
        needsFlushPut(1);
        storeEngineStateInto(engine);
        return receiver;
    }

    /* BalloonEnginePlugin>>#primitiveAddGradientFill */
    public static long primitiveAddGradientFill(final PointersObject receiver, final NativeObject colorRamp, final PointersObject origin, final PointersObject direction, final PointersObject normal,
                    final boolean isRadial) {
        final long failureCode;
        final long fill;

        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        loadPointfrom(GWPoint1, origin);
        loadPointfrom(GWPoint2, direction);
        loadPointfrom(GWPoint3, normal);
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFBadPoint);
        }
        fill = loadGradientFillfromalongnormalisRadial(colorRamp, isRadial);
        if (engineStopped) {

            /* Make sure the stack is okay */
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineStopped);
        }
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEntityLoadFailed);
        }
        storeEngineStateInto(engine);
        return fill;
    }

    /* BalloonEnginePlugin>>#primitiveAddLine */
    public static PointersObject primitiveAddLine(final PointersObject receiver, final PointersObject start, final PointersObject end, final long leftFillValue, final long rightFillValue) {
        final long failureCode;
        long leftFill = leftFillValue;
        long rightFill = rightFillValue;

        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        if (!((isFillOkay(leftFill)) && (isFillOkay(rightFill)))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWrongFill);
        }
        loadPointfrom(GWPoint1, start);
        loadPointfrom(GWPoint2, end);
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFBadPoint);
        }
        transformPoints(2);
        leftFill = transformColor(leftFill);
        rightFill = transformColor(rightFill);
        if (engineStopped) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineStopped);
        }
        loadWideLinefromtolineFillleftFillrightFill(0, GWPoint1, GWPoint2, 0, leftFill, rightFill);
        if (engineStopped) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineStopped);
        }
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEntityLoadFailed);
        }
        storeEngineStateInto(engine);
        return receiver;
    }

    /* BalloonEnginePlugin>>#primitiveAddOval */
    public static PointersObject primitiveAddOval(final PointersObject receiver, final PointersObject start, final PointersObject end, final long fillIndexValue, final long borderWidthValue,
                    final long borderIndexValue) {
        final long failureCode;
        long fillIndex = fillIndexValue;
        long borderIndex = borderIndexValue;
        long borderWidth = borderWidthValue;

        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        if (!((isFillOkay(borderIndex)) && (isFillOkay(fillIndex)))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWrongFill);
        }
        fillIndex = transformColor(fillIndex);
        borderIndex = transformColor(borderIndex);
        if (engineStopped) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineStopped);
        }
        if ((fillIndex == 0) && ((borderIndex == 0) || (borderWidth <= 0))) {
            return receiver;
        }
        if (!(needAvailableSpace(16 * GBBaseSize))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWorkTooBig);
        }
        if ((borderWidth > 0) && (borderIndex != 0)) {
            borderWidth = transformWidth(borderWidth);
        } else {
            borderWidth = 0;
        }
        loadPointfrom(GWPoint1, start);
        loadPointfrom(GWPoint2, end);
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFBadPoint);
        }
        loadOvallineFillleftFillrightFill(borderWidth, borderIndex, 0, fillIndex);
        if (engineStopped) {
            wbStackClear();
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineStopped);
        }
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEntityLoadFailed);
        }
        needsFlushPut(1);
        storeEngineStateInto(engine);
        return receiver;
    }

    /* BalloonEnginePlugin>>#primitiveAddPolygon */
    public static PointersObject primitiveAddPolygon(final PointersObject receiver, final AbstractSqueakObject points, final long nPoints, final long fillIndexValue, final long lineWidthValue,
                    final long lineFillValue) {
        final long failureCode;
        final long length;
        final boolean pointsIsArray;
        final long segSize;
        long lineFill = lineFillValue;
        long fillIndex = fillIndexValue;
        long lineWidth = lineWidthValue;

        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        if (isWords(points)) {
            /* Either PointArray or ShortPointArray */
            pointsIsArray = false;
            length = slotSizeOf((NativeObject) points);
            if (!((length == nPoints) || ((nPoints * 2) == length))) {
                CompilerDirectives.transferToInterpreter();
                throw new PrimitiveFailed(PrimErrBadArgument);
            }
        } else {
            /* Must be Array of points */
            if (!(isArray(points))) {
                CompilerDirectives.transferToInterpreter();
                throw new PrimitiveFailed(PrimErrBadArgument);
            }
            length = slotSizeOf((ArrayObject) points);
            if (!(length == nPoints)) {
                CompilerDirectives.transferToInterpreter();
                throw new PrimitiveFailed(PrimErrBadArgument);
            }
            pointsIsArray = true;
        }
        if ((lineWidth == 0) || (lineFill == 0)) {
            segSize = GLBaseSize;
        } else {
            segSize = GLWideSize;
        }
        if (!(needAvailableSpace(segSize * nPoints))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed();
        }
        if (!((isFillOkay(lineFill)) && (isFillOkay(fillIndex)))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWrongFill);
        }
        lineFill = transformColor(lineFill);
        fillIndex = transformColor(fillIndex);
        if (engineStopped) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineStopped);
        }
        if (((lineFill == 0) || (lineWidth == 0)) && (fillIndex == 0)) {
            return receiver;
        }
        if (!(lineWidth == 0)) {
            lineWidth = transformWidth(lineWidth);
        }
        if (pointsIsArray) {
            loadArrayPolygonnPointsfilllineWidthlineFill((ArrayObject) points, nPoints, fillIndex, lineWidth, lineFill);
        } else {
            loadPolygonnPointsfilllineWidthlineFillpointsShort(((NativeObject) points).getIntStorage(), nPoints, fillIndex, lineWidth, lineFill, nPoints == length);
        }
        if (engineStopped) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineStopped);
        }
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEntityLoadFailed);
        }
        needsFlushPut(1);
        storeEngineStateInto(engine);
        return receiver;
    }

    /* BalloonEnginePlugin>>#primitiveAddRect */
    public static PointersObject primitiveAddRect(final PointersObject receiver, final PointersObject start, final PointersObject end, final long fillIndexValue, final long borderWidthValue,
                    final long borderIndexValue) {
        final long failureCode;
        long fillIndex = fillIndexValue;
        long borderIndex = borderIndexValue;
        long borderWidth = borderWidthValue;

        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        if (!((isFillOkay(borderIndex)) && (isFillOkay(fillIndex)))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWrongFill);
        }
        borderIndex = transformColor(borderIndex);
        fillIndex = transformColor(fillIndex);
        if (engineStopped) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineStopped);
        }
        if ((fillIndex == 0) && ((borderIndex == 0) || (borderWidth == 0))) {
            return receiver;
        }
        if (!(needAvailableSpace(4 * GLBaseSize))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWorkTooBig);
        }
        if ((borderWidth > 0) && (borderIndex != 0)) {
            borderWidth = transformWidth(borderWidth);
        } else {
            borderWidth = 0;
        }
        loadPointfrom(GWPoint1, start);
        loadPointfrom(GWPoint2, end);
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFBadPoint);
        }
        point2SetX(point3GetX());
        point2SetY(point1GetY());
        point4SetX(point1GetX());
        point4SetY(point3GetY());
        transformPoints(4);
        /* begin loadRectangle:lineFill:leftFill:rightFill: */
        loadWideLinefromtolineFillleftFillrightFill(borderWidth, GWPoint1, GWPoint2, borderIndex, 0, fillIndex);
        loadWideLinefromtolineFillleftFillrightFill(borderWidth, GWPoint2, GWPoint3, borderIndex, 0, fillIndex);
        loadWideLinefromtolineFillleftFillrightFill(borderWidth, GWPoint3, GWPoint4, borderIndex, 0, fillIndex);
        loadWideLinefromtolineFillleftFillrightFill(borderWidth, GWPoint4, GWPoint1, borderIndex, 0, fillIndex);
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEntityLoadFailed);
        }
        needsFlushPut(1);
        storeEngineStateInto(engine);
        return receiver;
    }

    /* Note: No need to load either bitBlt or spanBuffer */

    /* BalloonEngineBase>>#primitiveChangedActiveEdgeEntry */
    public static PointersObject primitiveChangedActiveEdgeEntry(final PointersObject receiver, final PointersObject edgeEntry) {
        final long edge;
        final long failureCode;

        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateWaitingChange))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        edge = loadEdgeStateFrom(edgeEntry);
        if ((edgeNumLinesOf(edge)) == 0) {
            removeFirstAETEntry();
        } else {
            resortFirstAETEntry();
            aetStartPut((aetStartGet()) + 1);
        }
        statePut(GEStateUpdateEdges);
        storeEngineStateInto(engine);
        if (doProfileStats) {
            incrementStatby(GWCountChangeAETEntry, 1);
            incrementStatby(GWTimeChangeAETEntry, (ioMicroMSecs()) - geProfileTime);
        }
        return receiver;
    }

    /* BalloonEngineBase>>#primitiveCopyBuffer */
    public static PointersObject primitiveCopyBuffer(final PointersObject receiver, final NativeObject buf1, final NativeObject buf2) {
        final int diff;
        long failCode;

        /* Make sure the old buffer is properly initialized */
        if (!(((failCode = loadWorkBufferFrom(buf1))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failCode);
        }
        if (!((fetchClassOf(buf1)) == (fetchClassOf(buf2)))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFClassMismatch);
        }
        diff = (slotSizeOf(buf2)) - (slotSizeOf(buf1));
        if (diff < 0) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFSizeMismatch);
        }
        final int[] src = workBuffer;
        final int[] dst = buf2.getIntStorage();
        for (int i = 0, iLimiT = ((wbTopGet()) - 1); i <= iLimiT; i += 1) {
            dst[i] = (src[i]);
        }
        dst[GWBufferTop] = ((wbTopGet()) + diff);
        dst[GWSize] = ((wbSizeGet()) + diff);
        final int srcOffset = wbTopGet();
        final int dstOffset = wbTopGet() + diff;
        for (int i = 0, iLimiT = (((wbSizeGet()) - (wbTopGet())) - 1); i <= iLimiT; i += 1) {
            dst[dstOffset + i] = (src[srcOffset + i]);
        }
        if (!(((failCode = loadWorkBufferFrom(buf2))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failCode);
        }
        return receiver;
    }

    /* Note: Must load bitBlt and spanBuffer */

    /* BalloonEngineBase>>#primitiveDisplaySpanBuffer */
    public static PointersObject primitiveDisplaySpanBuffer(final PointersObject receiver) {
        long failureCode;

        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateBlitBuffer))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        if (!(((failureCode = loadSpanBufferFrom(fetchNativeofObject(BESpanIndex, engine)))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        loadBitBltFrom(fetchPointerofObject(BEBitBltIndex, engine));
        if (((currentYGet()) & (aaScanMaskGet())) == (aaScanMaskGet())) {
            displaySpanBufferAt(currentYGet());
            postDisplayAction();
        }
        if (!(finishedProcessing())) {
            aetStartPut(0);
            currentYPut((currentYGet()) + 1);
            statePut(GEStateUpdateEdges);
        }
        storeEngineStateInto(engine);
        if (doProfileStats) {
            incrementStatby(GWCountDisplaySpan, 1);
            incrementStatby(GWTimeDisplaySpan, (ioMicroMSecs()) - geProfileTime);
        }
        return receiver;
    }

    /* Turn on/off profiling. Return the old value of the flag. */

    /* BalloonEngineBase>>#primitiveDoProfileStats */
    public static boolean primitiveDoProfileStats(final PointersObject receiver, final boolean newValue) {
        final boolean oldValue;

        oldValue = doProfileStats;
        doProfileStats = newValue;
        return receiver.image.wrap(oldValue);
    }

    /* BalloonEngineBase>>#primitiveFinishedProcessing */
    public static Object primitiveFinishedProcessing(final PointersObject receiver) {
        final long failureCode;
        final boolean finished;

        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        if (!(((failureCode = quickLoadEngineFrom(receiver))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        finished = finishedProcessing();
        storeEngineStateInto(engine);
        if (doProfileStats) {
            incrementStatby(GWCountFinishTest, 1);
            incrementStatby(GWTimeFinishTest, (ioMicroMSecs()) - geProfileTime);
        }
        return receiver.image.wrap(finished);
    }

    /* BalloonEngineBase>>#primitiveGetAALevel */
    public static long primitiveGetAALevel(final PointersObject receiver) {
        final long failureCode;

        if (!(((failureCode = quickLoadEngineFrom(receiver))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        return aaLevelGet();
    }

    /* BalloonEnginePlugin>>#primitiveGetBezierStats */
    public static Object primitiveGetBezierStats(final PointersObject receiver, final NativeObject statOop) {
        final long failureCode;

        if (!(((failureCode = quickLoadEngineFrom(receiver))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        final int[] stats = statOop.getIntStorage();
        stats[0] = ((stats[0]) + (workBuffer[GWBezierMonotonSubdivisions]));
        stats[1] = ((stats[1]) + (workBuffer[GWBezierHeightSubdivisions]));
        stats[2] = ((stats[2]) + (workBuffer[GWBezierOverflowSubdivisions]));
        stats[3] = ((stats[3]) + (workBuffer[GWBezierLineConversions]));
        return receiver;
    }

    /* BalloonEngineBase>>#primitiveGetClipRect */
    public static PointersObject primitiveGetClipRect(final PointersObject receiver, final PointersObject rectOop) {
        final long failureCode;

        if (!(((failureCode = quickLoadEngineFrom(receiver))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        PointersObject pointOop = receiver.image.newPoint(clipMinXGet(), clipMinYGet());
        storeValue(0, rectOop, pointOop);
        pointOop = receiver.image.newPoint(clipMaxXGet(), clipMaxYGet());
        storeValue(1, rectOop, pointOop);
        return rectOop;
    }

    /* BalloonEngineBase>>#primitiveGetCounts */
    public static Object primitiveGetCounts(final PointersObject receiver, final NativeObject statOop) {
        final long failureCode;

        if (!(((failureCode = quickLoadEngineFrom(receiver))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        final int[] stats = statOop.getIntStorage();
        stats[0] = ((stats[0]) + (workBuffer[GWCountInitializing]));
        stats[1] = ((stats[1]) + (workBuffer[GWCountFinishTest]));
        stats[2] = ((stats[2]) + (workBuffer[GWCountNextGETEntry]));
        stats[3] = ((stats[3]) + (workBuffer[GWCountAddAETEntry]));
        stats[4] = ((stats[4]) + (workBuffer[GWCountNextFillEntry]));
        stats[5] = ((stats[5]) + (workBuffer[GWCountMergeFill]));
        stats[6] = ((stats[6]) + (workBuffer[GWCountDisplaySpan]));
        stats[7] = ((stats[7]) + (workBuffer[GWCountNextAETEntry]));
        stats[8] = ((stats[8]) + (workBuffer[GWCountChangeAETEntry]));
        return receiver;
    }

    /* BalloonEngineBase>>#primitiveGetDepth */
    public static long primitiveGetDepth(final PointersObject receiver) {
        final long failureCode;
        if (!(((failureCode = quickLoadEngineFrom(receiver))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        return currentZGet();
    }

    /* Return the reason why the last operation failed. */

    /* BalloonEngineBase>>#primitiveGetFailureReason */
    public static long primitiveGetFailureReason(final PointersObject receiver) {
        final long failCode;
        /*
         * Note -- don't call loadEngineFrom here because this will override the stopReason with
         * Zero
         */
        engine = receiver;
        if ((slotSizeOf(engine)) < BEBalloonEngineSize) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineTooSmall);
        }
        if (!(((failCode = loadWorkBufferFrom(fetchNativeofObject(BEWorkBufferIndex, engine)))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failCode);
        }
        return stopReasonGet();
    }

    /* BalloonEngineBase>>#primitiveGetOffset */
    public static PointersObject primitiveGetOffset(final PointersObject receiver) {
        final long failureCode;

        if (!(((failureCode = quickLoadEngineFrom(receiver))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        return receiver.image.newPoint(destOffsetXGet(), destOffsetYGet());
    }

    /* BalloonEngineBase>>#primitiveGetTimes */
    public static Object primitiveGetTimes(final PointersObject receiver, final NativeObject statsArray) {
        final long failureCode;

        if (!(((failureCode = quickLoadEngineFrom(receiver))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        final int[] stats = statsArray.getIntStorage();
        stats[0] = ((stats[0]) + (workBuffer[GWTimeInitializing]));
        stats[1] = ((stats[1]) + (workBuffer[GWTimeFinishTest]));
        stats[2] = ((stats[2]) + (workBuffer[GWTimeNextGETEntry]));
        stats[3] = ((stats[3]) + (workBuffer[GWTimeAddAETEntry]));
        stats[4] = ((stats[4]) + (workBuffer[GWTimeNextFillEntry]));
        stats[5] = ((stats[5]) + (workBuffer[GWTimeMergeFill]));
        stats[6] = ((stats[6]) + (workBuffer[GWTimeDisplaySpan]));
        stats[7] = ((stats[7]) + (workBuffer[GWTimeNextAETEntry]));
        stats[8] = ((stats[8]) + (workBuffer[GWTimeChangeAETEntry]));
        return receiver;
    }

    /* BalloonEngineBase>>#primitiveInitializeBuffer */
    public static NativeObject primitiveInitializeBuffer(@SuppressWarnings("unused") final PointersObject receiver, final NativeObject wbOop) {
        final int size = wbOop.getIntLength();

        workBufferPut(wbOop);
        objBufferIndex = GWHeaderSize;
        /* begin magicNumberPut: */
        workBuffer[GWMagicIndex] = GWMagicNumber;
        workBuffer[GWSize] = size;
        wbTopPut(size);
        statePut(GEStateUnlocked);
        /* begin objStartPut: */
        workBuffer[GWObjStart] = GWHeaderSize;
        objUsedPut(4);
        objectTypeOfput(0, GEPrimitiveFill);
        objectLengthOfput(0, 4);
        objectIndexOfput(0, 0);
        getStartPut(0);
        getUsedPut(0);
        aetStartPut(0);
        aetUsedPut(0);
        stopReasonPut(0);
        needsFlushPut(0);
        clipMinXPut(0);
        clipMaxXPut(0);
        clipMinYPut(0);
        clipMaxYPut(0);
        currentZPut(0);
        resetGraphicsEngineStats();
        initEdgeTransform();
        initColorTransform();
        return wbOop;
    }

    /* Note: No need to load bitBlt but must load spanBuffer */

    /* BalloonEngineBase>>#primitiveInitializeProcessing */
    public static PointersObject primitiveInitializeProcessing(final PointersObject receiver) {
        long failureCode;

        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        if (!(((failureCode = loadSpanBufferFrom(fetchNativeofObject(BESpanIndex, engine)))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        initializeGETProcessing();
        if (engineStopped) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineStopped);
        }
        statePut(GEStateAddingFromGET);
        if (!(failed())) {
            storeEngineStateInto(engine);
        }
        if (doProfileStats) {
            incrementStatby(GWCountInitializing, 1);
            incrementStatby(GWTimeInitializing, (ioMicroMSecs()) - geProfileTime);
        }
        return receiver;
    }

    /* Note: No need to load bitBlt but must load spanBuffer */

    /* BalloonEngineBase>>#primitiveMergeFillFrom */
    public static Object primitiveMergeFillFrom(final PointersObject receiver, final NativeObject bitsOop, final PointersObject fillOop) {
        long failureCode;
        long value;

        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateWaitingForFill))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        if (!(((failureCode = loadSpanBufferFrom(fetchNativeofObject(BESpanIndex, engine)))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        /* Check bitmap */
        if ((slotSizeOf(fillOop)) < FTBalloonFillDataSize) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFFillDataTooSmall);
        }
        value = fetchIntegerofObject(FTIndexIndex, fillOop);
        if (!((objectIndexOf(lastExportedFillGet())) == value)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWrongFill);
        }
        value = fetchIntegerofObject(FTMinXIndex, fillOop);
        if (!((lastExportedLeftXGet()) == value)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWrongFill);
        }
        value = fetchIntegerofObject(FTMaxXIndex, fillOop);
        if (!((lastExportedRightXGet()) == value)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWrongFill);
        }
        if ((slotSizeOf(bitsOop)) < ((lastExportedRightXGet()) - (lastExportedLeftXGet()))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(PrimErrBadArgument);
        }
        if (failed()) {
            return null;
        }
        fillBitmapSpanfromto(bitsOop.getIntStorage(), lastExportedLeftXGet(), lastExportedRightXGet());
        statePut(GEStateScanningAET);
        storeEngineStateInto(engine);
        if (doProfileStats) {
            incrementStatby(GWCountMergeFill, 1);
            incrementStatby(GWTimeMergeFill, (ioMicroMSecs()) - geProfileTime);
        }
        return receiver;
    }

    /* BalloonEngineBase>>#primitiveNeedsFlush */
    public static boolean primitiveNeedsFlush(final PointersObject receiver) {
        final long failureCode;
        final boolean needFlush;

        if (!(((failureCode = quickLoadEngineFrom(receiver))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        needFlush = needsFlush();
        storeEngineStateInto(engine);
        return receiver.image.wrap(needFlush);
    }

    /* BalloonEngineBase>>#primitiveNeedsFlushPut */
    public static Object primitiveNeedsFlushPut(final PointersObject receiver, final boolean needFlush) {
        final long failureCode;

        if (!(((failureCode = quickLoadEngineFrom(receiver))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        if (needFlush) {
            needsFlushPut(1);
        } else {
            needsFlushPut(0);
        }
        storeEngineStateInto(engine);
        return receiver;
    }

    /* Note: No need to load either bitBlt or spanBuffer */

    /* BalloonEngineBase>>#primitiveNextActiveEdgeEntry */
    public static boolean primitiveNextActiveEdgeEntry(final PointersObject receiver, final PointersObject edgeEntry) {
        final int edge;
        final long failureCode;
        boolean hasEdge;

        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        if (!(((failureCode = quickLoadEngineFromrequiredStateor(receiver, GEStateUpdateEdges, GEStateCompleted))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        hasEdge = false;
        if (!((stateGet()) == GEStateCompleted)) {
            hasEdge = findNextExternalUpdateFromAET();
            if (hasEdge) {
                edge = aetBuffer(aetStartGet());
                storeEdgeStateFrominto(edge, edgeEntry);
                statePut(GEStateWaitingChange);
            } else {
                statePut(GEStateAddingFromGET);
            }
        }
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new SqueakException("return null");
        }
        storeEngineStateInto(engine);
        if (doProfileStats) {
            incrementStatby(GWCountNextAETEntry, 1);
            incrementStatby(GWTimeNextAETEntry, (ioMicroMSecs()) - geProfileTime);
        }
        return receiver.image.wrap(!hasEdge);
    }

    /* Note: No need to load bitBlt but must load spanBuffer */

    /* BalloonEngineBase>>#primitiveNextFillEntry */
    public static boolean primitiveNextFillEntry(final PointersObject receiver, final PointersObject fillOop) {
        long failureCode;
        final boolean hasFill;

        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateScanningAET))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        if (!(((failureCode = loadSpanBufferFrom(fetchNativeofObject(BESpanIndex, engine)))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        if (!(loadFormsFrom(fetchArrayofObject(BEFormsIndex, engine)))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFFormLoadFailed);
        }
        if (!((clearSpanBufferGet()) == 0)) {
            if (((currentYGet()) & (aaScanMaskGet())) == 0) {
                clearSpanBuffer();
            }
            clearSpanBufferPut(0);
        }
        hasFill = findNextExternalFillFromAET();
        if (engineStopped) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineStopped);
        }
        if (hasFill) {
            storeFillStateInto(fillOop);
        }
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWrongFill);
        }
        if (hasFill) {
            statePut(GEStateWaitingForFill);
        } else {
            wbStackClear();
            spanEndAAPut(0);
            statePut(GEStateBlitBuffer);
        }
        storeEngineStateInto(engine);
        if (doProfileStats) {
            incrementStatby(GWCountNextFillEntry, 1);
            incrementStatby(GWTimeNextFillEntry, (ioMicroMSecs()) - geProfileTime);
        }
        return receiver.image.wrap(!hasFill);
    }

    /* Note: No need to load either bitBlt or spanBuffer */

    /* BalloonEngineBase>>#primitiveNextGlobalEdgeEntry */
    public static boolean primitiveNextGlobalEdgeEntry(final PointersObject receiver, final PointersObject edgeEntry) {
        final int edge;
        final long failureCode;
        final boolean hasEdge;

        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateAddingFromGET))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        hasEdge = findNextExternalEntryFromGET();
        if (hasEdge) {
            edge = getBuffer(getStartGet());
            storeEdgeStateFrominto(edge, edgeEntry);
            getStartPut((getStartGet()) + 1);
        }
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWrongEdge);
        }
        if (hasEdge) {
            statePut(GEStateWaitingForEdge);
        } else {
            /* Start scanning the AET */
            statePut(GEStateScanningAET);
            clearSpanBufferPut(1);
            aetStartPut(0);
            wbStackClear();
        }
        storeEngineStateInto(engine);
        if (doProfileStats) {
            incrementStatby(GWCountNextGETEntry, 1);
            incrementStatby(GWTimeNextGETEntry, (ioMicroMSecs()) - geProfileTime);
        }
        return receiver.image.wrap(!hasEdge);
    }

    /* BalloonEngineBase>>#primitiveRegisterExternalEdge */
    public static PointersObject primitiveRegisterExternalEdge(final PointersObject receiver, final long index, final long initialX, final long initialY, final long initialZ, final long leftFillIndex,
                    final long rightFillIndex) {
        final int edge;
        final long failureCode;

        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        if (!(allocateObjEntry(GEBaseEdgeSize))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWorkTooBig);
        }
        if (!((isFillOkay(leftFillIndex)) && (isFillOkay(rightFillIndex)))) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFWrongFill);
        }
        edge = objUsed;

        /* Install type and length */
        objUsed = edge + GEBaseEdgeSize;
        objectTypeOfput(edge, GEPrimitiveEdge);
        objectLengthOfput(edge, GEBaseEdgeSize);
        objectIndexOfput(edge, index);
        edgeXValueOfput(edge, initialX);
        edgeYValueOfput(edge, initialY);
        edgeZValueOfput(edge, initialZ);
        edgeLeftFillOfput(edge, transformColor(leftFillIndex));
        edgeRightFillOfput(edge, transformColor(rightFillIndex));
        if (engineStopped) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(GEFEngineStopped);
        }
        if (!(failed())) {
            storeEngineStateInto(engine);
        }
        return receiver;
    }

    /* BalloonEngineBase>>#primitiveRegisterExternalFill */
    public static long primitiveRegisterExternalFill(final PointersObject receiver, final long index) {
        final long failureCode;
        int fill;

        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        fill = 0;
        while (fill == 0) {
            if (!(allocateObjEntry(GEBaseEdgeSize))) {
                CompilerDirectives.transferToInterpreter();
                throw new PrimitiveFailed(GEFWorkTooBig);
            }
            fill = objUsed;
            /* Install type and length */
            objUsed = fill + GEBaseFillSize;
            objectTypeOfput(fill, GEPrimitiveFill);
            objectLengthOfput(fill, GEBaseFillSize);
            objectIndexOfput(fill, index);
        }
        storeEngineStateInto(engine);
        return fill;
    }

    /* Start/Proceed rendering the entire image */

    /* BalloonEngineBase>>#primitiveRenderImage */
    public static long primitiveRenderImage(final PointersObject receiver, final PointersObject edge, final PointersObject fill) {
        final long failCode;

        if (!(((failCode = loadRenderingState(receiver, edge, fill))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failCode);
        }
        proceedRenderingScanline();
        if (engineStopped) {
            return storeRenderingState(edge, fill);
        }
        proceedRenderingImage();
        return storeRenderingState(edge, fill);
    }

    /* Start rendering the entire image */

    /* BalloonEngineBase>>#primitiveRenderScanline */
    public static long primitiveRenderScanline(final PointersObject receiver, final PointersObject edge, final PointersObject fill) {
        final long failCode;

        if (!(((failCode = loadRenderingState(receiver, edge, fill))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failCode);
        }
        proceedRenderingScanline();
        return storeRenderingState(edge, fill);
    }

    /* BalloonEngineBase>>#primitiveSetAALevel */
    public static PointersObject primitiveSetAALevel(final PointersObject receiver, final long level) {
        final long failureCode;

        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        setAALevel(level);
        storeEngineStateInto(engine);
        return receiver;
    }

    /* Primitive. Set the BitBlt plugin to use. */

    /* BalloonEngineBase>>#primitiveSetBitBltPlugin */
    public static ClassObject primitiveSetBitBltPlugin(final ClassObject receiver, final NativeObject pluginName) {
        final long length;

        /* Must be string to work */
        assert pluginName.isByteType();
        final byte[] ptr = pluginName.getByteStorage();
        length = ptr.length;
        if (length >= 256) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed();
        }
        // Implemented as NOOP.
        return receiver;
    }

    /* BalloonEngineBase>>#primitiveSetClipRect */
    public static PointersObject primitiveSetClipRect(final PointersObject receiver, final PointersObject rectOop) {
        final long failureCode;

        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        loadPointfrom(GWPoint1, fetchPointerofObject(0, rectOop));
        loadPointfrom(GWPoint2, fetchPointerofObject(1, rectOop));
        if (failed()) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(PrimErrBadArgument);
        }
        clipMinXPut((point1GetX()));
        clipMinYPut((point1GetY()));
        clipMaxXPut((point2GetX()));
        clipMaxYPut((point2GetY()));
        storeEngineStateInto(engine);
        return receiver;
    }

    /* BalloonEngineBase>>#primitiveSetColorTransform */
    public static PointersObject primitiveSetColorTransform(final PointersObject receiver, final AbstractSqueakObject transformOop) {
        final long failureCode;

        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        loadColorTransformFrom(transformOop);
        storeEngineStateInto(engine);
        return receiver;
    }

    /* BalloonEngineBase>>#primitiveSetDepth */
    public static PointersObject primitiveSetDepth(final PointersObject receiver, final long depth) {
        final long failureCode;

        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        currentZPut(depth);
        storeEngineStateInto(engine);
        return receiver;
    }

    /* BalloonEngineBase>>#primitiveSetEdgeTransform */
    public static PointersObject primitiveSetEdgeTransform(final PointersObject receiver, final AbstractSqueakObject transformOop) {
        final long failureCode;

        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        loadEdgeTransformFrom(transformOop);
        storeEngineStateInto(engine);
        return receiver;
    }

    /* BalloonEngineBase>>#primitiveSetOffset */
    public static PointersObject primitiveSetOffset(final PointersObject receiver, final PointersObject pointOop) {
        final long failureCode;

        if (!(((failureCode = quickLoadEngineFromrequiredState(receiver, GEStateUnlocked))) == 0)) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed(failureCode);
        }
        loadPointfrom(GWPoint1, pointOop);
        workBuffer[GWDestOffsetX] = (point1GetX());
        workBuffer[GWDestOffsetY] = (point1GetY());
        storeEngineStateInto(engine);
        return receiver;
    }

    /* This is the main rendering entry */

    /* BalloonEngineBase>>#proceedRenderingImage */
    static void proceedRenderingImage() {
        boolean external;

        while (!(finishedProcessing())) {
            if (doProfileStats) {
                geProfileTime = ioMicroMSecs();
            }
            external = findNextExternalEntryFromGET();
            if (doProfileStats) {
                incrementStatby(GWCountNextGETEntry, 1);
                incrementStatby(GWTimeNextGETEntry, (ioMicroMSecs()) - geProfileTime);
            }
            if (engineStopped) {
                statePut(GEStateAddingFromGET);
                return;
            }
            if (external) {
                statePut(GEStateWaitingForEdge);
                stopBecauseOf(GErrorGETEntry);
                return;
            }
            aetStartPut(0);
            wbStackClear();
            clearSpanBufferPut(1);
            if (doProfileStats) {
                geProfileTime = ioMicroMSecs();
            }
            if (((clearSpanBufferGet()) != 0) && (((currentYGet()) & (aaScanMaskGet())) == 0)) {
                clearSpanBuffer();
            }
            clearSpanBufferPut(0);
            external = findNextExternalFillFromAET();
            if (doProfileStats) {
                incrementStatby(GWCountNextFillEntry, 1);
                incrementStatby(GWTimeNextFillEntry, (ioMicroMSecs()) - geProfileTime);
            }
            if (engineStopped) {
                statePut(GEStateScanningAET);
                return;
            }
            if (external) {
                statePut(GEStateWaitingForFill);
                stopBecauseOf(GErrorFillEntry);
                return;
            }
            wbStackClear();
            spanEndAAPut(0);
            if (doProfileStats) {
                geProfileTime = ioMicroMSecs();
            }
            if (((currentYGet()) & (aaScanMaskGet())) == (aaScanMaskGet())) {
                displaySpanBufferAt(currentYGet());
                postDisplayAction();
            }
            if (doProfileStats) {
                incrementStatby(GWCountDisplaySpan, 1);
                incrementStatby(GWTimeDisplaySpan, (ioMicroMSecs()) - geProfileTime);
            }
            if (engineStopped) {
                statePut(GEStateBlitBuffer);
                return;
            }
            if (finishedProcessing()) {
                return;
            }
            aetStartPut(0);
            currentYPut((currentYGet()) + 1);
            if (doProfileStats) {
                geProfileTime = ioMicroMSecs();
            }
            external = findNextExternalUpdateFromAET();
            if (doProfileStats) {
                incrementStatby(GWCountNextAETEntry, 1);
                incrementStatby(GWTimeNextAETEntry, (ioMicroMSecs()) - geProfileTime);
            }
            if (engineStopped) {
                statePut(GEStateUpdateEdges);
                return;
            }
            if (external) {
                statePut(GEStateWaitingChange);
                stopBecauseOf(GErrorAETEntry);
                return;
            }
        }
    }

    /*
     * Proceed rendering the current scan line. This method may be called after some Smalltalk code
     * has been executed inbetween.
     */
    /* This is the main rendering entry */

    /* BalloonEngineBase>>#proceedRenderingScanline */
    static void proceedRenderingScanline() {
        boolean external;
        long state;

        state = stateGet();
        if (state == GEStateUnlocked) {
            initializeGETProcessing();
            if (engineStopped) {
                return;
            }
            state = GEStateAddingFromGET;
        }
        if (state == GEStateAddingFromGET) {
            if (doProfileStats) {
                geProfileTime = ioMicroMSecs();
            }
            external = findNextExternalEntryFromGET();
            if (doProfileStats) {
                incrementStatby(GWCountNextGETEntry, 1);
                incrementStatby(GWTimeNextGETEntry, (ioMicroMSecs()) - geProfileTime);
            }
            if (engineStopped) {
                statePut(GEStateAddingFromGET);
                return;
            }
            if (external) {
                statePut(GEStateWaitingForEdge);
                stopBecauseOf(GErrorGETEntry);
                return;
            }
            aetStartPut(0);
            wbStackClear();
            clearSpanBufferPut(1);
            state = GEStateScanningAET;
        }
        if (state == GEStateScanningAET) {
            if (doProfileStats) {
                geProfileTime = ioMicroMSecs();
            }
            if (((clearSpanBufferGet()) != 0) && (((currentYGet()) & (aaScanMaskGet())) == 0)) {
                clearSpanBuffer();
            }
            clearSpanBufferPut(0);
            external = findNextExternalFillFromAET();
            if (doProfileStats) {
                incrementStatby(GWCountNextFillEntry, 1);
                incrementStatby(GWTimeNextFillEntry, (ioMicroMSecs()) - geProfileTime);
            }
            if (engineStopped) {
                statePut(GEStateScanningAET);
                return;
            }
            if (external) {
                statePut(GEStateWaitingForFill);
                stopBecauseOf(GErrorFillEntry);
                return;
            }
            state = GEStateBlitBuffer;
            wbStackClear();
            spanEndAAPut(0);
        }
        if (state == GEStateBlitBuffer) {
            if (doProfileStats) {
                geProfileTime = ioMicroMSecs();
            }
            if (((currentYGet()) & (aaScanMaskGet())) == (aaScanMaskGet())) {
                displaySpanBufferAt(currentYGet());
                postDisplayAction();
            }
            if (doProfileStats) {
                incrementStatby(GWCountDisplaySpan, 1);
                incrementStatby(GWTimeDisplaySpan, (ioMicroMSecs()) - geProfileTime);
            }
            if (engineStopped) {
                statePut(GEStateBlitBuffer);
                return;
            }
            if (finishedProcessing()) {
                return;
            }
            state = GEStateUpdateEdges;
            aetStartPut(0);
            currentYPut((currentYGet()) + 1);
        }
        if (state == GEStateUpdateEdges) {
            if (doProfileStats) {
                geProfileTime = ioMicroMSecs();
            }
            external = findNextExternalUpdateFromAET();
            if (doProfileStats) {
                incrementStatby(GWCountNextAETEntry, 1);
                incrementStatby(GWTimeNextAETEntry, (ioMicroMSecs()) - geProfileTime);
            }
            if (engineStopped) {
                statePut(GEStateUpdateEdges);
                return;
            }
            if (external) {
                statePut(GEStateWaitingChange);
                stopBecauseOf(GErrorAETEntry);
                return;
            }
            statePut(GEStateAddingFromGET);
        }
    }

    /*
     * Load the minimal required state from the engineOop, e.g., just the work buffer. Answer 0 on
     * success or non-zero a failure code on failure
     */

    /* BalloonEngineBase>>#quickLoadEngineFrom: */
    static long quickLoadEngineFrom(final PointersObject engineOop) {
        final long failCode;

        if (failed()) {
            return GEFAlreadyFailed;
        }
        if ((slotSizeOf(engineOop)) < BEBalloonEngineSize) {
            return GEFEngineTooSmall;
        }
        engine = engineOop;
        if (!(((failCode = loadWorkBufferFrom(fetchNativeofObject(BEWorkBufferIndex, engineOop)))) == 0)) {
            return failCode;
        }
        stopReasonPut(0);
        objUsed = objUsedGet();
        engineStopped = false;
        return 0;
    }

    /* BalloonEngineBase>>#quickLoadEngineFrom:requiredState: */
    static long quickLoadEngineFromrequiredState(final PointersObject oop, final long requiredState) {
        final long failureCode;

        if (!(((failureCode = quickLoadEngineFrom(oop))) == 0)) {
            return failureCode;
        }
        if ((stateGet()) == requiredState) {
            return 0;
        }
        stopReasonPut(GErrorBadState);
        return GEFWrongState;
    }

    /* BalloonEngineBase>>#quickLoadEngineFrom:requiredState:or: */
    static long quickLoadEngineFromrequiredStateor(final PointersObject oop, final long requiredState, final long alternativeState) {
        final long failureCode;

        if (!(((failureCode = quickLoadEngineFrom(oop))) == 0)) {
            return failureCode;
        }
        if ((stateGet()) == requiredState) {
            return 0;
        }
        if ((stateGet()) == alternativeState) {
            return 0;
        }
        stopReasonPut(GErrorBadState);
        return GEFWrongState;
    }

    /* Remove any top fills if they have become invalid. */

    /* BalloonEngineBase>>#quickRemoveInvalidFillsAt: */
    static void quickRemoveInvalidFillsAt(final long leftX) {
        if ((stackFillSize()) == 0) {
            return;
        }
        while ((topRightX()) <= leftX) {
            hideFilldepth(topFill(), topDepth());
            if ((stackFillSize()) == 0) {
                return;
            }
        }
    }

    /*
     * Sort elements i through j of self to be nondescending according to sortBlock.
     */
    /* Note: The original loop has been heavily re-written for C translation */

    /* BalloonEngineBase>>#quickSortGlobalEdgeTable:from:to: */
    static void quickSortGlobalEdgeTablefromto(final int[] array, final int i, final int j) {
        boolean again;
        boolean before;
        int di;
        int dij;
        int dj;
        final int ij;
        int k;
        int l;
        final long n;
        int tmp;
        final int tt;

        /* The prefix d means the data at that index. */
        if (((n = (j + 1) - i)) <= 1) {
            return;
        }
        di = array[i];
        dj = array[j];
        /* i.e., should di precede dj? */
        before = getSortsbefore(di, dj);
        if (!before) {
            tmp = array[i];
            array[i] = (array[j]);
            array[j] = tmp;
            tt = di;
            di = dj;
            dj = tt;
        }
        if (n <= 2) {
            return;
        }
        /* ij is the midpoint of i and j. */
        ij = (i + j) / 2;
        /* Sort di,dij,dj. Make dij be their median. */
        dij = array[ij];
        /* i.e. should di precede dij? */
        before = getSortsbefore(di, dij);
        if (before) {
            /* i.e., should dij precede dj? */
            before = getSortsbefore(dij, dj);
            if (!before) {
                /* i.e., should dij precede dj? */
                tmp = array[j];
                array[j] = (array[ij]);
                array[ij] = tmp;
                dij = dj;
            }
        } else {
            /* i.e. di should come after dij */
            tmp = array[i];
            array[i] = (array[ij]);
            array[ij] = tmp;
            dij = di;
        }
        if (n <= 3) {
            return;
        }
        k = i;
        l = j;
        again = true;
        while (again) {
            before = true;
            while (before) {
                if (k <= ((l -= 1))) {
                    tmp = array[l];
                    before = getSortsbefore(dij, tmp);
                } else {
                    before = false;
                }
            }
            before = true;
            while (before) {
                if (((k += 1)) <= l) {
                    tmp = array[k];
                    before = getSortsbefore(tmp, dij);
                } else {
                    before = false;
                }
            }
            again = k <= l;
            if (again) {
                tmp = array[k];
                array[k] = (array[l]);
                array[l] = tmp;
            }
        }
        quickSortGlobalEdgeTablefromto(array, i, l);
        quickSortGlobalEdgeTablefromto(array, k, j);
    }

    /* BalloonEngineBase>>#removeFirstAETEntry */
    static void removeFirstAETEntry() {
        int index = aetStartGet();
        aetUsedPut((aetUsedGet()) - 1);
        while (index < (aetUsedGet())) {
            aetBuffer(index, aetBuffer(index + 1));
            index += 1;
        }
    }

    /* BalloonEnginePlugin>>#repeatValue:max: */
    static long repeatValuemax(final long delta, final long maxValue) {
        long newDelta = delta;
        while (newDelta < 0) {
            newDelta += maxValue;
        }
        while (newDelta >= maxValue) {
            newDelta -= maxValue;
        }
        return newDelta;
    }

    /* BalloonEngineBase>>#resetGraphicsEngineStats */
    static void resetGraphicsEngineStats() {
        workBuffer[GWTimeInitializing] = 0;
        workBuffer[GWTimeFinishTest] = 0;
        workBuffer[GWTimeNextGETEntry] = 0;
        workBuffer[GWTimeAddAETEntry] = 0;
        workBuffer[GWTimeNextFillEntry] = 0;
        workBuffer[GWTimeMergeFill] = 0;
        workBuffer[GWTimeDisplaySpan] = 0;
        workBuffer[GWTimeNextAETEntry] = 0;
        workBuffer[GWTimeChangeAETEntry] = 0;
        workBuffer[GWCountInitializing] = 0;
        workBuffer[GWCountFinishTest] = 0;
        workBuffer[GWCountNextGETEntry] = 0;
        workBuffer[GWCountAddAETEntry] = 0;
        workBuffer[GWCountNextFillEntry] = 0;
        workBuffer[GWCountMergeFill] = 0;
        workBuffer[GWCountDisplaySpan] = 0;
        workBuffer[GWCountNextAETEntry] = 0;
        workBuffer[GWCountChangeAETEntry] = 0;
        workBuffer[GWBezierMonotonSubdivisions] = 0;
        workBuffer[GWBezierHeightSubdivisions] = 0;
        workBuffer[GWBezierOverflowSubdivisions] = 0;
        workBuffer[GWBezierLineConversions] = 0;
    }

    /* BalloonEngineBase>>#resortFirstAETEntry */
    static void resortFirstAETEntry() {
        final int edge;
        final int leftEdge;
        final long xValue;

        if ((aetStartGet()) == 0) {
            return;
        }
        edge = aetBuffer(aetStartGet());
        xValue = edgeXValueOf(edge);
        leftEdge = aetBuffer((aetStartGet()) - 1);
        if ((edgeXValueOf(leftEdge)) <= xValue) {
            return;
        }
        moveAETEntryFromedgex(aetStartGet(), edge, xValue);
    }

    /* BalloonEnginePlugin>>#returnWideBezierFill */
    static long returnWideBezierFill() {
        return (dispatchReturnValue = objat(dispatchedValue, GBWideFill));
    }

    /* BalloonEnginePlugin>>#returnWideBezierWidth */
    static long returnWideBezierWidth() {
        return (dispatchReturnValue = objat(dispatchedValue, GBWideWidth));
    }

    /* Return the fill of the (wide) line - this method is called from a case. */

    /* BalloonEnginePlugin>>#returnWideLineFill */
    static long returnWideLineFill() {
        return (dispatchReturnValue = objat(dispatchedValue, GLWideFill));
    }

    /* Return the width of the (wide) line - this method is called from a case. */

    /* BalloonEnginePlugin>>#returnWideLineWidth */
    static long returnWideLineWidth() {
        return (dispatchReturnValue = wideLineWidthOf(dispatchedValue));
    }

    /* BalloonEnginePlugin>>#rShiftTable */
    static int[] rShiftTable() {
        final int[] theTable = new int[]{0, 5, 4, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1};
        return theTable;
    }

    /*
     * Set the anti-aliasing level. Three levels are supported: 1 - No antialiasing 2 - 2x2
     * unweighted anti-aliasing 4 - 4x4 unweighted anti-aliasing.
     */

    /* BalloonEngineBase>>#setAALevel: */
    static long setAALevel(final long level) {
        int aaLevel;
        final long value;
        final long value1;

        aaLevel = 0;
        if (level >= 4) {
            aaLevel = 4;
        }
        if ((level >= 2) && (level < 4)) {
            aaLevel = 2;
        }
        if (level < 2) {
            aaLevel = 1;
        }
        /* begin aaLevelPut: */
        workBuffer[GWAALevel] = aaLevel;
        if (aaLevel == 1) {
            aaShiftPut(0);
            aaColorMaskPut(0xFFFFFFFFL);
            aaScanMaskPut(0);
        }
        if (aaLevel == 2) {
            aaShiftPut(1);
            aaColorMaskPut(4244438268L);
            aaScanMaskPut(1);
        }
        if (aaLevel == 4) {
            aaShiftPut(2);
            aaColorMaskPut(4042322160L);
            aaScanMaskPut(3);
        }
        /* begin aaColorShiftPut: */
        value = (aaShiftGet()) * 2;
        workBuffer[GWAAColorShift] = (int) value;
        /* begin aaHalfPixelPut: */
        value1 = aaShiftGet();
        workBuffer[GWAAHalfPixel] = (int) value1;
        return 0;
    }

    /* Return the run-length value from the given ShortRunArray. */

    /* BalloonEnginePlugin>>#shortRunLengthAt:from: */
    static long shortRunLengthAtfrom(final long i, final int[] runArray) {
        return runArray[(int) i] >> 16;
    }

    /*
     * Return the run-length value from the given ShortRunArray. Note: We don't need any coercion to
     * short/int here, since we deal basically only with unsigned values.
     */

    /* BalloonEnginePlugin>>#shortRunValueAt:from: */
    static long shortRunValueAtfrom(final long i, final int[] runArray) {
        return runArray[(int) i] & 0xFFFF;
    }

    /* BalloonEngineBase>>#showFill:depth:rightX: */
    static void showFilldepthrightX(final long fillIndex, final long depth, final long rightX) {
        if (!(allocateStackFillEntry())) {
            return;
        }
        stackFillValueput(0, fillIndex);
        stackFillDepthput(0, depth);
        stackFillRightXput(0, rightX);
        if ((stackFillSize()) == (stackFillEntryLength())) {
            return;
        }
        if (fillSortsbefore(0, (stackFillSize()) - (stackFillEntryLength()))) {
            /* New top fill */
            stackFillValueput(0, topFillValue());
            stackFillDepthput(0, topFillDepth());
            stackFillRightXput(0, topFillRightX());
            topFillValuePut(fillIndex);
            topFillDepthPut(depth);
            topFillRightXPut(rightX);
        }
        return;
    }

    /* BalloonEngineBase>>#smallSqrtTable */
    static int[] smallSqrtTable() {
        final int[] theTable = new int[]{0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6};
        return theTable;
    }

    /* Sort the entire global edge table */

    /* BalloonEngineBase>>#sortGlobalEdgeTable */
    static void sortGlobalEdgeTable() {
        quickSortGlobalEdgeTablefromto(workBuffer, getBufferIndex, getBufferIndex + (getUsedGet()) - 1);
    }

    /* BalloonEngineBase>>#spanEndAAGet */
    static int spanEndAAGet() {
        return workBuffer[GWSpanEndAA];
    }

    /* BalloonEngineBase>>#spanEndAAPut: */
    static long spanEndAAPut(final long value) {
        return workBuffer[GWSpanEndAA] = (int) value;
    }

    /* BalloonEngineBase>>#spanEndGet */
    static int spanEndGet() {
        return workBuffer[GWSpanEnd];
    }

    /* BalloonEngineBase>>#spanEndPut: */
    static int spanEndPut(final long value) {
        return workBuffer[GWSpanEnd] = (int) value;
    }

    /* BalloonEngineBase>>#spanSizeGet */
    static int spanSizeGet() {
        return workBuffer[GWSpanSize];
    }

    /* BalloonEngineBase>>#spanSizePut: */
    static long spanSizePut(final long value) {
        return workBuffer[GWSpanSize] = (int) value;
    }

    /* BalloonEngineBase>>#spanStartGet */
    static int spanStartGet() {
        return workBuffer[GWSpanStart];
    }

    /* BalloonEngineBase>>#spanStartPut: */
    static long spanStartPut(final long value) {
        return workBuffer[GWSpanStart] = (int) value;
    }

    /* BalloonEngineBase>>#squaredLengthOf:with: */
    static long squaredLengthOfwith(final long deltaX, final long deltaY) {
        return (deltaX * deltaX) + (deltaY * deltaY);
    }

    /* BalloonEngineBase>>#stackFillDepth: */
    static long stackFillDepth(final long index) {
        return wbStackValue(index + 1);
    }

    /* BalloonEngineBase>>#stackFillDepth:put: */
    static long stackFillDepthput(final long index, final long value) {
        return wbStackValueput(index + 1, value);
    }

    /* BalloonEngineBase>>#stackFillEntryLength */
    static long stackFillEntryLength() {
        return 3;
    }

    /* BalloonEngineBase>>#stackFillRightX: */
    static long stackFillRightX(final long index) {
        return wbStackValue(index + 2);
    }

    /* BalloonEngineBase>>#stackFillRightX:put: */
    static long stackFillRightXput(final long index, final long value) {
        return wbStackValueput(index + 2, value);
    }

    /* BalloonEngineBase>>#stackFillSize */
    static long stackFillSize() {
        return wbStackSize();
    }

    /* BalloonEngineBase>>#stackFillValue: */
    static long stackFillValue(final long index) {
        return wbStackValue(index);
    }

    /* BalloonEngineBase>>#stackFillValue:put: */
    static long stackFillValueput(final long index, final long value) {
        return wbStackValueput(index, value);
    }

    /* BalloonEngineBase>>#stateGet */
    static long stateGet() {
        return workBuffer[GWState];
    }

    /* BalloonEngineBase>>#statePut: */
    static void statePut(final long value) {
        workBuffer[GWState] = (int) value;
    }

    /*
     * Initialize the current entry in the GET by stepping to the current scan line
     */

    /* BalloonEnginePlugin>>#stepToFirstBezier */
    static void stepToFirstBezier() {
        stepToFirstBezierInat(getBuffer(getStartGet()), currentYGet());
    }

    /*
     * Initialize the bezier at yValue. TODO: Check if reducing maxSteps from 2*deltaY to deltaY
     * brings a *significant* performance improvement. In theory this should make for double step
     * performance but will cost in quality. Might be that the AA stuff will compensate for this -
     * but I'm not really sure.
     */

    /* BalloonEnginePlugin>>#stepToFirstBezierIn:at: */
    static void stepToFirstBezierInat(final long bezier, final long yValue) {
        final long deltaY;
        final long endX;
        final long endY;
        final long fwDDx;
        final long fwDDy;
        long fwDx;
        long fwDy;
        final long fwX1;
        final long fwX2;
        final long fwY1;
        final long fwY2;
        long maxSteps;
        final long scaledStepSize;
        final long squaredStepSize;
        final long startX;
        long startY;
        final long viaX;
        final long viaY;

        /* Do a quick check if there is anything at all to do */
        if ((!(isWide(bezier))) && (yValue >= (bezierEndYOf(bezier)))) {
            edgeNumLinesOfput(bezier, 0);
            return;
        }
        startX = edgeXValueOf(bezier);
        startY = edgeYValueOf(bezier);
        viaX = objat(bezier, GBViaX);
        viaY = objat(bezier, GBViaY);
        endX = bezierEndXOf(bezier);
        endY = bezierEndYOf(bezier);

        /* Initialize integer forward differencing */
        deltaY = endY - startY;
        fwX1 = (viaX - startX) * 2;
        fwX2 = (startX + endX) - (viaX * 2);
        fwY1 = (viaY - startY) * 2;
        fwY2 = (startY + endY) - (viaY * 2);
        maxSteps = deltaY * 2;
        if (maxSteps < 2) {
            maxSteps = 2;
        }
        scaledStepSize = div(0x1000000, maxSteps);
        squaredStepSize = absoluteSquared8Dot24(scaledStepSize);
        fwDx = fwX1 * scaledStepSize;
        fwDDx = (fwX2 * squaredStepSize) * 2;
        fwDx += fwDDx / 2;
        fwDy = fwY1 * scaledStepSize;
        fwDDy = (fwY2 * squaredStepSize) * 2;

        /* Store the values */
        fwDy += fwDDy / 2;
        edgeNumLinesOfput(bezier, deltaY);
        bezierUpdateDataOf(bezier, GBUpdateX, (startX * 256));
        bezierUpdateDataOf(bezier, GBUpdateY, (startY * 256));
        bezierUpdateDataOf(bezier, GBUpdateDX, fwDx);
        bezierUpdateDataOf(bezier, GBUpdateDY, fwDy);
        bezierUpdateDataOf(bezier, GBUpdateDDX, fwDDx);
        bezierUpdateDataOf(bezier, GBUpdateDDY, fwDDy);
        if (!(((startY = edgeYValueOf(bezier))) == yValue)) {
            stepToNextBezierInat(bezier, yValue);
            edgeNumLinesOfput(bezier, deltaY - (yValue - startY));
        }
    }

    /*
     * Initialize the current entry in the GET by stepping to the current scan line
     */

    /* BalloonEnginePlugin>>#stepToFirstLine */
    static void stepToFirstLine() {
        stepToFirstLineInat(getBuffer(getStartGet()), currentYGet());
    }

    /* Initialize the line at yValue */

    /* BalloonEnginePlugin>>#stepToFirstLineIn:at: */
    static void stepToFirstLineInat(final long line, final long yValue) {
        final long deltaX;
        final long deltaY;
        long error;
        final long errorAdjUp;
        long i;
        final long startY;
        final long widthX;
        final long xDir;
        final long xInc;

        /* Do a quick check if there is anything at all to do */
        if ((!(isWide(line))) && (yValue >= (lineEndYOf(line)))) {
            edgeNumLinesOfput(line, 0);
            return;
        }
        deltaX = (lineEndXOf(line)) - (edgeXValueOf(line));
        /* Check if edge goes left to right */
        deltaY = (lineEndYOf(line)) - (edgeYValueOf(line));
        if (deltaX >= 0) {
            xDir = 1;
            widthX = deltaX;
            error = 0;
        } else {
            xDir = -1;
            widthX = 0 - deltaX;
            error = 1 - deltaY;
        }
        if (deltaY == 0) {
            /* No error for horizontal edges */
            error = 0;
            /* Encodes width and direction */
            xInc = deltaX;
            errorAdjUp = 0;
        } else {
            /* Check if edge is y-major */
            if (deltaY > widthX) {
                /* Note: The '>' instead of '>=' could be important here... */
                xInc = 0;
                errorAdjUp = widthX;
            } else {
                xInc = div(widthX, deltaY) * xDir;
                errorAdjUp = mod(widthX, deltaY);
            }
        }
        edgeNumLinesOfput(line, deltaY);
        objatput(line, GLXDirection, xDir);
        objatput(line, GLXIncrement, xInc);
        lineErrorOfput(line, error);
        objatput(line, GLErrorAdjUp, errorAdjUp);
        objatput(line, GLErrorAdjDown, deltaY);
        if (!(((startY = edgeYValueOf(line))) == yValue)) {
            for (i = startY; i < yValue; i += 1) {
                stepToNextLineInat(line, i);
            }
            edgeNumLinesOfput(line, deltaY - (yValue - startY));
        }
    }

    /*
     * Initialize the current entry in the GET by stepping to the current scan line
     */

    /* BalloonEnginePlugin>>#stepToFirstWideBezier */
    static void stepToFirstWideBezier() {
        stepToFirstWideBezierInat(getBuffer(getStartGet()), currentYGet());
    }

    /* Initialize the bezier at yValue */

    /* BalloonEnginePlugin>>#stepToFirstWideBezierIn:at: */
    static void stepToFirstWideBezierInat(final long bezier, final long yValue) {
        final long endX;
        final long lineOffset;
        final long lineWidth;
        final long nLines;
        final int startY;
        int xDir;
        final long yEntry;
        final long yExit;

        /* Get some values */
        lineWidth = wideBezierExtentOf(bezier);
        /* Compute the incremental values of the bezier */
        lineOffset = offsetFromWidth(lineWidth);
        endX = bezierEndXOf(bezier);
        startY = edgeYValueOf(bezier);
        stepToFirstBezierInat(bezier, startY);
        /* Copy the incremental update data */
        nLines = edgeNumLinesOf(bezier);
        for (int i = 0; i <= 5; i += 1) {
            wideBezierUpdateDataOf(bezier, i, bezierUpdateDataOf(bezier, i));
        }
        xDir = bezierUpdateDataOf(bezier, GBUpdateDX);
        if (xDir == 0) {
            xDir = bezierUpdateDataOf(bezier, GBUpdateDDX);
        }
        if (xDir >= 0) {
            xDir = 1;
        } else {
            xDir = -1;
        }
        if (xDir < 0) {
            adjustWideBezierLeftwidthoffsetendX(bezier, lineWidth, lineOffset, endX);
        } else {
            adjustWideBezierRightwidthoffsetendX(bezier, lineWidth, lineOffset, endX);
        }
        if (nLines == 0) {
            bezierUpdateDataOf(bezier, GBUpdateX, bezierFinalXOf(bezier) * 256);
        }
        edgeNumLinesOfput(bezier, nLines + lineWidth);
        /* turned on at lineOffset */
        yEntry = 0;
        /* turned off at zero */
        yExit = (0 - nLines) - lineOffset;
        wideBezierEntryOfput(bezier, yEntry);
        wideBezierExitOfput(bezier, yExit);
        if ((yEntry >= lineOffset) && (yExit < 0)) {
            edgeFillsValidate(bezier);
        } else {
            edgeFillsInvalidate(bezier);
        }
        computeFinalWideBezierValueswidth(bezier, lineWidth);
        if (!(startY == yValue)) {
            /* Note: Must single step here so that entry/exit works */
            for (int i = startY; i < yValue; i += 1) {
                stepToNextWideBezierInat(bezier, i);
            }
            edgeNumLinesOfput(bezier, (edgeNumLinesOf(bezier)) - (yValue - startY));
        }
    }

    /*
     * Initialize the current entry in the GET by stepping to the current scan line
     */

    /* BalloonEnginePlugin>>#stepToFirstWideLine */
    static long stepToFirstWideLine() {
        return stepToFirstWideLineInat(getBuffer(getStartGet()), currentYGet());
    }

    /* Initialize the wide line at yValue. */

    /* BalloonEnginePlugin>>#stepToFirstWideLineIn:at: */
    static long stepToFirstWideLineInat(final long line, final long yValue) {
        long i;
        final long lineOffset;
        final long lineWidth;
        final long nLines;
        final long startX;
        final long startY;
        final long xDir;
        final long yEntry;
        final long yExit;

        /* Get some values */
        lineWidth = wideLineExtentOf(line);

        /* Compute the incremental values of the line */
        lineOffset = offsetFromWidth(lineWidth);
        startX = edgeXValueOf(line);
        startY = edgeYValueOf(line);
        stepToFirstLineInat(line, startY);
        nLines = edgeNumLinesOf(line);

        /* Adjust the line to start at the correct X position */
        xDir = lineXDirectionOf(line);
        edgeXValueOfput(line, startX - lineOffset);
        edgeNumLinesOfput(line, nLines + lineWidth);
        if (xDir > 0) {
            wideLineWidthOfput(line, (lineXIncrementOf(line)) + lineWidth);
        } else {
            wideLineWidthOfput(line, lineWidth - (lineXIncrementOf(line)));
            edgeXValueOfput(line, (edgeXValueOf(line)) + (lineXIncrementOf(line)));
        }

        /* turned on at lineOffset */
        yEntry = 0;

        /* turned off at zero */
        yExit = (0 - nLines) - lineOffset;
        wideLineEntryOfput(line, yEntry);
        wideLineExitOfput(line, yExit);
        if ((yEntry >= lineOffset) && (yExit < 0)) {
            edgeFillsValidate(line);
        } else {
            edgeFillsInvalidate(line);
        }
        if (!(startY == yValue)) {
            for (i = startY; i < yValue; i += 1) {
                stepToNextWideLineInat(line, i);
            }
            edgeNumLinesOfput(line, (edgeNumLinesOf(line)) - (yValue - startY));
        }
        return 0;
    }

    /* Process the current entry in the AET by stepping to the next scan line */

    /* BalloonEnginePlugin>>#stepToNextBezier */
    static void stepToNextBezier() {
        stepToNextBezierInat(aetBuffer(aetStartGet()), currentYGet());
    }

    /*
     * Incrementally step to the next scan line in the given bezier update data. Note: This method
     * has been written so that inlining works, e.g., not declaring updateData as 'int[]' but
     * casting it on every use.
     */

    /* BalloonEnginePlugin>>#stepToNextBezierForward:at: */
    static long stepToNextBezierForwardat(final long bzesierUpdateDataIndex, final long yValue) {
        int fwDx;
        int fwDy;
        int lastX;
        int lastY;
        final long minY;

        lastX = bezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateX);
        lastY = bezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateY);
        fwDx = bezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateDX);
        fwDy = bezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateDY);

        /*
         * Step as long as we haven't yet reached minY and also as long as fwDy is greater than zero
         * thus stepping down. Note: The test for fwDy should not be necessary in theory but is a
         * good insurance in practice.
         */
        minY = yValue * 256;
        while ((minY > lastY) && (fwDy >= 0)) {
            lastX += ((fwDx + 32768) >> 16);
            lastY += ((fwDy + 32768) >> 16);
            fwDx += bezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateDDX);
            fwDy += bezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateDDY);
        }
        bezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateX, lastX);
        bezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateY, lastY);
        bezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateDX, fwDx);
        bezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateDY, fwDy);
        return (lastX >> 8);
    }

    /* Copy of BalloonEnginePlugin>>#stepToNextBezierForward:at: for wide beziers */
    static long stepToNextBezierForwardatWide(final long bzesierUpdateDataIndex, final long yValue) {
        int fwDx;
        int fwDy;
        int lastX;
        int lastY;
        final long minY;

        lastX = wideBezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateX);
        lastY = wideBezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateY);
        fwDx = wideBezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateDX);
        fwDy = wideBezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateDY);

        /*
         * Step as long as we haven't yet reached minY and also as long as fwDy is greater than zero
         * thus stepping down. Note: The test for fwDy should not be necessary in theory but is a
         * good insurance in practice.
         */
        minY = yValue * 256;
        while ((minY > lastY) && (fwDy >= 0)) {
            lastX += ((fwDx + 32768) >> 16);
            lastY += ((fwDy + 32768) >> 16);
            fwDx += wideBezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateDDX);
            fwDy += wideBezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateDDY);
        }
        wideBezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateX, lastX);
        wideBezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateY, lastY);
        wideBezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateDX, fwDx);
        wideBezierUpdateDataOf(bzesierUpdateDataIndex, GBUpdateDY, fwDy);
        return (lastX >> 8);
    }

    /* Incrementally step to the next scan line in the given bezier */

    /* BalloonEnginePlugin>>#stepToNextBezierIn:at: */
    static void stepToNextBezierInat(final long bezier, final long yValue) {
        final long xValue;

        xValue = stepToNextBezierForwardat(bezier, yValue);
        edgeXValueOfput(bezier, xValue);
    }

    /* Process the current entry in the AET by stepping to the next scan line */

    /* BalloonEnginePlugin>>#stepToNextLine */
    static void stepToNextLine() {
        stepToNextLineInat(aetBuffer(aetStartGet()), currentYGet());
    }

    /* Incrementally step to the next scan line in the given line */

    /* BalloonEnginePlugin>>#stepToNextLineIn:at: */
    static void stepToNextLineInat(final long line, @SuppressWarnings("unused") final long yValue) {
        long err;
        long x;

        x = (edgeXValueOf(line)) + (lineXIncrementOf(line));
        err = (objat(line, GLError)) + (objat(line, GLErrorAdjUp));
        if (err > 0) {
            x += lineXDirectionOf(line);
            err -= objat(line, GLErrorAdjDown);
        }
        lineErrorOfput(line, err);
        edgeXValueOfput(line, x);
    }

    /*
     * Initialize the current entry in the GET by stepping to the current scan line
     */

    /* BalloonEnginePlugin>>#stepToNextWideBezier */
    static long stepToNextWideBezier() {
        stepToNextWideBezierInat(aetBuffer(aetStartGet()), currentYGet());
        return 0;
    }

    /* Incrementally step to the next scan line in the given wide bezier */

    /* BalloonEnginePlugin>>#stepToNextWideBezierIn:at: */
    static void stepToNextWideBezierInat(final long bezier, final long yValue) {
        final long lineOffset;
        final long lineWidth;
        final long yEntry;
        final long yExit;

        /* Don't inline this */
        lineWidth = wideBezierExtentOf(bezier);
        lineOffset = offsetFromWidth(lineWidth);
        yEntry = (objat(bezier, GBWideEntry)) + 1;
        yExit = (objat(bezier, GBWideExit)) + 1;
        wideBezierEntryOfput(bezier, yEntry);
        wideBezierExitOfput(bezier, yExit);
        if (yEntry >= lineOffset) {
            edgeFillsValidate(bezier);
        }
        if (yExit >= 0) {
            edgeFillsInvalidate(bezier);
        }
        if ((yExit + lineOffset) < 0) {
            stepToNextBezierForwardat(bezier, yValue);
        } else {
            /* Adjust the last x value to the final x recorded previously */
            bezierUpdateDataOf(bezier, GBUpdateX, bezierFinalXOf(bezier) * 256);
        }
        stepToNextBezierForwardatWide(bezier, yValue);
        computeFinalWideBezierValueswidth(bezier, lineWidth);
    }

    /* Process the current entry in the AET by stepping to the next scan line */

    /* BalloonEnginePlugin>>#stepToNextWideLine */
    static long stepToNextWideLine() {
        return stepToNextWideLineInat(aetBuffer(aetStartGet()), currentYGet());
    }

    /* Incrementally step to the next scan line in the given wide line */

    /* BalloonEnginePlugin>>#stepToNextWideLineIn:at: */
    static long stepToNextWideLineInat(final long line, final long yValue) {
        final long lastX;
        final long lineOffset;
        final long lineWidth;
        final long nextX;
        final long yEntry;
        final long yExit;

        /* Adjust entry/exit values */
        yEntry = (wideLineEntryOf(line)) + 1;
        yExit = (wideLineExitOf(line)) + 1;
        wideLineEntryOfput(line, yEntry);
        wideLineExitOfput(line, yExit);
        lineWidth = wideLineExtentOf(line);
        lineOffset = offsetFromWidth(lineWidth);
        if (yEntry >= lineOffset) {
            edgeFillsValidate(line);
        }
        if (yExit >= 0) {
            edgeFillsInvalidate(line);
        }
        lastX = edgeXValueOf(line);
        stepToNextLineInat(line, yValue);

        /* Check for special start/end adjustments */
        nextX = edgeXValueOf(line);
        if ((yEntry <= lineWidth) || ((yExit + lineOffset) >= 0)) {

            /* Yes, need an update */
            adjustWideLineafterSteppingFromto(line, lastX, nextX);
        }
        return 0;
    }

    /* BalloonEngineBase>>#stopBecauseOf: */
    static void stopBecauseOf(final long stopReason) {
        stopReasonPut(stopReason);
        engineStopped = true;
    }

    /* BalloonEngineBase>>#stopReasonGet */
    static long stopReasonGet() {
        return workBuffer[GWStopReason];
    }

    /* BalloonEngineBase>>#stopReasonPut: */
    static long stopReasonPut(final long value) {
        return workBuffer[GWStopReason] = (int) value;
    }

    /* BalloonEngineBase>>#storeEdgeStateFrom:into: */
    static void storeEdgeStateFrominto(final long edge, final PointersObject edgeOop) {
        if ((slotSizeOf(edgeOop)) < ETBalloonEdgeDataSize) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed();
        }
        storeValue(ETIndexIndex, edgeOop, objectIndexOf(edge));
        storeValue(ETXValueIndex, edgeOop, edgeXValueOf(edge));
        storeValue(ETYValueIndex, edgeOop, currentYGet());
        storeValue(ETZValueIndex, edgeOop, edgeZValueOf(edge));
        storeValue(ETLinesIndex, edgeOop, edgeNumLinesOf(edge));
        /* begin lastExportedEdgePut: */
        workBuffer[GWLastExportedEdge] = (int) edge;
    }

    /* BalloonEngineBase>>#storeEngineStateInto: */
    static void storeEngineStateInto(@SuppressWarnings("unused") final PointersObject oop) {
        objUsedPut(objUsed);
    }

    /* BalloonEngineBase>>#storeFillStateInto: */
    static void storeFillStateInto(final PointersObject fillOop) {
        final long fillIndex;
        final long leftX;
        final long rightX;

        fillIndex = lastExportedFillGet();
        leftX = lastExportedLeftXGet();
        rightX = lastExportedRightXGet();
        if ((slotSizeOf(fillOop)) < FTBalloonFillDataSize) {
            CompilerDirectives.transferToInterpreter();
            throw new PrimitiveFailed();
        }
        storeValue(FTIndexIndex, fillOop, objectIndexOf(fillIndex));
        storeValue(FTMinXIndex, fillOop, leftX);
        storeValue(FTMaxXIndex, fillOop, rightX);
        storeValue(FTYValueIndex, fillOop, currentYGet());
    }

    /* BalloonEngineBase>>#storeRenderingState */
    static long storeRenderingState(final PointersObject edgeOop, final PointersObject fillOop) {
        if (failed()) {
            throw new SqueakException("return null");
        }
        if (engineStopped) {
            /* Check the stop reason and store the required information */
            storeStopStateIntoEdgefill(edgeOop, fillOop);
        }
        storeEngineStateInto(engine);
        return stopReasonGet();
    }

    /* BalloonEngineBase>>#storeStopStateIntoEdge:fill: */
    static void storeStopStateIntoEdgefill(final PointersObject edgeOop, final PointersObject fillOop) {
        final int edge;
        final long reason = stopReasonGet();
        if (reason == GErrorGETEntry) {
            edge = getBuffer(getStartGet());
            storeEdgeStateFrominto(edge, edgeOop);
            getStartPut((getStartGet()) + 1);
        } else if (reason == GErrorFillEntry) {
            storeFillStateInto(fillOop);
        } else if (reason == GErrorAETEntry) {
            edge = aetBuffer(aetStartGet());
            storeEdgeStateFrominto(edge, edgeOop);
        }
    }

    /* Recursively subdivide the curve on the bezier stack. */

    /* BalloonEnginePlugin>>#subdivideBezierFrom: */
    static long subdivideBezierFrom(final long index) {
        final long index1;
        final long index2;
        final long otherIndex;

        otherIndex = subdivideBezier(index);
        if (!(otherIndex == index)) {
            index1 = subdivideBezierFrom(index);
            if (engineStopped) {
                return 0;
            }
            index2 = subdivideBezierFrom(otherIndex);
            if (engineStopped) {
                return 0;
            }
            if (index1 >= index2) {
                return index1;
            } else {
                return index2;
            }
        }
        return index;
    }

    /* Subdivide the given bezier curve if necessary */

    /* BalloonEnginePlugin>>#subdivideBezier: */
    static long subdivideBezier(final long index) {
        long deltaX;
        long deltaY;
        final long endX;
        final long endY;
        final long startX;
        final long startY;

        startY = bzStartY(index);

        /* If the receiver is horizontal, don't do anything */
        endY = bzEndY(index);
        if (endY == startY) {
            return index;
        }
        deltaY = endY - startY;
        if (deltaY < 0) {
            deltaY = 0 - deltaY;
        }
        if (deltaY > 0xFF) {
            incrementStatby(GWBezierHeightSubdivisions, 1);
            return computeBezierSplitAtHalf(index);
        }
        startX = bzStartX(index);
        endX = bzEndX(index);
        deltaX = endX - startX;
        if (deltaX < 0) {
            deltaX = 0 - deltaX;
        }
        if ((deltaY * 32) < deltaX) {
            incrementStatby(GWBezierOverflowSubdivisions, 1);
            return computeBezierSplitAtHalf(index);
        }
        return index;
    }

    /* Check if the given bezier curve is monoton in X. If not, subdivide it */

    /* BalloonEnginePlugin>>#subdivideToBeMonotonInX: */
    static long subdivideToBeMonotonInX(final long index) {
        long denom;
        final long dx1;
        final long dx2;
        final long endX;
        long num;
        final long startX;
        final long viaX;

        startX = bzStartX(index);
        viaX = bzViaX(index);
        endX = bzEndX(index);
        dx1 = viaX - startX;
        dx2 = endX - viaX;
        if ((dx1 * dx2) >= 0) {
            return index;
        }
        incrementStatby(GWBezierMonotonSubdivisions, 1);
        denom = dx2 - dx1;
        num = dx1;
        if (num < 0) {
            num = 0 - num;
        }
        if (denom < 0) {
            denom = 0 - denom;
        }
        return computeBeziersplitAt(index, (((double) num)) / (((double) denom)));
    }

    /* Check if the given bezier curve is monoton in Y. If not, subdivide it */

    /* BalloonEnginePlugin>>#subdivideToBeMonotonInY: */
    static long subdivideToBeMonotonInY(final long index) {
        long denom;
        final long dy1;
        final long dy2;
        final long endY;
        long num;
        final long startY;
        final long viaY;

        startY = bzStartY(index);
        viaY = bzViaY(index);
        endY = bzEndY(index);
        dy1 = viaY - startY;
        dy2 = endY - viaY;
        if ((dy1 * dy2) >= 0) {
            return index;
        }
        incrementStatby(GWBezierMonotonSubdivisions, 1);
        denom = dy2 - dy1;
        num = dy1;
        if (num < 0) {
            num = 0 - num;
        }
        if (denom < 0) {
            denom = 0 - denom;
        }
        return computeBeziersplitAt(index, (((double) num)) / (((double) denom)));
    }

    /*
     * Check if the given bezier curve is monoton in Y, and, if desired in X. If not, subdivide it
     */

    /* BalloonEnginePlugin>>#subdivideToBeMonoton:inX: */
    static long subdivideToBeMonotoninX(final long base, final boolean doTestX) {
        final long base2;
        long index1;
        long index2;

        base2 = (index1 = (index2 = subdivideToBeMonotonInY(base)));
        if (doTestX) {
            index1 = subdivideToBeMonotonInX(base);
        }
        if (index1 > index2) {
            index2 = index1;
        }
        if ((base != base2) && (doTestX)) {
            index1 = subdivideToBeMonotonInX(base2);
        }
        if (index1 > index2) {
            index2 = index1;
        }
        return index2;
    }

    /* BalloonEngineBase>>#toggleFillsOf: */
    static void toggleFillsOf(final long edge) {
        final long depth;
        long fillIndex;

        if (!(needAvailableSpace((stackFillEntryLength()) * 2))) {
            return;
        }
        depth = (((edgeZValueOf(edge))) << 1);
        fillIndex = objat(edge, GEFillIndexLeft);
        if (!(fillIndex == 0)) {
            toggleFilldepthrightX(fillIndex, depth, 999999999);
        }
        fillIndex = objat(edge, GEFillIndexRight);
        if (!(fillIndex == 0)) {
            toggleFilldepthrightX(fillIndex, depth, 999999999);
        }
        quickRemoveInvalidFillsAt(edgeXValueOf(edge));
    }

    /* Make the fill style with the given index either visible or invisible */

    /* BalloonEngineBase>>#toggleFill:depth:rightX: */
    static void toggleFilldepthrightX(final long fillIndex, final long depth, final long rightX) {
        final boolean hidden;

        if ((stackFillSize()) == 0) {
            if (allocateStackFillEntry()) {
                topFillValuePut(fillIndex);
                topFillDepthPut(depth);
                topFillRightXPut(rightX);
            }
        } else {
            hidden = hideFilldepth(fillIndex, depth);
            if (!hidden) {
                showFilldepthrightX(fillIndex, depth, rightX);
            }
        }
    }

    /* BalloonEngineBase>>#toggleWideFillOf: */
    static void toggleWideFillOf(final long edge) {
        final long depth;
        final long fill;
        final long index;
        final long lineWidth;
        final long rightX;
        final int type;

        type = edgeTypeOf(edge);
        dispatchedValue = edge;
        switch (type) {
            case 0:
            case 1:
                errorWrongIndex();
                break;
            case 2:
                returnWideLineWidth();
                break;
            case 3:
                returnWideBezierWidth();
                break;
        }
        lineWidth = dispatchReturnValue;
        switch (type) {
            case 0:
            case 1:
                errorWrongIndex();
                break;
            case 2:
                returnWideLineFill();
                break;
            case 3:
                returnWideBezierFill();
                break;
        }
        fill = dispatchReturnValue;
        if (fill == 0) {
            return;
        }
        if (!(needAvailableSpace(stackFillEntryLength()))) {
            return;
        }

        /* So lines sort before interior fills */
        depth = ((((edgeZValueOf(edge))) << 1)) + 1;
        rightX = (edgeXValueOf(edge)) + lineWidth;
        index = findStackFilldepth(fill, depth);
        if (index == -1) {
            showFilldepthrightX(fill, depth, rightX);
        } else {
            if ((stackFillRightX(index)) < rightX) {
                stackFillRightXput(index, rightX);
            }
        }
        quickRemoveInvalidFillsAt(edgeXValueOf(edge));
    }

    /* BalloonEngineBase>>#topDepth */
    static long topDepth() {
        if ((stackFillSize()) == 0) {
            return -1;
        } else {
            return topFillDepth();
        }
    }

    /* BalloonEngineBase>>#topFill */
    static long topFill() {
        if ((stackFillSize()) == 0) {
            return 0;
        } else {
            return topFillValue();
        }
    }

    /* BalloonEngineBase>>#topFillDepth */
    static long topFillDepth() {
        return stackFillDepth((stackFillSize()) - (stackFillEntryLength()));
    }

    /* BalloonEngineBase>>#topFillDepthPut: */
    static long topFillDepthPut(final long value) {
        return stackFillDepthput((stackFillSize()) - (stackFillEntryLength()), value);
    }

    /* BalloonEngineBase>>#topFillRightX */
    static long topFillRightX() {
        return stackFillRightX((stackFillSize()) - (stackFillEntryLength()));
    }

    /* BalloonEngineBase>>#topFillRightXPut: */
    static long topFillRightXPut(final long value) {
        return stackFillRightXput((stackFillSize()) - (stackFillEntryLength()), value);
    }

    /* BalloonEngineBase>>#topFillValue */
    static long topFillValue() {
        return stackFillValue((stackFillSize()) - (stackFillEntryLength()));
    }

    /* BalloonEngineBase>>#topFillValuePut: */
    static long topFillValuePut(final long value) {
        return stackFillValueput((stackFillSize()) - (stackFillEntryLength()), value);
    }

    /* BalloonEngineBase>>#topRightX */
    static long topRightX() {
        if ((stackFillSize()) == 0) {
            return 999999999;
        } else {
            return topFillRightX();
        }
    }

    /* BalloonEngineBase>>#transformColor: */
    static long transformColor(final long fillIndexValue) {
        final int fillIndex = (int) fillIndexValue;
        int a;
        final double alphaScale;
        int b;
        int g;
        int r;

        if (!((fillIndex == 0) || (isFillColor(fillIndex)))) {
            return fillIndex;
        }
        b = fillIndex & 0xFF;
        g = ((fillIndex) >> 8) & 0xFF;
        r = ((fillIndex) >> 16) & 0xFF;
        a = ((fillIndex) >> 24) & 0xFF;
        if (hasColorTransform()) {
            alphaScale = ((a * (colorTransformGet(6))) + (colorTransformGet(7))) / a;
            r = (int) ((((r * (colorTransformGet(0))) + (colorTransformGet(1))) * alphaScale));
            g = (int) ((((g * (colorTransformGet(2))) + (colorTransformGet(3))) * alphaScale));
            b = (int) ((((b * (colorTransformGet(4))) + (colorTransformGet(5))) * alphaScale));
            a = (int) (a * alphaScale); // TODO: check this cast is ok
            r = ((r < 0) ? 0 : r);
            r = ((r < 0xFF) ? r : 0xFF);
            g = ((g < 0) ? 0 : g);
            g = ((g < 0xFF) ? g : 0xFF);
            b = ((b < 0) ? 0 : b);
            b = ((b < 0xFF) ? b : 0xFF);
            a = ((a < 0) ? 0 : a);
            a = ((a < 0xFF) ? a : 0xFF);
        }
        if (a < 1) {
            return 0;
        }
        if ((a < 0xFF) && (needsFlush())) {
            stopBecauseOf(GErrorNeedFlush);
        }
        return ((b + (((g) << 8))) + (((r) << 16))) + (((a) << 24));
    }

    /*
     * Transform n (n=1,2,3) points. If haveMatrix is true then the matrix contains the actual
     * transformation.
     */

    /* BalloonEngineBase>>#transformPoints: */
    static void transformPoints(final long n) {
        if (n > 0) {
            transformPoint(GWPoint1);
        }
        if (n > 1) {
            transformPoint(GWPoint2);
        }
        if (n > 2) {
            transformPoint(GWPoint3);
        }
        if (n > 3) {
            transformPoint(GWPoint4);
        }
    }

    /* Transform srcPoint into dstPoint by using the currently loaded matrix */
    /*
     * Note: This should be rewritten so that inlining works (e.g., removing the declarations and
     * adding argument coercions at the appropriate points)
     */

    /* BalloonEngineBase>>#transformPointX:y:into: */
    static void transformPointXyinto(final int xValue, final int yValue, final int dstPointIndex) {
        final int x;
        final int y;

        x = (int) ((((((edgeTransformGet(0)) * xValue) + ((edgeTransformGet(1)) * yValue)) + (edgeTransformGet(2))) * (((aaLevelGet())))));
        y = (int) ((((((edgeTransformGet(3)) * xValue) + ((edgeTransformGet(4)) * yValue)) + (edgeTransformGet(5))) * (((aaLevelGet())))));
        pointSetX(dstPointIndex, x);
        pointSetY(dstPointIndex, y);
    }

    /*
     * Transform the given point. If haveMatrix is true then use the current transformation.
     */

    /* BalloonEngineBase>>#transformPoint: */
    static void transformPoint(final int pointIndex) {
        if ((workBuffer[GWHasEdgeTransform]) != 0) {
            /* Note: AA adjustment is done in #transformPoint: for higher accuracy */
            transformPointinto(pointIndex, pointIndex);
        } else {
            /* Multiply each component by aaLevel and add a half pixel */
            pointSetX(pointIndex, (((pointGetX(pointIndex)) + (destOffsetXGet())) * (aaLevelGet())));
            pointSetY(pointIndex, (((pointGetY(pointIndex)) + (destOffsetYGet())) * (aaLevelGet())));
        }
    }

    /* Transform srcPoint into dstPoint by using the currently loaded matrix */
    /*
     * Note: This method has been rewritten so that inlining works (e.g., removing the declarations
     * and adding argument coercions at the appropriate points)
     */

    /* BalloonEngineBase>>#transformPoint:into: */
    static void transformPointinto(final int srcPointIndex, final int dstPointIndex) {
        transformPointXyinto(pointGetX(srcPointIndex), pointGetY(srcPointIndex), dstPointIndex);
    }

    /* Transform the given width */

    /* BalloonEngineBase>>#transformWidth: */
    static long transformWidth(final long w) {
        double deltaX;
        double deltaY;
        long dstWidth;
        final long dstWidth2;

        if (w == 0) {
            return 0;
        }
        point1SetX(0);
        point1SetY(0);
        point2SetX((w * 256));
        point2SetY(0);
        point3SetX(0);
        point3SetY((w * 256));
        transformPoints(3);
        deltaX = (((point2GetX())) - ((point1GetX())));
        deltaY = (((point2GetY())) - ((point1GetY())));
        dstWidth = ((((long) (Math.sqrt((deltaX * deltaX) + (deltaY * deltaY))))) + 128) / 256;
        deltaX = (((point3GetX())) - ((point1GetX())));
        deltaY = (((point3GetY())) - ((point1GetY())));
        dstWidth2 = ((((long) (Math.sqrt((deltaX * deltaX) + (deltaY * deltaY))))) + 128) / 256;
        if (dstWidth2 < dstWidth) {
            dstWidth = dstWidth2;
        }
        if (dstWidth == 0) {
            return 1;
        } else {
            return dstWidth;
        }
    }

    /* BalloonEngineBase>>#uncheckedTransformColor: */
    static long uncheckedTransformColor(final long fillIndex) {
        long a;
        long b;
        long g;
        long r;

        if (!(hasColorTransform())) {
            return fillIndex;
        }
        b = fillIndex & 0xFF;
        g = ((fillIndex) >> 8) & 0xFF;
        r = ((fillIndex) >> 16) & 0xFF;
        a = ((fillIndex) >> 24) & 0xFF;
        r = ((r * (colorTransformGet(0))) + (colorTransformGet(1)));
        g = ((g * (colorTransformGet(2))) + (colorTransformGet(3)));
        b = ((b * (colorTransformGet(4))) + (colorTransformGet(5)));
        a = ((a * (colorTransformGet(6))) + (colorTransformGet(7)));
        r = ((r < 0) ? 0 : r);
        r = ((r < 0xFF) ? r : 0xFF);
        g = ((g < 0) ? 0 : g);
        g = ((g < 0xFF) ? g : 0xFF);
        b = ((b < 0) ? 0 : b);
        b = ((b < 0xFF) ? b : 0xFF);
        a = ((a < 0) ? 0 : a);
        a = ((a < 0xFF) ? a : 0xFF);
        if (a < 16) {
            return 0;
        }
        return ((b + (((g) << 8))) + (((r) << 16))) + (((a) << 24));
    }

    /* BalloonEngineBase>>#wbSizeGet */
    static int wbSizeGet() {
        return workBuffer[GWSize];
    }

    /* BalloonEngineBase>>#wbSizePut: */
    static long wbSizePut(final long value) {
        return workBuffer[GWSize] = (int) value;
    }

    /* BalloonEngineBase>>#wbStackClear */
    static long wbStackClear() {
        wbTopPut(wbSizeGet());
        return 0;
    }

    /* BalloonEngineBase>>#wbStackPop: */
    static long wbStackPop(final long nItems) {
        wbTopPut((wbTopGet()) + nItems);
        return 0;
    }

    /* BalloonEngineBase>>#wbStackPush: */
    static boolean wbStackPush(final long nItems) {
        if (!(needAvailableSpace(nItems))) {
            return false;
        }
        wbTopPut((wbTopGet()) - nItems);
        return true;
    }

    /* BalloonEngineBase>>#wbStackSize */
    static long wbStackSize() {
        return (wbSizeGet()) - (wbTopGet());
    }

    /* BalloonEngineBase>>#wbStackValue: */
    static long wbStackValue(final long index) {
        return workBuffer[(wbTopGet()) + (int) index];
    }

    /* BalloonEngineBase>>#wbStackValue:put: */
    static long wbStackValueput(final long index, final long value) {
        return workBuffer[(wbTopGet()) + (int) index] = (int) value;
    }

    /* BalloonEngineBase>>#wbTopGet */
    static int wbTopGet() {
        return workBuffer[GWBufferTop];
    }

    /* BalloonEngineBase>>#wbTopPut: */
    static long wbTopPut(final long value) {
        return workBuffer[GWBufferTop] = (int) value;
    }

    /* BalloonEnginePlugin>>#wideBezierEntryOf: */
    static long wideBezierEntryOf(final long line) {
        return objat(line, GBWideEntry);
    }

    /* BalloonEnginePlugin>>#wideBezierEntryOf:put: */
    static void wideBezierEntryOfput(final long line, final long value) {
        objatput(line, GBWideEntry, value);
    }

    /* BalloonEnginePlugin>>#wideBezierExitOf: */
    static long wideBezierExitOf(final long line) {
        return objat(line, GBWideExit);
    }

    /* BalloonEnginePlugin>>#wideBezierExitOf:put: */
    static void wideBezierExitOfput(final long line, final long value) {
        objatput(line, GBWideExit, value);
    }

    /* BalloonEnginePlugin>>#wideBezierExtentOf: */
    static long wideBezierExtentOf(final long bezier) {
        return objat(bezier, GBWideExtent);
    }

    /* BalloonEnginePlugin>>#wideBezierExtentOf:put: */
    static void wideBezierExtentOfput(final long bezier, final long value) {
        objatput(bezier, GBWideExtent, value);
    }

    /* BalloonEnginePlugin>>#wideBezierFillOf: */
    static long wideBezierFillOf(final long bezier) {
        return objat(bezier, GBWideFill);
    }

    /* BalloonEnginePlugin>>#wideBezierFillOf:put: */
    static void wideBezierFillOfput(final long bezier, final long value) {
        objatput(bezier, GBWideFill, value);
    }

    /* BalloonEnginePlugin>>#wideBezierUpdateDataOf: */
    static int wideBezierUpdateDataOf(final long bezier, final int index) {
        return workBuffer[wideBezierUpdateDataIndexOf(bezier) + index];
    }

    static int wideBezierUpdateDataOf(final long bezier, final int index, final long value) {
        return workBuffer[wideBezierUpdateDataIndexOf(bezier) + index] = (int) value;
    }

    static int wideBezierUpdateDataIndexOf(final long bezier) {
        return (objBufferIndex + (int) bezier) + GBWideUpdateData;
    }

    /* BalloonEnginePlugin>>#wideBezierWidthOf: */
    static long wideBezierWidthOf(final long line) {
        return objat(line, GBWideWidth);
    }

    /* BalloonEnginePlugin>>#wideBezierWidthOf:put: */
    static void wideBezierWidthOfput(final long line, final long value) {
        objatput(line, GBWideWidth, value);
    }

    /* BalloonEnginePlugin>>#wideLineEntryOf: */
    static long wideLineEntryOf(final long line) {
        return objat(line, GLWideEntry);
    }

    /* BalloonEnginePlugin>>#wideLineEntryOf:put: */
    static void wideLineEntryOfput(final long line, final long value) {
        objatput(line, GLWideEntry, value);
    }

    /* BalloonEnginePlugin>>#wideLineExitOf: */
    static long wideLineExitOf(final long line) {
        return objat(line, GLWideExit);
    }

    /* BalloonEnginePlugin>>#wideLineExitOf:put: */
    static void wideLineExitOfput(final long line, final long value) {
        objatput(line, GLWideExit, value);
    }

    /* BalloonEnginePlugin>>#wideLineExtentOf: */
    static long wideLineExtentOf(final long line) {
        return objat(line, GLWideExtent);
    }

    /* BalloonEnginePlugin>>#wideLineExtentOf:put: */
    static void wideLineExtentOfput(final long line, final long value) {
        objatput(line, GLWideExtent, value);
    }

    /* BalloonEnginePlugin>>#wideLineFillOf: */
    static long wideLineFillOf(final long line) {
        return objat(line, GLWideFill);
    }

    /* BalloonEnginePlugin>>#wideLineFillOf:put: */
    static void wideLineFillOfput(final long line, final long value) {
        objatput(line, GLWideFill, value);
    }

    /* BalloonEnginePlugin>>#wideLineWidthOf: */
    static long wideLineWidthOf(final long line) {
        return objat(line, GLWideWidth);
    }

    /* BalloonEnginePlugin>>#wideLineWidthOf:put: */
    static void wideLineWidthOfput(final long line, final long value) {
        objatput(line, GLWideWidth, value);
    }

    /* BalloonEngineBase>>#workBufferPut: */
    static void workBufferPut(final NativeObject wbOop) {
        workBuffer = wbOop.getIntStorage();
    }

    /*
     * POLYFILLS
     */

    private static boolean failed() {
        return false;
    }

    private static int slotSizeOf(final PointersObject object) {
        return object.size();
    }

    private static long ioMicroMSecs() {
        return System.currentTimeMillis();
    }

    private static void storeValue(final int i, final PointersObject object, final Object value) {
        object.atput0(i, value);
    }

    private static boolean isPointers(final AbstractSqueakObject object) {
        return SqueakGuards.isPointersObject(object);
    }

    private static boolean isWords(final NativeObject object) {
        return object.isIntType();
    }

    private static int slotSizeOf(final NativeObject words) {
        return words.getIntLength();
    }

    private static Object fetchClassOf(final NativeObject object) {
        return object.getSqueakClass();
    }

    private static ArrayObject fetchArrayofObject(final int index, final PointersObject object) {
        return (ArrayObject) object.at0(index);
    }

    private static Object fetchObjectofObject(final int index, final PointersObject object) {
        return object.at0(index);
    }

    private static PointersObject fetchPointerofObject(final int index, final PointersObject object) {
        return (PointersObject) object.at0(index);
    }

    private static NativeObject fetchNativeofObject(final int index, final PointersObject object) {
        return (NativeObject) object.at0(index);
    }

    private static long fetchIntegerofObject(final int index, final PointersObject object) {
        return (long) object.at0(index);
    }

    static void workbufferAtput(final int index, final float value) {
        workBuffer[index] = (int) value;
    }

    private static boolean isIntegerObject(final Object value) {
        return value instanceof Long;
    }

    private static boolean isFloatObject(final Object value) {
        return value instanceof Double || value instanceof FloatObject;
    }

    private static PointersObject fetchPointerofObject(final int index, final ArrayObject object) {
        return (PointersObject) object.getObjectStorage()[index];
    }

    private static int slotSizeOf(final ArrayObject object) {
        if (object.isEmptyType()) {
            return object.getEmptyLength();
        } else {
            return object.getObjectLength();
        }
    }

    private static double floatValueOf(final Object value) {
        if (value instanceof FloatObject) {
            return ((FloatObject) value).getValue();
        } else {
            return (double) value;
        }
    }

    private static long integerValueOf(final Object value) {
        return (long) value;
    }

    private static boolean isWords(final AbstractSqueakObject object) {
        return object instanceof NativeObject && ((NativeObject) object).isIntType();
    }

    private static boolean isArray(final AbstractSqueakObject object) {
        return SqueakGuards.isArrayObject(object);
    }

    private static int aetBuffer(final long index) {
        return workBuffer[aetBufferIndex + (int) index];
    }

    private static void aetBuffer(final long index, final long value) {
        workBuffer[aetBufferIndex + (int) index] = (int) value;
    }

    private static int getBuffer(final long index) {
        return workBuffer[getBufferIndex + (int) index];
    }

    private static void getBuffer(final long index, final long value) {
        workBuffer[getBufferIndex + (int) index] = (int) value;
    }

    private static long unsignedAt(final long index) {
        return Integer.toUnsignedLong(workBuffer[(int) index]);
    }

    public static long div(final long a, final long b) {
        return Math.floorDiv(a, b);
    }

    public static long mod(final long a, final long b) {
        return a - div(a, b) * b;
    }
}
