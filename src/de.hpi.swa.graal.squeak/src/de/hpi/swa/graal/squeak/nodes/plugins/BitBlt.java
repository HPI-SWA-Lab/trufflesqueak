package de.hpi.swa.graal.squeak.nodes.plugins;

import java.util.function.LongBinaryOperator;

import com.oracle.truffle.api.CompilerDirectives;

import de.hpi.swa.graal.squeak.exceptions.PrimitiveExceptions.PrimitiveFailed;
import de.hpi.swa.graal.squeak.exceptions.SqueakExceptions.SqueakException;
import de.hpi.swa.graal.squeak.model.AbstractSqueakObject;
import de.hpi.swa.graal.squeak.model.ArrayObject;
import de.hpi.swa.graal.squeak.model.FloatObject;
import de.hpi.swa.graal.squeak.model.NativeObject;
import de.hpi.swa.graal.squeak.model.PointersObject;
import de.hpi.swa.graal.squeak.nodes.SqueakGuards;
import de.hpi.swa.graal.squeak.util.ArrayConversionUtils;

/* Automatically generated by
  SmartSyntaxPluginCodeGenerator * VMMaker.oscog-eem.2480 uuid: bb3ffda7-8241-4dea-b886-d656e474b6c1
   from
  BitBltSimulation * VMMaker.oscog-eem.2480 uuid: bb3ffda7-8241-4dea-b886-d656e474b6c1
 */

public final class BitBlt {
    /* Constants */
    private static final long AllOnes = 0xFFFFFFFFL;
    private static final int AlphaIndex = 3;
    private static final int BBClipHeightIndex = 13;
    private static final int BBClipWidthIndex = 12;
    private static final int BBClipXIndex = 10;
    private static final int BBClipYIndex = 11;
    private static final int BBColorMapIndex = 14;
    private static final int BBDestFormIndex = 0;
    private static final int BBDestXIndex = 4;
    private static final int BBDestYIndex = 5;
    private static final int BBHalftoneFormIndex = 2;
    private static final int BBHeightIndex = 7;
    private static final int BBRuleIndex = 3;
    private static final int BBSourceFormIndex = 1;
    private static final int BBSourceXIndex = 8;
    private static final int BBSourceYIndex = 9;
    private static final int BBWarpBase = 15;
    private static final int BBWidthIndex = 6;
    private static final int BEBitBltIndex = 2;
    private static final int BinaryPoint = 14;
    private static final int BlueIndex = 2;
    private static final int ColorMapFixedPart = 2;
    private static final int ColorMapIndexedPart = 4;
    private static final int ColorMapNewStyle = 8;
    private static final int ColorMapPresent = 1;
    private static final int FixedPt1 = 0x4000;
    private static final int FormBitsIndex = 0;
    private static final int FormDepthIndex = 3;
    private static final int FormHeightIndex = 2;
    private static final int FormWidthIndex = 1;
    private static final int GreenIndex = 1;
    private static final int OpTableSize = 43;
    private static final int PrimErrCallbackError = 20;
    private static final int PrimErrObjectMoved = 18;
    private static final int RedIndex = 0;

    /* Return the default translation table from 1..8 bit indexed colors to 32bit */
    /* The table has been generated by the following statements */
    /*
     * | pvs hex | String streamContents:[:s| s nextPutAll:'static long theTable[256] = { '. pvs :=
     * (Color colorMapIfNeededFrom: 8 to: 32) asArray. 1 to: pvs size do:[:i| i > 1 ifTrue:[s
     * nextPutAll:', ']. (i-1 \\ 8) = 0 ifTrue:[s cr]. s nextPutAll:'0x'. hex := (pvs at: i)
     * printStringBase: 16. s nextPutAll: (hex copyFrom: 4 to: hex size). ]. s nextPutAll:'};'. ].
     */

    /* BitBltSimulation>>#default8To32Table */
    static final long[] default8To32Table = new long[]{
                    0x0, 0xFF000001, 0xFFFFFFFF, 0xFF808080, 0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFF00FFFF,
                    0xFFFFFF00, 0xFFFF00FF, 0xFF202020, 0xFF404040, 0xFF606060, 0xFF9F9F9F, 0xFFBFBFBF, 0xFFDFDFDF,
                    0xFF080808, 0xFF101010, 0xFF181818, 0xFF282828, 0xFF303030, 0xFF383838, 0xFF484848, 0xFF505050,
                    0xFF585858, 0xFF686868, 0xFF707070, 0xFF787878, 0xFF878787, 0xFF8F8F8F, 0xFF979797, 0xFFA7A7A7,
                    0xFFAFAFAF, 0xFFB7B7B7, 0xFFC7C7C7, 0xFFCFCFCF, 0xFFD7D7D7, 0xFFE7E7E7, 0xFFEFEFEF, 0xFFF7F7F7,
                    0xFF000001, 0xFF003300, 0xFF006600, 0xFF009900, 0xFF00CC00, 0xFF00FF00, 0xFF000033, 0xFF003333,
                    0xFF006633, 0xFF009933, 0xFF00CC33, 0xFF00FF33, 0xFF000066, 0xFF003366, 0xFF006666, 0xFF009966,
                    0xFF00CC66, 0xFF00FF66, 0xFF000099, 0xFF003399, 0xFF006699, 0xFF009999, 0xFF00CC99, 0xFF00FF99,
                    0xFF0000CC, 0xFF0033CC, 0xFF0066CC, 0xFF0099CC, 0xFF00CCCC, 0xFF00FFCC, 0xFF0000FF, 0xFF0033FF,
                    0xFF0066FF, 0xFF0099FF, 0xFF00CCFF, 0xFF00FFFF, 0xFF330000, 0xFF333300, 0xFF336600, 0xFF339900,
                    0xFF33CC00, 0xFF33FF00, 0xFF330033, 0xFF333333, 0xFF336633, 0xFF339933, 0xFF33CC33, 0xFF33FF33,
                    0xFF330066, 0xFF333366, 0xFF336666, 0xFF339966, 0xFF33CC66, 0xFF33FF66, 0xFF330099, 0xFF333399,
                    0xFF336699, 0xFF339999, 0xFF33CC99, 0xFF33FF99, 0xFF3300CC, 0xFF3333CC, 0xFF3366CC, 0xFF3399CC,
                    0xFF33CCCC, 0xFF33FFCC, 0xFF3300FF, 0xFF3333FF, 0xFF3366FF, 0xFF3399FF, 0xFF33CCFF, 0xFF33FFFF,
                    0xFF660000, 0xFF663300, 0xFF666600, 0xFF669900, 0xFF66CC00, 0xFF66FF00, 0xFF660033, 0xFF663333,
                    0xFF666633, 0xFF669933, 0xFF66CC33, 0xFF66FF33, 0xFF660066, 0xFF663366, 0xFF666666, 0xFF669966,
                    0xFF66CC66, 0xFF66FF66, 0xFF660099, 0xFF663399, 0xFF666699, 0xFF669999, 0xFF66CC99, 0xFF66FF99,
                    0xFF6600CC, 0xFF6633CC, 0xFF6666CC, 0xFF6699CC, 0xFF66CCCC, 0xFF66FFCC, 0xFF6600FF, 0xFF6633FF,
                    0xFF6666FF, 0xFF6699FF, 0xFF66CCFF, 0xFF66FFFF, 0xFF990000, 0xFF993300, 0xFF996600, 0xFF999900,
                    0xFF99CC00, 0xFF99FF00, 0xFF990033, 0xFF993333, 0xFF996633, 0xFF999933, 0xFF99CC33, 0xFF99FF33,
                    0xFF990066, 0xFF993366, 0xFF996666, 0xFF999966, 0xFF99CC66, 0xFF99FF66, 0xFF990099, 0xFF993399,
                    0xFF996699, 0xFF999999, 0xFF99CC99, 0xFF99FF99, 0xFF9900CC, 0xFF9933CC, 0xFF9966CC, 0xFF9999CC,
                    0xFF99CCCC, 0xFF99FFCC, 0xFF9900FF, 0xFF9933FF, 0xFF9966FF, 0xFF9999FF, 0xFF99CCFF, 0xFF99FFFF,
                    0xFFCC0000, 0xFFCC3300, 0xFFCC6600, 0xFFCC9900, 0xFFCCCC00, 0xFFCCFF00, 0xFFCC0033, 0xFFCC3333,
                    0xFFCC6633, 0xFFCC9933, 0xFFCCCC33, 0xFFCCFF33, 0xFFCC0066, 0xFFCC3366, 0xFFCC6666, 0xFFCC9966,
                    0xFFCCCC66, 0xFFCCFF66, 0xFFCC0099, 0xFFCC3399, 0xFFCC6699, 0xFFCC9999, 0xFFCCCC99, 0xFFCCFF99,
                    0xFFCC00CC, 0xFFCC33CC, 0xFFCC66CC, 0xFFCC99CC, 0xFFCCCCCC, 0xFFCCFFCC, 0xFFCC00FF, 0xFFCC33FF,
                    0xFFCC66FF, 0xFFCC99FF, 0xFFCCCCFF, 0xFFCCFFFF, 0xFFFF0000, 0xFFFF3300, 0xFFFF6600, 0xFFFF9900,
                    0xFFFFCC00, 0xFFFFFF00, 0xFFFF0033, 0xFFFF3333, 0xFFFF6633, 0xFFFF9933, 0xFFFFCC33, 0xFFFFFF33,
                    0xFFFF0066, 0xFFFF3366, 0xFFFF6666, 0xFFFF9966, 0xFFFFCC66, 0xFFFFFF66, 0xFFFF0099, 0xFFFF3399,
                    0xFFFF6699, 0xFFFF9999, 0xFFFFCC99, 0xFFFFFF99, 0xFFFF00CC, 0xFFFF33CC, 0xFFFF66CC, 0xFFFF99CC,
                    0xFFFFCCCC, 0xFFFFFFCC, 0xFFFF00FF, 0xFFFF33FF, 0xFFFF66FF, 0xFFFF99FF, 0xFFFFCCFF, 0xFFFFFFFF};

    /* Variables */
    static long affectedB;
    static long affectedL;
    static long affectedR;
    static long affectedT;
    static int bbH;
    static int bbW;
    static PointersObject bitBltOop;
    static long bitCount;
    static int clipHeight;
    static int clipWidth;
    static int clipX;
    static int clipY;
    static long cmBitsPerColor;
    static long cmFlags;
    static int[] cmLookupTable;
    static long cmMask;
    static int[] cmMaskTable;
    static int[] cmShiftTable;
    static int combinationRule;
    static long componentAlphaModeAlpha;
    static long componentAlphaModeColor;
    static final long destBits = 0; // TODO: C-pointer can be removed, use destWords
    static long destDelta;
    static int destDepth;
    static PointersObject destForm;
    static int destHeight;
    static long destIndex;
    static long destMask;
    static boolean destMSB;
    static int destPitch;
    static int destPPW;
    static int destWidth;
    static int destX;
    static int destY;
    static int[] dither8Lookup = new int[4096];
    static int[] ditherMatrix4x4 = new int[]{
                    0, 8, 2, 10,
                    12, 4, 14, 6,
                    3, 11, 1, 9,
                    15, 7, 13, 5
    };
    static final int[] ditherThresholds16 = new int[]{0, 2, 4, 6, 8, 12, 14, 16};
    static final int[] ditherValues16 = new int[]{
                    0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
                    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30
    };
    static long dstBitShift;
    static int dx;
    static int dy;
    static long endOfDestination;
    static long endOfSource;
    static long[] gammaLookupTable;
    static final long halftoneBase = 0; // TODO: C-pointer can be removed, use halftoneWords
    static AbstractSqueakObject halftoneForm;
    static long halftoneHeight;
    static boolean hasSurfaceLock;
    static long hDir;
    static int height;
    static boolean isWarping;
    static long mask1;
    static long mask2;
    static int[] maskTable = new int[]{
                    0, 1, 3, 0, 15, 31, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 65535,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1
    };
    static final String moduleName = "BitBltPlugin * VMMaker.oscog-eem.2480 (GraalSqueak)";
    static boolean noHalftone;
    static boolean noSource;
    static long numGCsOnInvocation;
    static long nWords;
    static LongBinaryOperator[] opTable = new LongBinaryOperator[43];
    static boolean preload;
    static long skew;
    static long sourceAlpha;
    static final long sourceBits = 0; // TODO: C-pointer can be removed, use sourceWords
    static long sourceDelta;
    static int sourceDepth;
    static PointersObject sourceForm;
    static int sourceHeight;
    static long sourceIndex;
    static boolean sourceMSB;
    static int sourcePitch;
    static int sourcePPW;
    static int sourceWidth;
    static int sourceX;
    static int sourceY;
    static long srcBitShift;
    static int sx;
    static int sy;
    static long[] ungammaLookupTable;
    static long vDir;
    static long warpAlignMask;
    static long warpAlignShift;
    static int[] warpBitShiftTable = new int[32];
    static long warpSrcMask;
    static long warpSrcShift;
    static int width;

    static byte[] destBytes;
    static int[] destWords;
    static int[] halftoneWords;
    static byte[] sourceBytes;
    static int[] sourceWords;

    static {
        initBBOpTable();
    }

    public BitBlt() {
    }

    /* BitBltSimulation>>#addWord:with: */
    static long addWordwith(final long sourceWord, final long destinationWord) {
        return sourceWord + destinationWord;
    }

    /* BitBltSimulation>>#affectedBottom */
    static long affectedBottom() {
        return affectedB;
    }

    /* BitBltSimulation>>#affectedLeft */
    static long affectedLeft() {
        return affectedL;
    }

    /* BitBltSimulation>>#affectedRight */
    static long affectedRight() {
        return affectedR;
    }

    /* BitBltSimulation>>#affectedTop */
    static long affectedTop() {
        return affectedT;
    }

    /* BitBltSimulation>>#alphaBlendConst:with: */
    static long

                    alphaBlendConstwith(final long sourceWord, final long destinationWord) {
        return alphaBlendConstwithpaintMode(sourceWord, destinationWord, false);
    }

/*
 * Blend sourceWord with destinationWord using a constant alpha. Alpha is encoded as 0 meaning 0.0,
 * and 255 meaning 1.0. The blend produced is alpha*source + (1.0-alpha)*dest, with the computation
 * being performed independently on each color component. This function could eventually blend into
 * any depth destination, using the same color averaging and mapping as warpBlt. paintMode = true
 * means do nothing if the source pixel value is zero.
 */
/*
 * This first implementation works with dest depths of 16 and 32 bits only. Normal color mapping
 * will allow sources of lower depths in this case, and results can be mapped directly by
 * truncation, so no extra color maps are needed. To allow storing into any depth will require
 * subsequent addition of two other colormaps, as is the case with WarpBlt.
 */

    /* BitBltSimulation>>#alphaBlendConst:with:paintMode: */
    static long alphaBlendConstwithpaintMode(final long sourceWord, final long destinationWord, final boolean paintMode) {
        final long bitsPerColor;
        long blend;
        long blendAG;
        long blendRB;
        long destPixVal;
        long destShifted;
        long i;
        long j;
        long maskShifted;
        long pixBlend;
        final long pixMask;
        long result;
        final long rgbMask;
        long shift;
        long sourcePixVal;
        long sourceShifted;
        final long unAlpha;

        if (destDepth < 16) {
            return destinationWord;
        }
        unAlpha = 0xFF - sourceAlpha;
        result = destinationWord;
        if (destPPW == 1) {

            /* 32bpp blends include alpha */
            if (!(paintMode && (sourceWord == 0))) {

                /* painting a transparent pixel */

                /* blendRB red and blue */
                blendRB = (((sourceWord & 16711935) * sourceAlpha) + ((destinationWord & 16711935) * unAlpha)) + 16711935;

                /* blendRB alpha and green */
                blendAG = (((((sourceWord) >> 8) & 16711935) * sourceAlpha) + ((((destinationWord) >> 8) & 16711935) * unAlpha)) + 16711935;

                /* divide by 255 */
                blendRB = ((blendRB + (((blendRB - 65537) >> 8) & 16711935)) >> 8) & 16711935;
                blendAG = ((blendAG + (((blendAG - 65537) >> 8) & 16711935)) >> 8) & 16711935;
                result = blendRB | (((blendAG) << 8));
            }
        } else {
            pixMask = maskTable[destDepth];
            bitsPerColor = 5;
            rgbMask = 0x1F;
            maskShifted = destMask;
            destShifted = destinationWord;
            sourceShifted = sourceWord;
            for (j = 1; j <= destPPW; j += 1) {
                sourcePixVal = sourceShifted & pixMask;
                if (!(((maskShifted & pixMask) == 0) || (paintMode && (sourcePixVal == 0)))) {
                    destPixVal = destShifted & pixMask;
                    pixBlend = 0;
                    for (i = 1; i <= 3; i += 1) {
                        shift = (i - 1) * bitsPerColor;
                        blend = (((((((sourcePixVal) >> shift) & rgbMask) * sourceAlpha) + ((((destPixVal) >> shift) & rgbMask) * unAlpha)) + 0xFE) / 0xFF) & rgbMask;
                        pixBlend = pixBlend | (((blend) << shift));
                    }
                    result = (result & (~(((pixMask) << ((j - 1) * 16))))) | (((pixBlend) << ((j - 1) * 16)));
                }
                maskShifted = (maskShifted) >> destDepth;
                sourceShifted = (sourceShifted) >> destDepth;
                destShifted = (destShifted) >> destDepth;
            }
        }
        return result;
    }

/*
 * Blend sourceWord with destinationWord using the alpha value from sourceWord. Alpha is encoded as
 * 0 meaning 0.0, and 255 meaning 1.0. In contrast to alphaBlend:with: the color produced is
 *
 * srcColor + (1-srcAlpha) * dstColor
 *
 * e.g., it is assumed that the source color is already scaled.
 */

    /* BitBltSimulation>>#alphaBlendScaled:with: */
    static long alphaBlendScaledwith(final long sourceWord, final long destinationWord) {
        long ag;
        long rb;
        final long unAlpha;

        /* Do NOT inline this into optimized loops */

        /* High 8 bits of source pixel is source opacity (ARGB format) */
        unAlpha = 0xFF - ((sourceWord) >> 24);

        /* blend red and blue components */
        rb = ((((destinationWord & 16711935) * unAlpha) >> 8) & 16711935) + (sourceWord & 16711935);

        /* blend alpha and green components */
        ag = ((((((destinationWord) >> 8) & 16711935) * unAlpha) >> 8) & 16711935) + (((sourceWord) >> 8) & 16711935);

        /* saturate red and blue components if there is a carry */
        rb = (rb & 16711935) | (((rb & 16777472) * 0xFF) >> 8);

        /* saturate alpha and green components if there is a carry */
        ag = ((((ag & 16711935)) << 8)) | ((ag & 16777472) * 0xFF);
        return ag | rb;
    }

/*
 * Blend sourceWord with destinationWord, assuming both are 32-bit pixels. The source is assumed to
 * have 255*alpha in the high 8 bits of each pixel, while the high 8 bits of the destinationWord
 * will be ignored. The blend produced is alpha*source + (1-alpha)*dest, with the computation being
 * performed independently on each color component. The high byte of the result will be 0.
 */

    /* BitBltSimulation>>#alphaBlend:with: */
    static long alphaBlendwith(final long sourceWord, final long destinationWord) {
        final long alpha;
        long blendAG;
        long blendRB;
        final long result;
        final long unAlpha;

        /* High 8 bits of source pixel */
        alpha = (sourceWord) >> 24;
        if (alpha == 0) {
            return destinationWord;
        }
        if (alpha == 0xFF) {
            return sourceWord;
        }
        unAlpha = 0xFF - alpha;

        /* blend red and blue */
        blendRB = (((sourceWord & 16711935) * alpha) + ((destinationWord & 16711935) * unAlpha)) + 16711935;

        /* blend alpha and green */
        blendAG = ((((((sourceWord) >> 8) | 0xFF0000) & 16711935) * alpha) + ((((destinationWord) >> 8) & 16711935) * unAlpha)) + 16711935;

        /* divide by 255 */
        blendRB = ((blendRB + (((blendRB - 65537) >> 8) & 16711935)) >> 8) & 16711935;
        blendAG = ((blendAG + (((blendAG - 65537) >> 8) & 16711935)) >> 8) & 16711935;
        result = blendRB | (((blendAG) << 8));
        return result;
    }

    /* BitBltSimulation>>#alphaPaintConst:with: */
    static long alphaPaintConstwith(final long sourceWord, final long destinationWord) {
        if (sourceWord == 0) {
            return destinationWord;
        }
        return alphaBlendConstwithpaintMode(sourceWord, destinationWord, true);
    }

/*
 * This version assumes combinationRule = 34 sourcePixSize = 32 destPixSize = 16 sourceForm ~=
 * destForm.
 */

    /* BitBltSimulation>>#alphaSourceBlendBits16 */
    static long alphaSourceBlendBits16() {
        int deltaX;
        int deltaY;
        long destWord;
        int ditherBase;
        int ditherIndex;
        int ditherThreshold;
        long dstIndex;
        long dstMask;
        long dstValue;
        long dstValue1;
        int dstY;
        long sourceWord;
        long srcAlpha;
        long srcIndex;
        int srcShift;
        int srcY;

        /* This particular method should be optimized in itself */

        /* So we can pre-decrement */
        deltaY = bbH + 1;
        srcY = sy;
        dstY = dy;
        srcShift = (dx & 1) * 16;
        if (destMSB) {
            srcShift = 16 - srcShift;
        }

        /* This is the outer loop */
        mask1 = 0xFFFFL << (16 - srcShift);
        while (((deltaY -= 1)) != 0) {
            srcIndex = (sourceBits + (srcY * sourcePitch)) + (sx * 4);
            dstIndex = (destBits + (dstY * destPitch)) + ((dx / 2) * 4);
            ditherBase = (dstY & 3) * 4;

            /* For pre-increment */
            ditherIndex = (sx & 3) - 1;

            /* So we can pre-decrement */
            deltaX = bbW + 1;
            dstMask = mask1;
            if (dstMask == 0xFFFF) {
                srcShift = 16;
            } else {
                srcShift = 0;
            }
            while (((deltaX -= 1)) != 0) {
                ditherThreshold = ditherMatrix4x4[ditherBase + ((ditherIndex = (ditherIndex + 1) & 3))];
                assert (((srcIndex)) < endOfSource);
                sourceWord = srcLongAt(srcIndex);
                srcAlpha = (sourceWord) >> 24;
                if (srcAlpha == 0xFF) {

                    /* Dither from 32 to 16 bit */
                    sourceWord = dither32To16threshold(sourceWord, ditherThreshold);
                    if (sourceWord == 0) {
                        sourceWord = 1L << srcShift;
                    } else {
                        sourceWord = ((sourceWord) << srcShift);
                    }
                    /* begin dstLongAt:put:mask: */
                    assert (((dstIndex)) < endOfDestination);
                    dstValue = dstLongAt(dstIndex);
                    dstValue = dstValue & dstMask;
                    dstValue = dstValue | sourceWord;
                    /* begin dstLongAt:put: */
                    dstLongAtput(dstIndex, dstValue);
                } else {

                    /* srcAlpha ~= 255 */
                    if (!(srcAlpha == 0)) {

                        /* 0 < srcAlpha < 255 */
                        /* If we have to mix colors then just copy a single word */
                        assert (((dstIndex)) < endOfDestination);
                        destWord = dstLongAt(dstIndex);
                        destWord = destWord & (~dstMask);

                        /* Expand from 16 to 32 bit by adding zero bits */
                        destWord = (destWord) >> srcShift;

                        /* Mix colors */
                        destWord = ((((destWord & 0x7C00) << 9)) | (((destWord & 0x3E0) << 6))) | ((((destWord & 0x1F) << 3)) | 0xFF000000L);

                        /* And dither */
                        sourceWord = alphaBlendScaledwith(sourceWord, destWord);
                        sourceWord = dither32To16threshold(sourceWord, ditherThreshold);
                        if (sourceWord == 0) {
                            sourceWord = 1L << srcShift;
                        } else {
                            sourceWord = ((sourceWord) << srcShift);
                        }
                        /* begin dstLongAt:put:mask: */
                        assert (((dstIndex)) < endOfDestination);
                        dstValue1 = dstLongAt(dstIndex);
                        dstValue1 = dstValue1 & dstMask;
                        dstValue1 = dstValue1 | sourceWord;
                        /* begin dstLongAt:put: */
                        dstLongAtput(dstIndex, dstValue1);
                    }
                }
                srcIndex += 4;
                if (destMSB) {
                    if (srcShift == 0) {
                        dstIndex += 4;
                    }
                } else {
                    if (!(srcShift == 0)) {
                        dstIndex += 4;
                    }
                }

                /* Toggle between 0 and 16 */
                srcShift = srcShift ^ 16;
                dstMask = ~dstMask;
            }
            srcY += 1;
            dstY += 1;
        }
        return 0;
    }

/*
 * This version assumes combinationRule = 34 sourcePixSize = destPixSize = 32 sourceForm ~=
 * destForm. Note: The inner loop has been optimized for dealing with the special cases of srcAlpha
 * = 0.0 and srcAlpha = 1.0
 */

    /* BitBltSimulation>>#alphaSourceBlendBits32 */
    static long alphaSourceBlendBits32() {
        int deltaX;
        int deltaY;
        long destWord;
        long dstIndex;
        int dstY;
        long sourceWord;
        long srcAlpha;
        long srcIndex;
        int srcY;

        /* This particular method should be optimized in itself */
        /* Give the compile a couple of hints */
        /*
         * The following should be declared as pointers so the compiler will notice that they're
         * used for accessing memory locations (good to know on an Intel architecture) but then the
         * increments would be different between ST code and C code so must hope the compiler
         * notices what happens (MS Visual C does)
         */

        /* So we can pre-decrement */
        deltaY = bbH + 1;
        srcY = sy;

        /* This is the outer loop */
        dstY = dy;
        while (((deltaY -= 1)) != 0) {
            srcIndex = (sourceBits + (srcY * sourcePitch)) + (sx * 4);
            dstIndex = (destBits + (dstY * destPitch)) + (dx * 4);

            /* So we can pre-decrement */
            /* This is the inner loop */
            deltaX = bbW + 1;
            while (((deltaX -= 1)) != 0) {
                assert (((srcIndex)) < endOfSource);
                sourceWord = srcLongAt(srcIndex);
                srcAlpha = (sourceWord) >> 24;
                if (srcAlpha == 0xFF) {
                    dstLongAtput(dstIndex, sourceWord);
                    srcIndex += 4;

                    /* Now copy as many words as possible with alpha = 255 */
                    dstIndex += 4;
                    while ((((deltaX -= 1)) != 0) && (((((sourceWord = srcLongAt(srcIndex)))) >> 24) == 0xFF)) {
                        dstLongAtput(dstIndex, sourceWord);
                        srcIndex += 4;
                        dstIndex += 4;
                    }
                    deltaX += 1;
                } else {

                    /* srcAlpha ~= 255 */
                    if (srcAlpha == 0) {
                        srcIndex += 4;

                        /* Now skip as many words as possible, */
                        dstIndex += 4;
                        while ((((deltaX -= 1)) != 0) && ((((((sourceWord = srcLongAt(srcIndex))))) >> 24) == 0)) {
                            srcIndex += 4;
                            dstIndex += 4;
                        }
                        deltaX += 1;
                    } else {

                        /* 0 < srcAlpha < 255 */
                        /* If we have to mix colors then just copy a single word */
                        assert (((dstIndex)) < endOfDestination);
                        destWord = dstLongAt(dstIndex);
                        destWord = alphaBlendScaledwith(sourceWord, destWord);
                        dstLongAtput(dstIndex, destWord);
                        srcIndex += 4;
                        dstIndex += 4;
                    }
                }
            }
            srcY += 1;
            dstY += 1;
        }
        return 0;
    }

/*
 * This version assumes combinationRule = 34 sourcePixSize = 32 destPixSize = 8 sourceForm ~=
 * destForm. Note: This is not real blending since we don't have the source colors available.
 */

    /* BitBltSimulation>>#alphaSourceBlendBits8 */
    static long alphaSourceBlendBits8() {
        long adjust;
        int deltaX;
        int deltaY;
        long destWord;
        long dstIndex;
        long dstMask;
        long dstValue;
        int dstY;
        final long mapperFlags;
        final long[] mappingTable;
        long sourceWord;
        long srcAlpha;
        long srcIndex;
        long srcShift;
        int srcY;

        mappingTable = default8To32Table;
        mapperFlags = cmFlags & (~ColorMapNewStyle);

        /* So we can pre-decrement */
        deltaY = bbH + 1;
        srcY = sy;
        dstY = dy;
        mask1 = (dx & 3) * 8;
        if (destMSB) {
            mask1 = 24 - mask1;
        }
        mask2 = AllOnes ^ (0xFFL << mask1);
        if ((dx & 1) == 0) {
            adjust = 0;
        } else {
            adjust = 522133279;
        }
        if ((dy & 1) == 0) {
            adjust = adjust ^ 522133279;
        }
        while (((deltaY -= 1)) != 0) {
            adjust = adjust ^ 522133279;
            srcIndex = (sourceBits + (srcY * sourcePitch)) + (sx * 4);
            dstIndex = (destBits + (dstY * destPitch)) + ((dx / 4) * 4);

            /* So we can pre-decrement */
            deltaX = bbW + 1;
            srcShift = mask1;

            /* This is the inner loop */
            dstMask = mask2;
            while (((deltaX -= 1)) != 0) {
                sourceWord = (srcLongAt(srcIndex) & (~adjust)) + adjust;
                srcAlpha = (sourceWord) >> 24;
                if (srcAlpha > 0x1F) {

                    /* Everything below 31 is transparent */
                    if (srcAlpha < 224) {

                        /* Everything above 224 is opaque */
                        assert (((dstIndex)) < endOfDestination);
                        destWord = dstLongAt(dstIndex);
                        destWord = destWord & (~dstMask);
                        destWord = (destWord) >> srcShift;
                        destWord = mappingTable[(int) destWord];
                        sourceWord = alphaBlendScaledwith(sourceWord, destWord);
                    }
                    sourceWord = mapPixelflags(sourceWord, mapperFlags);

                    /* Store back */
                    sourceWord = ((sourceWord) << srcShift);
                    /* begin dstLongAt:put:mask: */
                    assert (((dstIndex)) < endOfDestination);
                    dstValue = dstLongAt(dstIndex);
                    dstValue = dstValue & dstMask;
                    dstValue = dstValue | sourceWord;
                    /* begin dstLongAt:put: */
                    dstLongAtput(dstIndex, dstValue);
                }
                srcIndex += 4;
                if (destMSB) {
                    if (srcShift == 0) {
                        dstIndex += 4;
                        srcShift = 24;
                        dstMask = 0xFFFFFF;
                    } else {
                        srcShift -= 8;
                        dstMask = ((dstMask) >> 8) | 0xFF000000L;
                    }
                } else {
                    if (srcShift == 24) {
                        dstIndex += 4;
                        srcShift = 0;
                        dstMask = 0xFFFFFF00L;
                    } else {
                        srcShift += 8;
                        dstMask = (((dstMask) << 8)) | 0xFF;
                    }
                }
                adjust = adjust ^ 522133279;
            }
            srcY += 1;
            dstY += 1;
        }
        return 0;
    }

    /* BitBltSimulation>>#bitAndInvert:with: */
    static long bitAndInvertwith(final long sourceWord, final long destinationWord) {
        return sourceWord & (~destinationWord);
    }

    /* BitBltSimulation>>#bitAnd:with: */
    static long bitAndwith(final long sourceWord, final long destinationWord) {
        return sourceWord & destinationWord;
    }

    /* BitBltSimulation>>#bitInvertAndInvert:with: */
    static long bitInvertAndInvertwith(final long sourceWord, final long destinationWord) {
        return (~sourceWord) & (~destinationWord);
    }

    /* BitBltSimulation>>#bitInvertAnd:with: */
    static long bitInvertAndwith(final long sourceWord, final long destinationWord) {
        return (~sourceWord) & destinationWord;
    }

    /* BitBltSimulation>>#bitInvertDestination:with: */
    static long bitInvertDestinationwith(final long sourceWord, final long destinationWord) {
        return ~destinationWord;
    }

    /* BitBltSimulation>>#bitInvertOrInvert:with: */
    static long bitInvertOrInvertwith(final long sourceWord, final long destinationWord) {
        return (~sourceWord) | (~destinationWord);
    }

    /* BitBltSimulation>>#bitInvertOr:with: */
    static long bitInvertOrwith(final long sourceWord, final long destinationWord) {
        return (~sourceWord) | destinationWord;
    }

    /* BitBltSimulation>>#bitInvertSource:with: */
    static long bitInvertSourcewith(final long sourceWord, final long destinationWord) {
        return ~sourceWord;
    }

    /* BitBltSimulation>>#bitInvertXor:with: */
    static long bitInvertXorwith(final long sourceWord, final long destinationWord) {
        return (~sourceWord) ^ destinationWord;
    }

    /* BitBltSimulation>>#bitOrInvert:with: */
    static long bitOrInvertwith(final long sourceWord, final long destinationWord) {
        return sourceWord | (~destinationWord);
    }

    /* BitBltSimulation>>#bitOr:with: */
    static long bitOrwith(final long sourceWord, final long destinationWord) {
        return sourceWord | destinationWord;
    }

    /* BitBltSimulation>>#bitXor:with: */
    static long bitXorwith(final long sourceWord, final long destinationWord) {
        return sourceWord ^ destinationWord;
    }

/* check for possible overlap of source and destination */
/* ar 10/19/1999: This method requires surfaces to be locked. */

    /* BitBltSimulation>>#checkSourceOverlap */
    static long checkSourceOverlap() {
        final long t;

        if ((sourceForm == destForm) && (dy >= sy)) {
            if (dy > sy) {

                /* have to start at bottom */
                vDir = -1;
                sy = (sy + bbH) - 1;
                dy = (dy + bbH) - 1;
            } else {
                if ((dy == sy) && (dx > sx)) {

                    /* y's are equal, but x's are backward */
                    hDir = -1;

                    /* start at right */
                    sx = (sx + bbW) - 1;

                    /* and fix up masks */
                    dx = (dx + bbW) - 1;
                    if (nWords > 1) {
                        t = mask1;
                        mask1 = mask2;
                        mask2 = t;
                    }
                }
            }
            destIndex = (destBits + (dy * destPitch)) + ((dx / destPPW) * 4);
            destDelta = (destPitch * vDir) - (4 * (nWords * hDir));
        }
        return 0;
    }

    /* BitBltSimulation>>#clearWord:with: */
    static long

                    clearWordwith(final long sourceWord, final long destinationWord) {
        return 0;
    }

/* clip and adjust source origin and extent appropriately */
/* first in x */

    /* BitBltSimulation>>#clipRange */
    static void clipRange() {
        if (destX >= clipX) {
            sx = sourceX;
            dx = destX;
            bbW = width;
        } else {
            sx = sourceX + (clipX - destX);
            bbW = width - (clipX - destX);
            dx = clipX;
        }
        if ((dx + bbW) > (clipX + clipWidth)) {
            bbW -= (dx + bbW) - (clipX + clipWidth);
        }
        if (destY >= clipY) {
            sy = sourceY;
            dy = destY;
            bbH = height;
        } else {
            sy = (sourceY + clipY) - destY;
            bbH = height - (clipY - destY);
            dy = clipY;
        }
        if ((dy + bbH) > (clipY + clipHeight)) {
            bbH -= (dy + bbH) - (clipY + clipHeight);
        }
        if (noSource) {
            return;
        }
        if (sx < 0) {
            dx -= sx;
            bbW += sx;
            sx = 0;
        }
        if ((sx + bbW) > sourceWidth) {
            bbW -= (sx + bbW) - sourceWidth;
        }
        if (sy < 0) {
            dy -= sy;
            bbH += sy;
            sy = 0;
        }
        if ((sy + bbH) > sourceHeight) {
            bbH -= (sy + bbH) - sourceHeight;
        }
    }

/* This function is exported for the Balloon engine */

    /* BitBltSimulation>>#copyBits */
    public static void copyBits() {
        clipRange();
        if ((bbW <= 0) || (bbH <= 0)) {
            /* zero width or height; noop */
            affectedL = (affectedR = (affectedT = (affectedB = 0)));
            return;
        }
        if (!(lockSurfaces())) {
            throw new PrimitiveFailed();
        }

        copyBitsLockedAndClipped();
        unlockSurfaces();
    }

/* Support for the balloon engine. */

    /* BitBltSimulation>>#copyBitsFrom:to:at: */
    public static void copyBitsFromtoat(final int startX, final int stopX, final int yValue) {
        destX = startX;
        destY = yValue;
        sourceX = startX;
        width = stopX - startX;
        copyBits();
        /* begin showDisplayBits */
        if (numGCsOnInvocation != (statNumGCs())) {
            reloadDestAndSourceForms();
        }
        showDisplayBitsLeftTopRightBottom(destForm, affectedL, affectedT, affectedR, affectedB);
    }

/*
 * Perform the actual copyBits operation. Assume: Surfaces have been locked and clipping was
 * performed.
 */

    /* BitBltSimulation>>#copyBitsLockedAndClipped */
    static void copyBitsLockedAndClipped() {
        copyBitsRule41Test();
        if (failed()) {
            throw new PrimitiveFailed();
        }
        if (tryCopyingBitsQuickly()) {
            return;
        }
        if (((combinationRule >= 30) && (combinationRule <= 0x1F))) {
            throw new SqueakException("Not implemented");
            // TODO: uncomment:
            // /* Check and fetch source alpha parameter for alpha blend */
            // if (!((methodArgumentCount()) == 1)) {
            // throw new PrimitiveFailed();
            // }
            // sourceAlpha = stackIntegerValue(0);
            // if ((failed()) || ((sourceAlpha < 0) || (sourceAlpha > 0xFF))) {
            // throw new PrimitiveFailed();
            // }
        }

        /* Choose and perform the actual copy loop. */
        bitCount = 0;
        performCopyLoop();
        if (((combinationRule >= 30) && (combinationRule <= 0x1F))) {

            /* zero width and height; just return the count */
            affectedL = (affectedR = (affectedT = (affectedB = 0)));
        } else {
            if (hDir > 0) {
                affectedL = dx;
                affectedR = dx + bbW;
            } else {
                affectedL = (dx - bbW) + 1;
                affectedR = dx + 1;
            }
            if (vDir > 0) {
                affectedT = dy;
                affectedB = dy + bbH;
            } else {
                affectedT = (dy - bbH) + 1;
                affectedB = dy + 1;
            }
        }
    }

/*
 * Test possible use of rule 41, rgbComponentAlpha:with: Nothing to return, just set up some
 * variables
 */

    /* BitBltSimulation>>#copyBitsRule41Test */
    static long copyBitsRule41Test() {
        final long gammaLookupTableOop;
        final long ungammaLookupTableOop;

        if (combinationRule == 41) {

            // TODO: uncomment:
            // /* fetch the forecolor into componentAlphaModeColor. */
            // componentAlphaModeAlpha = 0xFF;
            // componentAlphaModeColor = 0xFFFFFF;
            // gammaLookupTable = null;
            // ungammaLookupTable = null;
            // if ((methodArgumentCount()) >= 2) {
            // componentAlphaModeAlpha = stackIntegerValue((methodArgumentCount()) - 2);
            // if (failed()) {
            // throw new PrimitiveFailed();
            // }
            // componentAlphaModeColor = stackIntegerValue((methodArgumentCount()) - 1);
            // if (failed()) {
            // throw new PrimitiveFailed();
            // }
            // if ((methodArgumentCount()) == 4) {
            // gammaLookupTableOop = stackObjectValue(1);
            // if (isBytes(gammaLookupTableOop)) {
            // gammaLookupTable = firstIndexableField(gammaLookupTableOop);
            // }
            // ungammaLookupTableOop = stackObjectValue(0);
            // if (isBytes(ungammaLookupTableOop)) {
            // ungammaLookupTable = firstIndexableField(ungammaLookupTableOop);
            // }
            // }
            // } else {
            // if ((methodArgumentCount()) == 1) {
            // componentAlphaModeColor = stackIntegerValue(0);
            // if (failed()) {
            // throw new PrimitiveFailed();
            // }
            // } else {
            // throw new PrimitiveFailed();
            // }
            // }
        }
        return 0;
    }

/* This version of the inner loop assumes noSource = false. */

    /* BitBltSimulation>>#copyLoop */
    static long copyLoop() {
        long destWord;
        long halftoneWord;
        final long hInc;
        long i;
        long mergeWord;
        final long notSkewMask;
        long prevWord;
        final long skewMask;
        long skewWord;
        long thisWord;
        final long unskew;
        long word;
        int y;

        /* unskew is a bitShift and MUST remain signed, while skewMask is unsigned. */
        final LongBinaryOperator mergeFnwith = opTable[combinationRule + 1];
        assert mergeFnwith != null;
        assert (!((preload && (skew == 0))));
        assert (((skew >= -31) && (skew <= 0x1F)));

        /* Byte delta */
        hInc = hDir * 4;
        if (skew < 0) {
            unskew = skew + 32;
            skewMask = ((AllOnes) << (0 - skew));
        } else {
            if (skew == 0) {
                unskew = 0;
                skewMask = AllOnes;
            } else {
                unskew = skew - 32;
                skewMask = (AllOnes) >> skew;
            }
        }
        notSkewMask = ~skewMask;
        if (noHalftone) {
            halftoneWord = AllOnes;
            halftoneHeight = 0;
        } else {
            halftoneWord = halftoneLongAt(halftoneBase + ((0 % halftoneHeight) * 4));
        }

        /*
         * Here is the vertical loop, in two versions, one for the combinationRule = 3 copy mode,
         * one for the general case.
         */
        y = dy;
        if (combinationRule == 3) {
            for (i = 1; i <= bbH; i += 1) {

                /*
                 * here is the vertical loop for combinationRule = 3 copy mode; no need to call
                 * merge
                 */
                if (halftoneHeight > 1) {

                    /* Otherwise, its always the same */
                    halftoneWord = halftoneLongAt(halftoneBase + ((y % halftoneHeight) * 4));
                    y += vDir;
                }
                if (preload) {

                    /* load the 64-bit shifter */
                    assert (((sourceIndex)) < endOfSource);
                    prevWord = srcLongAt(sourceIndex);
                    sourceIndex += hInc;
                } else {
                    prevWord = 0;
                }
                destMask = mask1;

                /* pick up next word */
                assert (((sourceIndex)) < endOfSource);
                thisWord = srcLongAt(sourceIndex);
                sourceIndex += hInc;

                /* 32-bit rotate */
                skewWord = (((unskew < 0) ? ((prevWord & notSkewMask) >> -unskew) : ((prevWord & notSkewMask) << unskew))) |
                                (((skew < 0) ? ((thisWord & skewMask) >> -skew) : ((thisWord & skewMask) << skew)));
                prevWord = thisWord;
                assert (((destIndex)) < endOfDestination);
                destWord = dstLongAt(destIndex);
                destWord = (destMask & (skewWord & halftoneWord)) | (destWord & (~destMask));
                dstLongAtput(destIndex, destWord);
                destIndex += hInc;
                destMask = AllOnes;
                if ((skew == 0) && (halftoneWord == AllOnes)) {

                    /* Very special inner loop for STORE mode with no skew -- just move words */
                    if (preload && (hDir == 1)) {
                        for (word = 2; word < nWords; word += 1) {

                            /* Note loop starts with prevWord loaded (due to preload) */
                            dstLongAtput(destIndex, prevWord);
                            destIndex += hInc;
                            assert (((sourceIndex)) < endOfSource);
                            prevWord = srcLongAt(sourceIndex);
                            sourceIndex += hInc;
                        }
                    } else {
                        for (word = 2; word < nWords; word += 1) {
                            assert (((sourceIndex)) < endOfSource);
                            thisWord = srcLongAt(sourceIndex);
                            sourceIndex += hInc;
                            dstLongAtput(destIndex, thisWord);
                            destIndex += hInc;
                        }
                        prevWord = thisWord;
                    }
                } else {
                    for (word = 2; word < nWords; word += 1) {
                        assert (((sourceIndex)) < endOfSource);
                        thisWord = srcLongAt(sourceIndex);
                        sourceIndex += hInc;

                        /* 32-bit rotate */
                        skewWord = (((unskew < 0) ? ((prevWord & notSkewMask) >> -unskew) : ((prevWord & notSkewMask) << unskew))) |
                                        (((skew < 0) ? ((thisWord & skewMask) >> -skew) : ((thisWord & skewMask) << skew)));
                        prevWord = thisWord;
                        dstLongAtput(destIndex, skewWord & halftoneWord);
                        destIndex += hInc;
                    }
                }
                if (nWords > 1) {
                    destMask = mask2;

                    /* pick up next word */
                    assert (((sourceIndex)) < endOfSource);
                    thisWord = srcLongAt(sourceIndex);
                    sourceIndex += hInc;

                    /* 32-bit rotate */
                    skewWord = (((unskew < 0) ? ((prevWord & notSkewMask) >> -unskew) : ((prevWord & notSkewMask) << unskew))) |
                                    (((skew < 0) ? ((thisWord & skewMask) >> -skew) : ((thisWord & skewMask) << skew)));
                    assert (((destIndex)) < endOfDestination);
                    destWord = dstLongAt(destIndex);
                    destWord = (destMask & (skewWord & halftoneWord)) | (destWord & (~destMask));
                    dstLongAtput(destIndex, destWord);
                    destIndex += hInc;
                }
                sourceIndex += sourceDelta;
                destIndex += destDelta;
            }
        } else {
            for (i = 1; i <= bbH; i += 1) {

                /* here is the vertical loop for the general case (combinationRule ~= 3) */
                if (halftoneHeight > 1) {

                    /* Otherwise, its always the same */
                    halftoneWord = halftoneLongAt(halftoneBase + ((y % halftoneHeight) * 4));
                    y += vDir;
                }
                if (preload) {

                    /* load the 64-bit shifter */
                    assert (((sourceIndex)) < endOfSource);
                    prevWord = srcLongAt(sourceIndex);
                    sourceIndex += hInc;
                } else {
                    prevWord = 0;
                }
                destMask = mask1;

                /* pick up next word */
                assert (((sourceIndex)) < endOfSource);
                thisWord = srcLongAt(sourceIndex);
                sourceIndex += hInc;

                /* 32-bit rotate */
                skewWord = (((unskew < 0) ? ((prevWord & notSkewMask) >> -unskew) : ((prevWord & notSkewMask) << unskew))) |
                                (((skew < 0) ? ((thisWord & skewMask) >> -skew) : ((thisWord & skewMask) << skew)));
                prevWord = thisWord;
                assert (((destIndex)) < endOfDestination);
                destWord = dstLongAt(destIndex);
                mergeWord = mergeFnwith.applyAsLong(skewWord & halftoneWord, destWord);
                destWord = (destMask & mergeWord) | (destWord & (~destMask));
                dstLongAtput(destIndex, destWord);
                destIndex += hInc;
                destMask = AllOnes;
                for (word = 2; word < nWords; word += 1) {

                    /* Normal inner loop does merge: */

                    /* pick up next word */
                    assert (((sourceIndex)) < endOfSource);
                    thisWord = srcLongAt(sourceIndex);
                    sourceIndex += hInc;

                    /* 32-bit rotate */
                    skewWord = (((unskew < 0) ? ((prevWord & notSkewMask) >> -unskew) : ((prevWord & notSkewMask) << unskew))) |
                                    (((skew < 0) ? ((thisWord & skewMask) >> -skew) : ((thisWord & skewMask) << skew)));
                    prevWord = thisWord;
                    mergeWord = mergeFnwith.applyAsLong(skewWord & halftoneWord, dstLongAt(destIndex));
                    dstLongAtput(destIndex, mergeWord);
                    destIndex += hInc;
                }
                if (nWords > 1) {
                    destMask = mask2;

                    /* pick up next word */
                    assert (((sourceIndex)) < endOfSource);
                    thisWord = srcLongAt(sourceIndex);
                    sourceIndex += hInc;

                    /* 32-bit rotate */
                    skewWord = (((unskew < 0) ? ((prevWord & notSkewMask) >> -unskew) : ((prevWord & notSkewMask) << unskew))) |
                                    (((skew < 0) ? ((thisWord & skewMask) >> -skew) : ((thisWord & skewMask) << skew)));
                    assert (((destIndex)) < endOfDestination);
                    destWord = dstLongAt(destIndex);
                    mergeWord = mergeFnwith.applyAsLong(skewWord & halftoneWord, destWord);
                    destWord = (destMask & mergeWord) | (destWord & (~destMask));
                    dstLongAtput(destIndex, destWord);
                    destIndex += hInc;
                }
                sourceIndex += sourceDelta;
                destIndex += destDelta;
            }
        }
        return 0;
    }

/*
 * Faster copyLoop when source not used. hDir and vDir are both positive, and perload and skew are
 * unused
 */

    /* BitBltSimulation>>#copyLoopNoSource */
    static void copyLoopNoSource() {
        long destWord;
        long halftoneWord;
        long i;
        long mergeWord;
        long word;

        halftoneWord = 0;
        final LongBinaryOperator mergeFnwith = opTable[combinationRule + 1];
        assert mergeFnwith != null;
        if (noHalftone) {
            halftoneWord = AllOnes;
        }
        for (i = 1; i <= bbH; i += 1) {
            /* here is the vertical loop */
            if (!noHalftone) {
                halftoneWord = halftoneLongAt(halftoneBase + ((((dy + i) - 1) % halftoneHeight) * 4));
            }
            destMask = mask1;
            assert (((destIndex)) < endOfDestination);
            destWord = dstLongAt(destIndex);
            mergeWord = mergeFnwith.applyAsLong(halftoneWord, destWord);
            destWord = (destMask & mergeWord) | (destWord & (~destMask));
            dstLongAtput(destIndex, destWord);
            destIndex += 4;
            destMask = AllOnes;
            if (combinationRule == 3) {
                /* Special inner loop for STORE */
                destWord = halftoneWord;
                for (word = 2; word < nWords; word += 1) {
                    dstLongAtput(destIndex, destWord);
                    destIndex += 4;
                }
            } else {
                /* Normal inner loop does merge */
                for (word = 2; word < nWords; word += 1) {
                    /* Normal inner loop does merge */
                    assert (((destIndex)) < endOfDestination);
                    destWord = dstLongAt(destIndex);
                    mergeWord = mergeFnwith.applyAsLong(halftoneWord, destWord);
                    dstLongAtput(destIndex, mergeWord);
                    destIndex += 4;
                }
            }
            if (nWords > 1) {
                destMask = mask2;
                assert (((destIndex)) < endOfDestination);
                destWord = dstLongAt(destIndex);
                mergeWord = mergeFnwith.applyAsLong(halftoneWord, destWord);
                destWord = (destMask & mergeWord) | (destWord & (~destMask));
                dstLongAtput(destIndex, destWord);
                destIndex += 4;
            }
            destIndex += destDelta;
        }
    }

/*
 * This version of the inner loop maps source pixels to a destination form with different depth.
 * Because it is already unweildy, the loop is not unrolled as in the other versions. Preload, skew
 * and skewMask are all overlooked, since pickSourcePixels delivers its destination word already
 * properly aligned. Note that pickSourcePixels could be copied in-line at the top of the horizontal
 * loop, and some of its inits moved out of the loop.
 */
/*
 * ar 12/7/1999: The loop has been rewritten to use only one pickSourcePixels call. The idea is that
 * the call itself could be inlined. If we decide not to inline pickSourcePixels we could optimize
 * the loop instead.
 */

    /* BitBltSimulation>>#copyLoopPixMap */
    static long copyLoopPixMap() {
        final long destPixMask;
        long destWord;
        long dstShift;
        int dstShiftInc;
        long dstShiftLeft;
        final long endBits;
        long halftoneWord;
        long i;
        final long mapperFlags;
        long mergeWord;
        long nPix;
        final long nSourceIncs;
        final long scrStartBits;
        long skewWord;
        final long sourcePixMask;
        long srcShift;
        int srcShiftInc;
        long startBits;
        long words;

        halftoneWord = 0;
        final LongBinaryOperator mergeFnwith = opTable[combinationRule + 1];
        assert mergeFnwith != null;
        sourcePPW = 32 / sourceDepth;
        sourcePixMask = maskTable[sourceDepth];
        destPixMask = maskTable[destDepth];
        mapperFlags = cmFlags & (~ColorMapNewStyle);
        sourceIndex = (sourceBits + (sy * sourcePitch)) + ((sx / sourcePPW) * 4);
        scrStartBits = sourcePPW - (sx & (sourcePPW - 1));
        if (bbW < scrStartBits) {
            nSourceIncs = 0;
        } else {
            nSourceIncs = ((bbW - scrStartBits) / sourcePPW) + 1;
        }

        /* Note following two items were already calculated in destmask setup! */
        sourceDelta = sourcePitch - (nSourceIncs * 4);
        startBits = destPPW - (dx & (destPPW - 1));
        endBits = (((dx + bbW) - 1) & (destPPW - 1)) + 1;
        if (bbW < startBits) {
            startBits = bbW;
        }
        srcShift = (sx & (sourcePPW - 1)) * sourceDepth;
        dstShift = (dx & (destPPW - 1)) * destDepth;
        srcShiftInc = sourceDepth;
        dstShiftInc = destDepth;
        dstShiftLeft = 0;
        if (sourceMSB) {
            srcShift = (32 - sourceDepth) - srcShift;
            srcShiftInc = 0 - srcShiftInc;
        }
        if (destMSB) {
            dstShift = (32 - destDepth) - dstShift;
            dstShiftInc = 0 - dstShiftInc;
            dstShiftLeft = 32 - destDepth;
        }
        if (noHalftone) {
            halftoneWord = AllOnes;
        }
        for (i = 1; i <= bbH; i += 1) {

            /* here is the vertical loop */
            if (!noHalftone) {
                halftoneWord = halftoneLongAt(halftoneBase + ((((dy + i) - 1) % halftoneHeight) * 4));
            }
            srcBitShift = srcShift;
            dstBitShift = dstShift;
            destMask = mask1;

            /* Here is the horizontal loop... */
            nPix = startBits;
            words = nWords;
            do {

                /* align next word to leftmost pixel */
                skewWord = pickSourcePixelsflagssrcMaskdestMasksrcShiftIncdstShiftInc(nPix, mapperFlags, sourcePixMask, destPixMask, srcShiftInc, dstShiftInc);
                dstBitShift = dstShiftLeft;
                if (destMask == AllOnes) {

                    /* avoid read-modify-write */
                    mergeWord = mergeFnwith.applyAsLong(skewWord & halftoneWord, dstLongAt(destIndex));
                    dstLongAtput(destIndex, destMask & mergeWord);
                } else {

                    /* General version using dest masking */
                    assert (((destIndex)) < endOfDestination);
                    destWord = dstLongAt(destIndex);
                    mergeWord = mergeFnwith.applyAsLong(skewWord & halftoneWord, destWord & destMask);
                    destWord = (destMask & mergeWord) | (destWord & (~destMask));
                    dstLongAtput(destIndex, destWord);
                }
                destIndex += 4;
                if (words == 2) {

                    /* e.g., is the next word the last word? */
                    /* set mask for last word in this row */
                    destMask = mask2;
                    nPix = endBits;
                } else {

                    /* use fullword mask for inner loop */
                    destMask = AllOnes;
                    nPix = destPPW;
                }
            } while (!(((words -= 1)) == 0));
            sourceIndex += sourceDelta;
            destIndex += destDelta;
        }
        return 0;
    }

/* Utility routine for computing Warp increments. */

    /* BitBltSimulation>>#deltaFrom:to:nSteps: */
    static long deltaFromtonSteps(final long x1, final long x2, final long n) {
        if (x2 > x1) {
            return (((x2 - x1) + FixedPt1) / (n + 1)) + 1;
        } else {
            if (x2 == x1) {
                return 0;
            }
            return 0 - ((((x1 - x2) + FixedPt1) / (n + 1)) + 1);
        }
    }

    /* BitBltSimulation>>#destinationWord:with: */
    static long destinationWordwith(final long sourceWord, final long destinationWord) {
        return destinationWord;
    }

/* Compute masks for left and right destination words */

    /* BitBltSimulation>>#destMaskAndPointerInit */
    static long destMaskAndPointerInit() {
        final long endBits;
        final long pixPerM1;
        final long startBits;

        /* A mask, assuming power of two */
        /* how many pixels in first word */
        pixPerM1 = destPPW - 1;

        /* how many pixels in last word */
        startBits = destPPW - (dx & pixPerM1);
        endBits = (((dx + bbW) - 1) & pixPerM1) + 1;
        if (destMSB) {
            mask1 = (AllOnes) >> (32 - (startBits * destDepth));
            mask2 = ((AllOnes) << (32 - (endBits * destDepth)));
        } else {
            mask1 = ((AllOnes) << (32 - (startBits * destDepth)));
            mask2 = (AllOnes) >> (32 - (endBits * destDepth));
        }
        if (bbW < startBits) {
            mask1 = mask1 & mask2;
            mask2 = 0;
            nWords = 1;
        } else {
            nWords = (((bbW - startBits) + pixPerM1) / destPPW) + 1;
        }

        /* defaults for no overlap with source */
        /* calculate byte addr and delta, based on first word of data */
        /* Note pitch is bytes and nWords is longs, not bytes */
        hDir = (vDir = 1);
        destIndex = (destBits + (dy * destPitch)) + ((dx / destPPW) * 4);

        /* byte addr delta */
        destDelta = (destPitch * vDir) - (4 * (nWords * hDir));
        return 0;
    }

/* Dither the given 32bit word to 16 bit. Ignore alpha. */

    /* BitBltSimulation>>#dither32To16:threshold: */
    static long dither32To16threshold(final long srcWord, final long ditherValue) {
        final long addThreshold;

        /* You bet */
        addThreshold = (ditherValue << 8);
        return ((((long) (dither8Lookup[(int) (addThreshold + (((srcWord >> 16)) & 0xFF))]) << 10)) +
                        (((long) (dither8Lookup[(int) (addThreshold + (((srcWord >> 8)) & 0xFF))]) << 5))) +
                        (dither8Lookup[(int) (addThreshold + (srcWord & 0xFF))]);
    }

/*
 * This is the primitive implementation of the line-drawing loop. See the comments in
 * BitBlt>>drawLoopX:Y:
 */

    /* BitBltSimulation>>#drawLoopX:Y: */
    void drawLoopXY(final long xDelta, final long yDelta) {
        long affB;
        long affL;
        long affR;
        long affT;
        final long dx1;
        final long dy1;
        long i;
        long p;
        final long px;
        final long py;

        if (xDelta > 0) {
            dx1 = 1;
        } else {
            if (xDelta == 0) {
                dx1 = 0;
            } else {
                dx1 = -1;
            }
        }
        if (yDelta > 0) {
            dy1 = 1;
        } else {
            if (yDelta == 0) {
                dy1 = 0;
            } else {
                dy1 = -1;
            }
        }
        px = Math.abs(yDelta);
        py = Math.abs(xDelta);

        /* init null rectangle */
        affL = (affT = 9999);
        affR = (affB = -9999);
        if (py > px) {

            /* more horizontal */
            p = py / 2;
            for (i = 1; i <= py; i += 1) {
                destX += dx1;
                if (((p -= px)) < 0) {
                    destY += dy1;
                    p += py;
                }
                if (i < py) {
                    copyBits();
                    if (failed()) {
                        return;
                    }
                    if ((affectedL < affectedR) && (affectedT < affectedB)) {

                        /* Affected rectangle grows along the line */
                        affL = ((affL < affectedL) ? affL : affectedL);
                        affR = ((affR < affectedR) ? affectedR : affR);
                        affT = ((affT < affectedT) ? affT : affectedT);
                        affB = ((affB < affectedB) ? affectedB : affB);
                        if (((affR - affL) * (affB - affT)) > 4000) {

                            /* If affected rectangle gets large, update it in chunks */
                            affectedL = affL;
                            affectedR = affR;
                            affectedT = affT;
                            affectedB = affB;
                            /* begin showDisplayBits */
                            if (numGCsOnInvocation != (statNumGCs())) {
                                reloadDestAndSourceForms();
                            }
                            showDisplayBitsLeftTopRightBottom(destForm, affectedL, affectedT, affectedR, affectedB);

                            /* init null rectangle */
                            affL = (affT = 9999);
                            affR = (affB = -9999);
                        }
                    }
                }
            }
        } else {

            /* more vertical */
            p = px / 2;
            for (i = 1; i <= px; i += 1) {
                destY += dy1;
                if (((p -= py)) < 0) {
                    destX += dx1;
                    p += px;
                }
                if (i < px) {
                    copyBits();
                    if (failed()) {
                        return;
                    }
                    if ((affectedL < affectedR) && (affectedT < affectedB)) {

                        /* Affected rectangle grows along the line */
                        affL = ((affL < affectedL) ? affL : affectedL);
                        affR = ((affR < affectedR) ? affectedR : affR);
                        affT = ((affT < affectedT) ? affT : affectedT);
                        affB = ((affB < affectedB) ? affectedB : affB);
                        if (((affR - affL) * (affB - affT)) > 4000) {

                            /* If affected rectangle gets large, update it in chunks */
                            affectedL = affL;
                            affectedR = affR;
                            affectedT = affT;
                            affectedB = affB;
                            /* begin showDisplayBits */
                            if (numGCsOnInvocation != (statNumGCs())) {
                                reloadDestAndSourceForms();
                            }
                            showDisplayBitsLeftTopRightBottom(destForm, affectedL, affectedT, affectedR, affectedB);

                            /* init null rectangle */
                            affL = (affT = 9999);
                            affR = (affB = -9999);
                        }
                    }
                }
            }
        }
        affectedL = affL;
        affectedR = affR;
        affectedT = affT;

        /* store destX, Y back */
        affectedB = affB;
        storeIntegerofObjectwithValue(BBDestXIndex, bitBltOop, destX);
        storeIntegerofObjectwithValue(BBDestYIndex, bitBltOop, destY);
    }

/* Dither the given 32bit word to 16 bit. Ignore alpha. */

    /* BitBltSimulation>>#expensiveDither32To16:threshold: */
    static long expensiveDither32To16threshold(final long srcWord, final long ditherValue) {
        int out;
        int pv;
        int threshold;
        int value;

        /* You bet */
        pv = (int) (srcWord & 0xFF);
        threshold = ditherThresholds16[pv & 7];
        value = ditherValues16[pv >> 3];
        if (ditherValue < threshold) {
            out = value + 1;
        } else {
            out = value;
        }
        pv = (int) (((srcWord >> 8)) & 0xFF);
        threshold = ditherThresholds16[pv & 7];
        value = ditherValues16[pv >> 3];
        if (ditherValue < threshold) {
            out = out | (((value + 1) << 5));
        } else {
            out = out | ((value << 5));
        }
        pv = (int) (((srcWord >> 16)) & 0xFF);
        threshold = ditherThresholds16[pv & 7];
        value = ditherValues16[pv >> 3];
        if (ditherValue < threshold) {
            out = out | (((value + 1) << 10));
        } else {
            out = out | ((value << 10));
        }
        return out;
    }

/*
 * Return the integer value of the given field of the given object. If the field contains a Float,
 * truncate it and return its integral part. Fail if the given field does not contain a small
 * integer or Float, or if the truncated Float is out of the range of small integers.
 */

    /* BitBltSimulation>>#fetchIntOrFloat:ofObject: */
    static long fetchIntOrFloatofObject(final int fieldIndex, final PointersObject objectPointer) {
        final Object fieldOop;
        final double floatValue;

        fieldOop = fetchPointerofObject(fieldIndex, objectPointer);
        if (fieldOop instanceof Long) {
            return (long) fieldOop;
        } else if (fieldOop instanceof Double) {
            floatValue = (double) fieldOop;
            if (!((-2.147483648e9 <= floatValue) && (floatValue <= 2.147483647e9))) {
                throw new PrimitiveFailed();
            }
            return ((long) floatValue);
        } else {
            throw new SqueakException("Should not be reached");
        }
    }

/*
 * Return the integer value of the given field of the given object. If the field contains a Float,
 * truncate it and return its integral part. Fail if the given field does not contain a small
 * integer or Float, or if the truncated Float is out of the range of small integers.
 */

    /* BitBltSimulation>>#fetchIntOrFloat:ofObject:ifNil: */
    static long fetchIntOrFloatofObjectifNil(final int fieldIndex, final PointersObject objectPointer, final long defaultValue) {
        final Object fieldOop;
        final double floatValue;

        fieldOop = fetchPointerofObject(fieldIndex, objectPointer);
        if (fieldOop instanceof Long) {
            return (long) fieldOop;
        } else if (fieldOop == objectPointer.image.nil) {
            return defaultValue;
        } else if (fieldOop instanceof Double) {
            floatValue = (double) fieldOop;
            if (!((-2.147483648e9 <= floatValue) && (floatValue <= 2.147483647e9))) {
                throw new PrimitiveFailed();
            }
            return ((long) floatValue);
        } else {
            throw new SqueakException("Should not be reached");
        }
    }

/*
 * For any non-zero pixel value in destinationWord with zero alpha channel take the alpha from
 * sourceWord and fill it in. Intended for fixing alpha channels left at zero during 16->32 bpp
 * conversions.
 */

    /* BitBltSimulation>>#fixAlpha:with: */
    static long fixAlphawith(final long sourceWord, final long destinationWord) {
        if (!(destDepth == 32)) {
            return destinationWord;
        }
        if (destinationWord == 0) {
            return 0;
        }
        if (!((destinationWord & 0xFF000000L) == 0)) {
            return destinationWord;
        }
        return destinationWord | (sourceWord & 0xFF000000L);
    }

/*
 * Note: This is hardcoded so it can be run from Squeak. The module name is used for validating a
 * module *after* it is loaded to check if it does really contain the module we're thinking it
 * contains. This is important!
 */

    /* InterpreterPlugin>>#getModuleName */
    public static String getModuleName() {
        return moduleName;
    }

    /* BitBltSimulation>>#ignoreSourceOrHalftone: */
    static boolean ignoreSourceOrHalftone(final PointersObject formPointer) {
        if (formPointer == null) {
            return true;
        }
        if (combinationRule == 0) {
            return true;
        }
        if (combinationRule == 5) {
            return true;
        }
        if (combinationRule == 10) {
            return true;
        }
        if (combinationRule == 15) {
            return true;
        }
        return false;
    }

    /* BitBltSimulation>>#initBBOpTable */
    static long initBBOpTable() {
        opTable[0 + 1] = BitBlt::clearWordwith;
        opTable[1 + 1] = BitBlt::bitAndwith;
        opTable[2 + 1] = BitBlt::bitAndInvertwith;
        opTable[3 + 1] = BitBlt::sourceWordwith;
        opTable[4 + 1] = BitBlt::bitInvertAndwith;
        opTable[5 + 1] = BitBlt::destinationWordwith;
        opTable[6 + 1] = BitBlt::bitXorwith;
        opTable[7 + 1] = BitBlt::bitOrwith;
        opTable[8 + 1] = BitBlt::bitInvertAndInvertwith;
        opTable[9 + 1] = BitBlt::bitInvertXorwith;
        opTable[10 + 1] = BitBlt::bitInvertDestinationwith;
        opTable[11 + 1] = BitBlt::bitOrInvertwith;
        opTable[12 + 1] = BitBlt::bitInvertSourcewith;
        opTable[13 + 1] = BitBlt::bitInvertOrwith;
        opTable[14 + 1] = BitBlt::bitInvertOrInvertwith;
        opTable[15 + 1] = BitBlt::destinationWordwith;
        opTable[16 + 1] = BitBlt::destinationWordwith;
        opTable[17 + 1] = BitBlt::destinationWordwith;
        opTable[18 + 1] = BitBlt::addWordwith;
        opTable[19 + 1] = BitBlt::subWordwith;
        opTable[20 + 1] = BitBlt::rgbAddwith;
        opTable[21 + 1] = BitBlt::rgbSubwith;
        opTable[22 + 1] = BitBlt::oLDrgbDiffwith;
        opTable[23 + 1] = BitBlt::oLDtallyIntoMapwith;
        opTable[24 + 1] = BitBlt::alphaBlendwith;
        opTable[25 + 1] = BitBlt::pixPaintwith;
        opTable[26 + 1] = BitBlt::pixMaskwith;
        opTable[27 + 1] = BitBlt::rgbMaxwith;
        opTable[28 + 1] = BitBlt::rgbMinwith;
        opTable[29 + 1] = BitBlt::rgbMinInvertwith;
        opTable[30 + 1] = BitBlt::alphaBlendConstwith;
        opTable[31 + 1] = BitBlt::alphaPaintConstwith;
        opTable[32 + 1] = BitBlt::rgbDiffwith;
        opTable[33 + 1] = BitBlt::tallyIntoMapwith;
        opTable[34 + 1] = BitBlt::alphaBlendScaledwith;
        opTable[35 + 1] = BitBlt::alphaBlendScaledwith;
        opTable[36 + 1] = BitBlt::alphaBlendScaledwith;
        opTable[37 + 1] = BitBlt::rgbMulwith;
        opTable[38 + 1] = BitBlt::pixSwapwith;
        opTable[39 + 1] = BitBlt::pixClearwith;
        opTable[40 + 1] = BitBlt::fixAlphawith;
        opTable[41 + 1] = BitBlt::rgbComponentAlphawith;
        return 0;
    }

    /* BitBltSimulation>>#initDither8Lookup */
    static long initDither8Lookup() {
        long value;

        for (int b = 0; b <= 0xFF; b += 1) {
            for (int t = 0; t <= 15; t += 1) {
                value = expensiveDither32To16threshold(b, t);
                dither8Lookup[(int) ((((long) (t) << 8)) + b)] = (int) value;
            }
        }
        return 0;
    }

    /* BitBltSimulation>>#initialiseModule */
    public static boolean initialiseModule() {
        initBBOpTable();
        initDither8Lookup();
        return true;
    }

/* Return true if shiftTable/maskTable define an identity mapping. */

    /* BitBltSimulation>>#isIdentityMap:with: */
    static boolean isIdentityMapwith(final int[] shifts, final int[] masks) {
        if ((shifts == null) || (masks == null)) {
            return true;
        }
        if (((shifts[RedIndex]) == 0) && (((shifts[GreenIndex]) == 0) && (((shifts[BlueIndex]) == 0) && (((shifts[AlphaIndex]) == 0) &&
                        (((masks[RedIndex]) == 0xFF0000) && (((masks[GreenIndex]) == 0xFF00) && (((masks[BlueIndex]) == 0xFF) && ((masks[AlphaIndex]) == 0xFF000000L)))))))) {
            return true;
        }
        return false;
    }

/*
 * Load the dest form for BitBlt. Answer false if anything is wrong, true otherwise.
 */

    /* BitBltSimulation>>#loadBitBltDestForm */
    static boolean loadBitBltDestForm() {
        final long destBitsSize;
        final long v;

        v = 0;
        if (!((isPointers(destForm)) && ((slotSizeOf(destForm)) >= 4))) {
            return false;
        }
        final Object destBitsValue = fetchPointerofObject(FormBitsIndex, destForm);
        destWidth = fetchIntegerofObject(FormWidthIndex, destForm);
        destHeight = fetchIntegerofObject(FormHeightIndex, destForm);
        if (!((destWidth >= 0) && (destHeight >= 0))) {
            return false;
        }
        destDepth = fetchIntegerofObject(FormDepthIndex, destForm);
        if (!((destMSB = destDepth > 0))) {
            destDepth = 0 - destDepth;
        }
        if (destBitsValue instanceof Long) {
            // TODO: uncomment
            // /* Query for actual surface dimensions */
            // if (querySurfaceFn == 0) {
            // if (!(loadSurfacePlugin())) {
            // return false;
            // }
            // }
            // if (!(querySurfaceFn(integerValueOf(destBits), (&destWidth), (&destHeight),
            // (&destDepth), (&destMSB)))) {
            // throw new PrimitiveFailed(PrimErrCallbackError);
            // return 0;
            // }
            destPPW = 32 / destDepth;
            destPitch = 0;
        } else {
            if (!(isWordsOrBytes(destBitsValue))) {
                return false;
            }

            final NativeObject destBitsNative = (NativeObject) destBitsValue;
            if (destBitsNative.isByteType()) {
                destBytes = destBitsNative.getByteStorage();
                destWords = null;
            } else if (destBitsNative.isIntType()) {
                destBytes = null;
                destWords = destBitsNative.getIntStorage();
            } else {
                throw new SqueakException("false");
            }

            destPPW = 32 / destDepth;
            destPitch = ((destWidth + (destPPW - 1)) / destPPW) * 4;
            destBitsSize = destWords == null ? destBytes.length : destWords.length * 4;
            if (!(destBitsSize >= (destPitch * destHeight))) {
                return false;
            }
        }
        return true;
    }

/*
 * Load BitBlt from the oop. This function is exported for the Balloon engine.
 */

    /* BitBltSimulation>>#loadBitBltFrom: */
    public static boolean loadBitBltFrom(final PointersObject bbObj) {
        return loadBitBltFromwarping(bbObj, false);
    }

/* Load context from BitBlt instance. Return false if anything is amiss */
/*
 * NOTE this should all be changed to minX/maxX coordinates for simpler clipping -- once it works!
 */

    /* BitBltSimulation>>#loadBitBltFrom:warping: */
    static boolean loadBitBltFromwarping(final PointersObject bbObj, final boolean aBool) {
        boolean ok;

        bitBltOop = bbObj;
        isWarping = aBool;
        numGCsOnInvocation = statNumGCs();
        combinationRule = fetchIntegerofObject(BBRuleIndex, bitBltOop);
        if ((failed()) || ((combinationRule < 0) || (combinationRule > (OpTableSize - 2)))) {
            return false;
        }
        if ((combinationRule >= 16) && (combinationRule <= 17)) {
            return false;
        }
        sourceForm = fetchPointerofObjectOrNull(BBSourceFormIndex, bitBltOop);
        noSource = ignoreSourceOrHalftone(sourceForm);
        halftoneForm = (AbstractSqueakObject) fetchPointerofObject(BBHalftoneFormIndex, bitBltOop);
        noHalftone = ignoreSourceOrHalftone(halftoneForm instanceof PointersObject ? ((PointersObject) halftoneForm) : null);
        destForm = fetchPointerofObjectOrNull(BBDestFormIndex, bbObj);
        ok = loadBitBltDestForm();
        if (!ok) {
            return false;
        }
        destX = fetchIntOrFloatofObjectifNil(BBDestXIndex, bitBltOop, 0);
        destY = fetchIntOrFloatofObjectifNil(BBDestYIndex, bitBltOop, 0);
        width = fetchIntOrFloatofObjectifNil(BBWidthIndex, bitBltOop, destWidth);
        height = fetchIntOrFloatofObjectifNil(BBHeightIndex, bitBltOop, destHeight);
        if (failed()) {
            return false;
        }
        if (noSource) {
            sourceX = (sourceY = 0);
        } else {
            ok = loadBitBltSourceForm();
            if (!ok) {
                return false;
            }
            ok = loadColorMap();
            if (!ok) {
                return false;
            }
            if ((cmFlags & ColorMapNewStyle) == 0) {
                setupColorMasks();
            }
            sourceX = fetchIntOrFloatofObjectifNil(BBSourceXIndex, bitBltOop, 0);
            sourceY = fetchIntOrFloatofObjectifNil(BBSourceYIndex, bitBltOop, 0);
        }
        ok = loadHalftoneForm();
        if (!ok) {
            return false;
        }
        clipX = fetchIntOrFloatofObjectifNil(BBClipXIndex, bitBltOop, 0);
        clipY = fetchIntOrFloatofObjectifNil(BBClipYIndex, bitBltOop, 0);
        clipWidth = fetchIntOrFloatofObjectifNil(BBClipWidthIndex, bitBltOop, destWidth);
        clipHeight = fetchIntOrFloatofObjectifNil(BBClipHeightIndex, bitBltOop, destHeight);
        if (failed()) {
            return false;
        }
        if (clipX < 0) {
            clipWidth += clipX;
            clipX = 0;
        }
        if (clipY < 0) {
            clipHeight += clipY;
            clipY = 0;
        }
        if ((clipX + clipWidth) > destWidth) {
            clipWidth = destWidth - clipX;
        }
        if ((clipY + clipHeight) > destHeight) {
            clipHeight = destHeight - clipY;
        }
        if (numGCsOnInvocation != (statNumGCs())) {
            /* querySurface could be a callback in loadSourceFor: and loadDestForm: */
            throw new PrimitiveFailed(PrimErrObjectMoved);
        }
        return true;
    }

/*
 * Load the source form for BitBlt. Return false if anything is wrong, true otherwise.
 */

    /* BitBltSimulation>>#loadBitBltSourceForm */
    static boolean loadBitBltSourceForm() {
        final long sourceBitsSize;
        final long v;

        v = 0;
        if (!((isPointers(sourceForm)) && ((slotSizeOf(sourceForm)) >= 4))) {
            return false;
        }
        final Object sourceBitsValue = fetchPointerofObject(FormBitsIndex, sourceForm);
        sourceWidth = (int) fetchIntOrFloatofObject(FormWidthIndex, sourceForm);
        sourceHeight = (int) fetchIntOrFloatofObject(FormHeightIndex, sourceForm);
        if (!((sourceWidth >= 0) && (sourceHeight >= 0))) {
            return false;
        }
        sourceDepth = fetchIntegerofObject(FormDepthIndex, sourceForm);
        if (!((sourceMSB = sourceDepth > 0))) {
            sourceDepth = 0 - sourceDepth;
        }
        if (sourceBitsValue instanceof Long) {
            // TODO: uncomment:
            // /* Query for actual surface dimensions */
            // if (querySurfaceFn == 0) {
            // if (!(loadSurfacePlugin())) {
            // return 0;
            // }
            // }
            // if (!(querySurfaceFn(integerValueOf(sourceBits), (&sourceWidth), (&sourceHeight),
            // (&sourceDepth),
            // (&sourceMSB)))) {
            // throw new PrimitiveFailed(PrimErrCallbackError);
            // return 0;
            // }
            sourcePPW = 32 / sourceDepth;
            sourcePitch = 0;
        } else {
            if (!(isWordsOrBytes(sourceBitsValue))) {
                return false;
            }
            final NativeObject sourceBitsNative = (NativeObject) sourceBitsValue;
            if (sourceBitsNative.isByteType()) {
                sourceBytes = sourceBitsNative.getByteStorage();
                sourceWords = null;
            } else if (sourceBitsNative.isIntType()) {
                sourceBytes = null;
                sourceWords = sourceBitsNative.getIntStorage();
            } else {
                throw new SqueakException("false");
            }

            sourcePPW = 32 / sourceDepth;
            sourcePitch = ((sourceWidth + (sourcePPW - 1)) / sourcePPW) * 4;
            sourceBitsSize = sourceWords == null ? sourceBytes.length : sourceWords.length * 4;
            if (!(sourceBitsSize >= (sourcePitch * sourceHeight))) {
                return false;
            }
        }
        return true;
    }

/*
 * ColorMap, if not nil, must be longWords, and 2^N long, where N = sourceDepth for 1, 2, 4, 8 bits,
 * or N = 9, 12, or 15 (3, 4, 5 bits per color) for 16 or 32 bits.
 */

    /* BitBltSimulation>>#loadColorMap */
    static boolean loadColorMap() {
        final Object cmOop;
        final long cmSize;
        boolean oldStyle;
        final NativeObject oop;

        cmFlags = (cmMask = (cmBitsPerColor = 0));
        cmShiftTable = null;
        cmMaskTable = null;
        cmLookupTable = null;
        cmOop = fetchPointerofObject(BBColorMapIndex, bitBltOop);
        if (cmOop == (nilObject())) {
            return true;
        }

        /* even if identity or somesuch - may be cleared later */
        cmFlags = ColorMapPresent;
        oldStyle = false;
        if (cmOop instanceof NativeObject && isWords((NativeObject) cmOop)) {
            /* This is an old-style color map (indexed only, with implicit RGBA conversion) */
            cmSize = slotSizeOfWords((NativeObject) cmOop);
            cmLookupTable = ((NativeObject) cmOop).getIntStorage();
            oldStyle = true;
        } else {

            /* A new-style color map (fully qualified) */
            if (!((isPointers(cmOop)) && ((slotSizeOf((PointersObject) cmOop)) >= 3))) {
                return false;
            }
            final PointersObject cmOopPointers = (PointersObject) cmOop;
            cmShiftTable = loadColorMapShiftOrMaskFrom(fetchNativeofObjectOrNull(0, cmOopPointers));
            cmMaskTable = loadColorMapShiftOrMaskFrom(fetchNativeofObjectOrNull(1, cmOopPointers));
            oop = fetchNativeofObjectOrNull(2, cmOopPointers);
            if (oop == null) {
                cmSize = 0;
            } else {
                if (!(isWords(oop))) {
                    return false;
                }
                cmLookupTable = oop.getIntStorage();
                cmSize = cmLookupTable.length;
            }
            cmFlags = cmFlags | ColorMapNewStyle;
        }
        if (!((cmSize & (cmSize - 1)) == 0)) {
            return false;
        }
        cmMask = cmSize - 1;
        cmBitsPerColor = 0;
        if (cmSize == 512) {
            cmBitsPerColor = 3;
        }
        if (cmSize == 4096) {
            cmBitsPerColor = 4;
        }
        if (cmSize == 32768) {
            cmBitsPerColor = 5;
        }
        if (cmSize == 0) {
            cmLookupTable = null;
            cmMask = 0;
        } else {
            cmFlags = cmFlags | ColorMapIndexedPart;
        }
        if (oldStyle) {
            /* needs implicit conversion */
            setupColorMasks();
        }
        if (isIdentityMapwith(cmShiftTable, cmMaskTable)) {
            cmMaskTable = null;
            cmShiftTable = null;
        } else {
            cmFlags = cmFlags | ColorMapFixedPart;
        }
        return true;
    }

    /* BitBltSimulation>>#loadColorMapShiftOrMaskFrom: */
    public static int[] loadColorMapShiftOrMaskFrom(final NativeObject mapOop) { // FIXME: return
                                                                                 // type
        if (mapOop == null) {
            return null;
        }
        if (!((isWords(mapOop)) && ((slotSizeOfWords(mapOop)) == 4))) {
            throw new PrimitiveFailed();
        }
        return mapOop.getIntStorage();
    }

/* Load the halftone form */

    /* BitBltSimulation>>#loadHalftoneForm */
    static boolean loadHalftoneForm() {
        final NativeObject halftoneBits;

        if (noHalftone) {
            halftoneWords = null;
            return true;
        }
        if ((isPointers(halftoneForm)) && ((slotSizeOf((PointersObject) halftoneForm)) >= 4)) {
            /* Old-style 32xN monochrome halftone Forms */
            halftoneBits = fetchNativeofObjectOrNull(FormBitsIndex, (PointersObject) halftoneForm);
            halftoneHeight = fetchIntegerofObject(FormHeightIndex, (PointersObject) halftoneForm);
            if (!(isWords(halftoneBits))) {
                noHalftone = true;
            } else {
                halftoneWords = halftoneBits.getIntStorage();
            }
        } else {
            /* New spec accepts, basically, a word array */
            if (!(halftoneForm instanceof NativeObject && isWords((NativeObject) halftoneForm))) {
                return false;
            }
            halftoneBits = (NativeObject) halftoneForm;
            halftoneWords = halftoneBits.getIntStorage();
            halftoneHeight = halftoneWords.length;
        }
        return true;
    }

/* Load the surface support plugin */

    /* BitBltSimulation>>#loadSurfacePlugin */
    static long loadSurfacePlugin() {
        // querySurfaceFn = ioLoadFunctionFrom("ioGetSurfaceFormat", "SurfacePlugin");
        // lockSurfaceFn = ioLoadFunctionFrom("ioLockSurface", "SurfacePlugin");
        // unlockSurfaceFn = ioLoadFunctionFrom("ioUnlockSurface", "SurfacePlugin");
        // return (querySurfaceFn != 0) && ((lockSurfaceFn != 0) && (unlockSurfaceFn != 0));
        // TODO: remove?
        return -1;
    }

    /* BitBltSimulation>>#loadWarpBltFrom: */
    static boolean loadWarpBltFrom(final PointersObject bbObj) {
        return loadBitBltFromwarping(bbObj, true);
    }

/* Get a pointer to the bits of any OS surfaces. */
/*
 * Notes: For equal source/dest handles only one locking operation is performed. This is to prevent
 * locking of overlapping areas which does not work with certain APIs (as an example, DirectDraw
 * prevents locking of overlapping areas). A special case for non-overlapping but equal source/dest
 * handle would be possible but we would have to transfer this information over to unlockSurfaces
 * somehow (currently, only one unlock operation is performed for equal source and dest handles).
 * Also, this would require a change in the notion of ioLockSurface() which is right now interpreted
 * as a hint and not as a requirement to lock only the specific portion of the surface.
 *
 * The arguments in ioLockSurface() provide the implementation with an explicit hint what area is
 * affected. It can be very useful to know the max. affected area beforehand if getting the bits
 * requires expensive copy operations (e.g., like a roundtrip to the X server or a glReadPixel op).
 * However, the returned pointer *MUST* point to the virtual origin of the surface and not to the
 * beginning of the rectangle. The promise made by BitBlt is to never access data outside the given
 * rectangle (aligned to 4byte boundaries!) so it is okay to return a pointer to the virtual origin
 * that is actually outside the valid memory area.
 *
 * The area provided in ioLockSurface() is already clipped (e.g., it will always be inside the
 * source and dest boundingBox) but it is not aligned to word boundaries yet. It is up to the
 * support code to compute accurate alignment if necessary. Warping always requires the entire
 * source surface to be locked because there is no beforehand knowledge about what area will
 * actually be traversed. Fail if a GC has occurred since the primitive started (presumably in the
 * lockSurface function), because one or more of the primitives' parameters may have been moved.
 *
 */

    /* BitBltSimulation>>#lockSurfaces */
    static boolean lockSurfaces() {
        final int b;
        final long destHandle;
        final int l;
        final int r;
        long sourceHandle;
        final int t;
        final long v;

        v = 0;
        assert (numGCsOnInvocation == (statNumGCs()));
        hasSurfaceLock = false;
        if (destWords == null) {

            /* Blitting *to* OS surface */
            // TODO: uncomment?
            // if (lockSurfaceFn == 0) {
            // if (!(loadSurfacePlugin())) {
            // return false;
            // }
            // }
            destHandle = fetchIntegerofObject(FormBitsIndex, destForm);
            if (!((sourceWords != null) || (noSource))) {

                /* Handle the special case of equal source and dest handles */
                sourceHandle = fetchIntegerofObject(FormBitsIndex, sourceForm);
                if (sourceHandle == destHandle) {
                    /*
                     * If we have overlapping source/dest we lock the entire area so that there is
                     * only one area transmitted
                     */
                    if (isWarping) {
                        /* Otherwise use overlapping area */
                        l = ((sx < dx) ? sx : dx);
                        r = (((sx < dx) ? dx : sx)) + bbW;
                        t = ((sy < dy) ? sy : dy);
                        b = (((sy < dy) ? dy : sy)) + bbH;
                        sourceWords = lockSurfaceFn(sourceHandle, sourcePitch, l, t, r - l, b - t);
                    } else {
                        /* When warping we always need the entire surface for the source */
                        sourceWords = lockSurfaceFn(sourceHandle, sourcePitch, 0, 0, sourceWidth, sourceHeight);
                    }
                    destWords = sourceWords;
                    destPitch = sourcePitch;
                    hasSurfaceLock = true;
                    if (numGCsOnInvocation != (statNumGCs())) {
                        unlockSurfaces();
                        throw new PrimitiveFailed(PrimErrObjectMoved);
                    }
                    if (destWords == null) {
                        unlockSurfaces();
                        throw new PrimitiveFailed(PrimErrCallbackError);
                    }
                    endOfDestination = (endOfSource = sourceBits + (sourcePitch * sourceHeight));
                    return true;
                }
            }
            destWords = lockSurfaceFn(destHandle, destPitch, dx, dy, bbW, bbH);
            hasSurfaceLock = true;
            if (numGCsOnInvocation != (statNumGCs())) {
                unlockSurfaces();
                throw new PrimitiveFailed(PrimErrObjectMoved);
            }
            if (destWords == null) {
                throw new PrimitiveFailed(PrimErrCallbackError);
            }
        }
        if (!((sourceWords != null) || (noSource))) {
            /* Blitting *from* OS surface */
            sourceHandle = fetchIntegerofObject(FormBitsIndex, sourceForm);
            if (failed()) {
                return false;
            }
            // TODO: uncomment?
            // if (lockSurfaceFn == 0) {
            // if (!(loadSurfacePlugin())) {
            // return false;
            // }
            // }
            if (isWarping) {
                sourceWords = lockSurfaceFn(sourceHandle, sourcePitch, 0, 0, sourceWidth, sourceHeight);
            } else {
                sourceWords = lockSurfaceFn(sourceHandle, sourcePitch, sx, sy, bbW, bbH);
            }
            hasSurfaceLock = true;
            if (numGCsOnInvocation != (statNumGCs())) {
                unlockSurfaces();
                throw new PrimitiveFailed(PrimErrObjectMoved);
            }
            if (sourceWords == null) {
                throw new PrimitiveFailed(PrimErrCallbackError);
            }
        }
        endOfSource = (noSource || (sourceWords == null) ? 0 : sourceWords.length + (sourcePitch * sourceHeight));
        endOfDestination = destWords.length + (destPitch * destHeight);
        return (destWords != null || destBytes != null) && ((sourceWords != null || sourceBytes != null) || (noSource));
    }

/* Color map the given source pixel. */

    /* BitBltSimulation>>#mapPixel:flags: */
    static long mapPixelflags(final long sourcePixel, final long mapperFlags) {
        long pv;

        pv = sourcePixel;
        if ((mapperFlags & ColorMapPresent) != 0) {
            if ((mapperFlags & ColorMapFixedPart) != 0) {

                /* avoid introducing transparency by color reduction */
                pv = rgbMapPixelflags(sourcePixel, mapperFlags);
                if ((pv == 0) && (sourcePixel != 0)) {
                    pv = 1;
                }
            }
            if ((mapperFlags & ColorMapIndexedPart) != 0) {
                pv = cmLookupTable[(int) (pv & cmMask)];
            }
        }
        return pv;
    }

/* Sender warpLoop is too big to include this in-line */

    /* BitBltSimulation>>#merge:with: */
    static long mergewith(final long sourceWord, final long destinationWord) {
        final LongBinaryOperator mergeFnwith = opTable[combinationRule + 1];
        assert mergeFnwith != null;
        return mergeFnwith.applyAsLong(sourceWord, destinationWord);
    }

/*
 * The module with the given name was just unloaded. Make sure we have no dangling references.
 */

    /* BitBltSimulation>>#moduleUnloaded: */
    public static long moduleUnloaded(final String aModuleName) {
        if ("SurfacePlugin".equals(aModuleName)) {
            // TODO: do something here

            /* The surface plugin just shut down. How nasty. */
            // querySurfaceFn = 0;
            // lockSurfaceFn = 0;
            // unlockSurfaceFn = 0;
        }
        return 0;
    }

/*
 * Subract the pixels in the source and destination, color by color, and return the sum of the
 * absolute value of all the differences. For non-rgb, XOR the two and return the number of
 * differing pixels. Note that the region is not clipped to bit boundaries, but only to the nearest
 * (enclosing) word. This is because copyLoop does not do pre-merge masking. For accurate results,
 * you must subtract the values obtained from the left and right fringes.
 */

    /* BitBltSimulation>>#OLDrgbDiff:with: */
    static long oLDrgbDiffwith(final long sourceWord, final long destinationWord) {
        long diff;
        final int pixMask;

        if (destDepth < 16) {

            /* Just xor and count differing bits if not RGB */
            diff = sourceWord ^ destinationWord;
            pixMask = maskTable[destDepth];
            while (!(diff == 0)) {
                if ((diff & pixMask) != 0) {
                    bitCount += 1;
                }
                diff = (diff) >> destDepth;
            }
            return destinationWord;
        }
        if (destDepth == 16) {
            diff = partitionedSubfromnBitsnPartitions(sourceWord, destinationWord, 5, 3);
            bitCount = ((bitCount + (diff & 0x1F)) + (((diff) >> 5) & 0x1F)) + (((diff) >> 10) & 0x1F);
            diff = partitionedSubfromnBitsnPartitions((sourceWord) >> 16, (destinationWord) >> 16, 5, 3);
            bitCount = ((bitCount + (diff & 0x1F)) + (((diff) >> 5) & 0x1F)) + (((diff) >> 10) & 0x1F);
        } else {
            diff = partitionedSubfromnBitsnPartitions(sourceWord, destinationWord, 8, 3);
            bitCount = ((bitCount + (diff & 0xFF)) + (((diff) >> 8) & 0xFF)) + (((diff) >> 16) & 0xFF);
        }
        return destinationWord;
    }

/*
 * Tally pixels into the color map. Note that the source should be specified = destination, in order
 * for the proper color map checks to be performed at setup. Note that the region is not clipped to
 * bit boundaries, but only to the nearest (enclosing) word. This is because copyLoop does not do
 * pre-merge masking. For accurate results, you must subtract the values obtained from the left and
 * right fringes.
 */

    /* BitBltSimulation>>#OLDtallyIntoMap:with: */
    static long oLDtallyIntoMapwith(final long sourceWord, final long destinationWord) {
        long i;
        long mapIndex;
        final long pixMask;
        long shiftWord;
        long value;
        final int value1;
        final int value2;
        final int value3;

        if (!((cmFlags & (ColorMapPresent | ColorMapIndexedPart)) == (ColorMapPresent | ColorMapIndexedPart))) {
            return destinationWord;
        }
        if (destDepth < 16) {
            /* loop through all packed pixels. */
            pixMask = (maskTable[destDepth]) & cmMask;
            shiftWord = destinationWord;
            for (i = 1; i <= destPPW; i += 1) {
                mapIndex = shiftWord & pixMask;
                /* begin tallyMapAt:put: */
                final int index = (int) (mapIndex & cmMask);
                value = (cmLookupTable[index]) + 1;
                cmLookupTable[index] = (int) value;
                shiftWord = (shiftWord) >> destDepth;
            }
            return destinationWord;
        }
        if (destDepth == 16) {
            /* Two pixels Tally the right half... */
            mapIndex = rgbMapfromto(destinationWord & 0xFFFF, 5, cmBitsPerColor);
            /* begin tallyMapAt:put: */
            final int index = (int) (mapIndex & cmMask);
            value1 = (cmLookupTable[index]) + 1;
            cmLookupTable[index] = value1;
            mapIndex = rgbMapfromto((destinationWord) >> 16, 5, cmBitsPerColor);
            /* begin tallyMapAt:put: */
            final int index2 = (int) (mapIndex & cmMask);
            value2 = (cmLookupTable[index2]) + 1;
            cmLookupTable[index2] = value2;
        } else {
            /* Just one pixel. */
            mapIndex = rgbMapfromto(destinationWord, 8, cmBitsPerColor);
            /* begin tallyMapAt:put: */
            final int index = (int) (mapIndex & cmMask);
            value3 = (cmLookupTable[index]) + 1;
            cmLookupTable[index] = value3;
        }
        return destinationWord;
    }

/*
 * Add word1 to word2 as nParts partitions of nBits each. This is useful for packed pixels, or
 * packed colors
 */
/*
 * Use long everywhere because it has a well known arithmetic model without undefined behavior
 * w.r.t. overflow and shifts
 */

    /* BitBltSimulation>>#partitionedAdd:to:nBits:componentMask:carryOverflowMask: */
    static long partitionedAddtonBitscomponentMaskcarryOverflowMask(final long word1, final long word2, final long nBits, final long componentMask, final long carryOverflowMask) {
        final long carryOverflow;
        final long sum;
        final long w1;
        final long w2;

        /* mask to remove high bit of each component */
        w1 = word1 & carryOverflowMask;
        w2 = word2 & carryOverflowMask;

        /* sum without high bit to avoid overflowing over next component */
        sum = (word1 ^ w1) + (word2 ^ w2);

        /* detect overflow condition for saturating */
        carryOverflow = (w1 & w2) | ((w1 | w2) & sum);
        return ((sum ^ w1) ^ w2) | (((carryOverflow) >> (nBits - 1)) * componentMask);
    }

/*
 * AND word1 to word2 as nParts partitions of nBits each. Any field of word1 not all-ones is treated
 * as all-zeroes. Used for erasing, eg, brush shapes prior to ORing in a color
 */

    /* BitBltSimulation>>#partitionedAND:to:nBits:nPartitions: */
    static long partitionedANDtonBitsnPartitions(final long word1, final long word2, final int nBits, final int nParts) {
        long i;
        long mask;
        long result;

        /* partition mask starts at the right */
        mask = maskTable[nBits];
        result = 0;
        for (i = 1; i <= nParts; i += 1) {
            if ((word1 & mask) == mask) {
                result = result | (word2 & mask);
            }

            /* slide left to next partition */
            mask = ((mask) << nBits);
        }
        return result;
    }

/* Max word1 to word2 as nParts partitions of nBits each */
/*
 * In C, most arithmetic operations answer the same bit pattern regardless of the operands being
 * signed or longs (this is due to the way 2's complement numbers work). However, comparisions might
 * fail. Add the proper declaration of words as long in those cases where comparisions are done
 * (jmv)
 */

    /* BitBltSimulation>>#partitionedMax:with:nBits:nPartitions: */
    static long partitionedMaxwithnBitsnPartitions(final long word1, final long word2, final int nBits, final int nParts) {
        long i;
        long mask;
        long result;

        /* partition mask starts at the right */
        mask = maskTable[nBits];
        result = 0;
        for (i = 1; i <= nParts; i += 1) {
            result = result | ((((word2 & mask) < (word1 & mask)) ? (word1 & mask) : (word2 & mask)));

            /* slide left to next partition */
            mask = ((mask) << nBits);
        }
        return result;
    }

/* Min word1 to word2 as nParts partitions of nBits each */
/*
 * In C, most arithmetic operations answer the same bit pattern regardless of the operands being
 * signed or longs (this is due to the way 2's complement numbers work). However, comparisions might
 * fail. Add the proper declaration of words as long in those cases where comparisions are done
 * (jmv)
 */

    /* BitBltSimulation>>#partitionedMin:with:nBits:nPartitions: */
    static long partitionedMinwithnBitsnPartitions(final long word1, final long word2, final int nBits, final int nParts) {
        long i;
        long mask;
        long result;

        /* partition mask starts at the right */
        mask = maskTable[nBits];
        result = 0;
        for (i = 1; i <= nParts; i += 1) {
            result = result | ((((word2 & mask) < (word1 & mask)) ? (word2 & mask) : (word1 & mask)));

            /* slide left to next partition */
            mask = ((mask) << nBits);
        }
        return result;
    }

/*
 * Multiply word1 with word2 as nParts partitions of nBits each. This is useful for packed pixels,
 * or packed colors. Bug in loop version when non-white background
 */
/*
 * In C, integer multiplication might answer a wrong value if the unsigned values are declared as
 * signed. This problem does not affect this method, because the most significant bit (i.e. the sign
 * bit) will always be zero (jmv)
 */

    /* BitBltSimulation>>#partitionedMul:with:nBits:nPartitions: */
    static long partitionedMulwithnBitsnPartitions(final long word1, final long word2, final int nBits, final int nParts) {
        final long dMask;
        long product;
        long result;
        final long sMask;

        /* partition mask starts at the right */
        sMask = maskTable[nBits];
        dMask = ((sMask) << nBits);

        /* optimized first step */
        result = (((((word1 & sMask) + 1) * ((word2 & sMask) + 1)) - 1) & dMask) >> nBits;
        if (nParts == 1) {
            return result;
        }
        product = ((((((word1) >> nBits) & sMask) + 1) * ((((word2) >> nBits) & sMask) + 1)) - 1) & dMask;
        result = result | product;
        if (nParts == 2) {
            return result;
        }
        product = ((((((word1) >> (2 * nBits)) & sMask) + 1) * ((((word2) >> (2 * nBits)) & sMask) + 1)) - 1) & dMask;
        result = result | (((product) << nBits));
        if (nParts == 3) {
            return result;
        }
        product = ((((((word1) >> (3 * nBits)) & sMask) + 1) * ((((word2) >> (3 * nBits)) & sMask) + 1)) - 1) & dMask;
        result = result | (((product) << (2 * nBits)));
        return result;
    }

    /* BitBltSimulation>>#partitionedRgbComponentAlpha:dest:nBits:nPartitions: */
    static long partitionedRgbComponentAlphadestnBitsnPartitions(final long sourceWord, final long destWord, final int nBits, final int nParts) {
        long mask;
        long p1;
        long p2;
        long result;
        long v;

        /* partition mask starts at the right */
        mask = maskTable[nBits];
        result = 0;
        for (int i = 1; i <= nParts; i += 1) {
            p1 = (sourceWord & mask) >> ((i - 1) * nBits);
            p2 = (destWord & mask) >> ((i - 1) * nBits);
            if (!(nBits == 32)) {
                if (nBits == 16) {
                    p1 = ((((((p1 & 0x1F)) << 3)) | ((((p1 & 0x3E0)) << 6))) | ((((p1 & 0x7C00)) << 9))) | 0xFF000000L;
                    p2 = ((((((p2 & 0x1F)) << 3)) | ((((p2 & 0x3E0)) << 6))) | ((((p2 & 0x7C00)) << 9))) | 0xFF000000L;
                } else {
                    p1 = (rgbMapfromto(p1, nBits, 32)) | 0xFF000000L;
                    p2 = (rgbMapfromto(p2, nBits, 32)) | 0xFF000000L;
                }
            }
            v = rgbComponentAlpha32with(p1, p2);
            if (!(nBits == 32)) {
                v = rgbMapfromto(v, 32, nBits);
            }
            result = result | (((v) << ((i - 1) * nBits)));

            /* slide left to next partition */
            mask = ((mask) << nBits);
        }
        return result;
    }

/*
 * Subtract word1 from word2 as nParts partitions of nBits each. This is useful for packed pixels,
 * or packed colors
 */
/*
 * In C, most arithmetic operations answer the same bit pattern regardless of the operands being
 * signed or longs (this is due to the way 2's complement numbers work). However, comparisions might
 * fail. Add the proper declaration of words as long in those cases where comparisions are done
 * (jmv)
 */

    /* BitBltSimulation>>#partitionedSub:from:nBits:nPartitions: */
    static long partitionedSubfromnBitsnPartitions(final long word1, final long word2, final int nBits, final int nParts) {
        long i;
        long mask;
        long p1;
        long p2;
        long result;

        /* partition mask starts at the right */
        mask = maskTable[nBits];
        result = 0;
        for (i = 1; i <= nParts; i += 1) {
            p1 = word1 & mask;
            p2 = word2 & mask;
            if (p1 < p2) {

                /* result is really abs value of thedifference */
                result = result | (p2 - p1);
            } else {
                result = result | (p1 - p2);
            }

            /* slide left to next partition */
            mask = ((mask) << nBits);
        }
        return result;
    }

/*
 * Based on the values provided during setup choose and perform the appropriate inner loop function.
 */
/* Should be inlined into caller for speed */

    /* BitBltSimulation>>#performCopyLoop */
    static void performCopyLoop() {
        destMaskAndPointerInit();
        if (noSource) {
            /* Simple fill loop */
            copyLoopNoSource();
        } else {
            /* Loop using source and dest */
            checkSourceOverlap();
            if ((sourceDepth != destDepth) || ((cmFlags != 0) || (sourceMSB != destMSB))) {
                /*
                 * If we must convert between pixel depths or use color lookups or swap pixels use
                 * the general version
                 */
                copyLoopPixMap();
            } else {
                /* Otherwise we simply copy pixels and can use a faster version */
                sourceSkewAndPointerInit();
                copyLoop();
            }
        }
    }

/*
 * Pick nPix pixels starting at srcBitIndex from the source, map by the color map, and justify them
 * according to dstBitIndex in the resulting destWord.
 */

    /* BitBltSimulation>>#pickSourcePixels:flags:srcMask:destMask:srcShiftInc:dstShiftInc: */
    static long pickSourcePixelsflagssrcMaskdestMasksrcShiftIncdstShiftInc(final long nPixels, final long mapperFlags, final long srcMask, final long dstMask, final long srcShiftInc,
                    final long dstShiftInc) {
        long destPix;
        long destWord;
        long dstShift;
        long nPix;
        long sourcePix;
        long sourceWord;
        long srcShift;

        /* oh please */
        destWord = 0;

        /* Hint: Keep in register */
        srcShift = srcBitShift;

        /* Hint: Keep in register */
        dstShift = dstBitShift;

        /* always > 0 so we can use do { } while(--nPix); */
        nPix = nPixels;
        if (mapperFlags == (ColorMapPresent | ColorMapIndexedPart)) {

            /* a little optimization for (pretty crucial) blits using indexed lookups only */
            /* grab, colormap and mix in pixel */
            do {
                assert (((sourceIndex)) < endOfSource);
                sourceWord = srcLongAt(sourceIndex);
                sourcePix = ((sourceWord) >> srcShift) & srcMask;
                destPix = cmLookupTable[(int) (sourcePix & cmMask)];

                /* adjust dest pix index */
                destWord = destWord | ((((destPix & dstMask)) << dstShift));

                /* adjust source pix index */
                dstShift += dstShiftInc;
                if (!((((srcShift += srcShiftInc)) & 0xFFFFFFE0L) == 0)) {
                    srcShift = (sourceMSB ? srcShift + 32 : srcShift - 32);
                    /* begin incSrcIndex: */
                    sourceIndex += 4;
                }
            } while (!(((nPix -= 1)) == 0));
        } else {

            /* grab, colormap and mix in pixel */
            do {
                assert (((sourceIndex)) < endOfSource);
                sourceWord = srcLongAt(sourceIndex);
                sourcePix = ((sourceWord) >> srcShift) & srcMask;
                destPix = mapPixelflags(sourcePix, mapperFlags);

                /* adjust dest pix index */
                destWord = destWord | ((((destPix & dstMask)) << dstShift));

                /* adjust source pix index */
                dstShift += dstShiftInc;
                if (!((((srcShift += srcShiftInc)) & 0xFFFFFFE0L) == 0)) {
                    srcShift = (sourceMSB ? srcShift + 32 : srcShift - 32);
                    /* begin incSrcIndex: */
                    sourceIndex += 4;
                }
            } while (!(((nPix -= 1)) == 0));
        }

        /* Store back */
        srcBitShift = srcShift;
        return destWord;
    }

/*
 * Pick a single pixel from the source for WarpBlt. Note: This method is crucial for WarpBlt speed
 * w/o smoothing and still relatively important when smoothing is used.
 */

    /* BitBltSimulation>>#pickWarpPixelAtX:y: */
    static long pickWarpPixelAtXy(final long xx, final long yy) {
        final long sourcePix;
        final long sourceWord;
        final long srcIndex;
        final long x;
        final long y;

        /* *please* */
        /*
         * note: it would be much faster if we could just avoid these stupid tests for being inside
         * sourceForm.
         */
        if ((xx < 0) || ((yy < 0) || ((((x = (xx) >> BinaryPoint)) >= sourceWidth) || (((y = (yy) >> BinaryPoint)) >= sourceHeight)))) {
            return 0;
        }
        srcIndex = (sourceBits + (y * sourcePitch)) + (((x) >> warpAlignShift) * 4);

        /* Extract pixel from word */
        assert (((srcIndex)) < endOfSource);
        sourceWord = srcLongAt(srcIndex);
        srcBitShift = warpBitShiftTable[(int) (x & warpAlignMask)];
        sourcePix = ((sourceWord) >> srcBitShift) & warpSrcMask;
        return sourcePix;
    }

/*
 * Clear all pixels in destinationWord for which the pixels of sourceWord have the same values. Used
 * to clear areas of some constant color to zero.
 */

    /* BitBltSimulation>>#pixClear:with: */
    static long pixClearwith(final long sourceWord, final long destinationWord) {
        long i;
        long mask;
        final int nBits;
        long pv;
        long result;

        if (destDepth == 32) {
            if (sourceWord == destinationWord) {
                return 0;
            } else {
                return destinationWord;
            }
        }
        nBits = destDepth;

        /* partition mask starts at the right */
        mask = maskTable[nBits];
        result = 0;
        for (i = 1; i <= destPPW; i += 1) {
            pv = destinationWord & mask;
            if ((sourceWord & mask) == pv) {
                pv = 0;
            }
            result = result | pv;

            /* slide left to next partition */
            mask = ((mask) << nBits);
        }
        return result;
    }

    /* BitBltSimulation>>#pixMask:with: */
    static long pixMaskwith(final long sourceWord, final long destinationWord) {
        return partitionedANDtonBitsnPartitions(~sourceWord, destinationWord, destDepth, destPPW);
    }

    /* BitBltSimulation>>#pixPaint:with: */
    static long pixPaintwith(final long sourceWord, final long destinationWord) {
        if (sourceWord == 0) {
            return destinationWord;
        }
        return sourceWord | (partitionedANDtonBitsnPartitions(~sourceWord, destinationWord, destDepth, destPPW));
    }

/* Swap the pixels in destWord */

    /* BitBltSimulation>>#pixSwap:with: */
    static long pixSwapwith(final long sourceWord, final long destWord) {
        long highMask;
        long i;
        long lowMask;
        long result;
        int shift;

        if (destPPW == 1) {
            return destWord;
        }
        result = 0;

        /* mask low pixel */
        lowMask = (1L << destDepth) - 1;

        /* mask high pixel */
        highMask = ((lowMask) << ((destPPW - 1) * destDepth));
        shift = 32 - destDepth;
        result = result | (((((destWord & lowMask)) << shift)) | ((destWord & highMask) >> shift));
        if (destPPW <= 2) {
            return result;
        }
        for (i = 2; i <= (destPPW / 2); i += 1) {
            lowMask = ((lowMask) << destDepth);
            highMask = (highMask) >> destDepth;
            shift -= destDepth * 2;
            result = result | (((((destWord & lowMask)) << shift)) | ((destWord & highMask) >> shift));
        }
        return result;
    }

/*
 * Invoke the copyBits primitive. If the destination is the display, then copy it to the screen.
 */

    /* BitBltSimulation>>#primitiveCopyBits */
    public static Object primitiveCopyBits(final PointersObject rcvr) {
        if (!(loadBitBltFromwarping(rcvr, false))) {
            throw new PrimitiveFailed();
        }
        copyBits();
        if (failed()) {
            throw new SqueakException("Should not happen");
        }
        /* begin showDisplayBits */
        if (numGCsOnInvocation != (statNumGCs())) {
            reloadDestAndSourceForms();
        }
        showDisplayBitsLeftTopRightBottom(destForm, affectedL, affectedT, affectedR, affectedB);
        if (failed()) {
            throw new SqueakException("return null");
        }
        if ((combinationRule == 22) || (combinationRule == 32)) {
            return bitCount;
        } else {
            return rcvr;
        }
    }

    /* BitBltSimulation>>#primitiveDisplayString */
    public Object primitiveDisplayString(final PointersObject bbObj, final NativeObject sourceString, final long startIndex, final long stopIndex, final ArrayObject glyphMap, final ArrayObject xTable,
                    final int kernDelta) {
        int ascii;
        int glyphIndex;
        final long left;
        final long maxGlyph;
        final boolean quickBlt;
        final String sourcePtr;

        if (!((isArray(xTable)) && ((isArray(glyphMap)) && (((slotSizeOf(glyphMap)) == 256) && ((isBytes(sourceString)) && ((startIndex > 0) &&
                        ((stopIndex >= 0) &&
                                        ((stopIndex <= (sourceString.getByteLength())) && ((loadBitBltFromwarping(bbObj, false)) && ((combinationRule != 30) && (combinationRule != 0x1F))))))))))) {
            throw new PrimitiveFailed();
        }
        if (stopIndex == 0) {
            return bbObj;
        }

        /* See if we can go directly into copyLoopPixMap (usually we can) */
        maxGlyph = (slotSizeOf(xTable)) - 2;

        /* no point using slower version */
        quickBlt = (destWords != null || destBytes != null) && ((sourceWords != null || sourceBytes != null) &&
                        ((noSource == false) && ((sourceForm != destForm) && ((cmFlags != 0) || ((sourceMSB != destMSB) || (sourceDepth != destDepth))))));
        if (quickBlt) {
            endOfSource = sourceBits + (sourcePitch * sourceHeight);
            endOfDestination = destBits + (destPitch * destHeight);
        } else {
            if (!(lockSurfaces())) {
                throw new PrimitiveFailed();
            }
        }
        left = destX;
        final long[] glyphs = glyphMap.getLongStorage();
        final long[] xTableLongs = xTable.getLongStorage();
        final byte[] sourceStringBytes = sourceString.getByteStorage();
        for (int charIndex = (int) startIndex; charIndex <= stopIndex; charIndex += 1) {
            ascii = Byte.toUnsignedInt(sourceStringBytes[charIndex - 1]);
            glyphIndex = (int) glyphs[ascii];
            if ((glyphIndex < 0) || (glyphIndex > maxGlyph)) {
                throw new PrimitiveFailed();
            }
            sourceX = (int) xTableLongs[glyphIndex];
            width = (int) (xTableLongs[glyphIndex + 1] - sourceX);
            if (failed()) {
                throw new SqueakException("return null");
            }
            clipRange();
            if ((bbW > 0) && (bbH > 0)) {
                if (quickBlt) {
                    destMaskAndPointerInit();
                    copyLoopPixMap();
                    affectedL = dx;
                    affectedR = dx + bbW;
                    affectedT = dy;
                    affectedB = dy + bbH;
                } else {
                    copyBitsLockedAndClipped();
                }
            }
            if (failed()) {
                throw new SqueakException("return null");
            }
            destX = (destX + width) + kernDelta;
        }
        affectedL = left;
        if (!quickBlt) {
            unlockSurfaces();
        }
        /* begin showDisplayBits */
        if (numGCsOnInvocation != (statNumGCs())) {
            reloadDestAndSourceForms();
        }
        showDisplayBitsLeftTopRightBottom(destForm, affectedL, affectedT, affectedR, affectedB);
        storeIntegerofObjectwithValue(BBDestXIndex, bbObj, destX);
        return bbObj;
    }

    /* Invoke the line drawing primitive. */

    /* BitBltSimulation>>#primitiveDrawLoop */
    public Object primitiveDrawLoop(final PointersObject rcvr, final long xDelta, final long yDelta) {
        if (!(loadBitBltFromwarping(rcvr, false))) {
            throw new PrimitiveFailed();
        }
        if (!(failed())) {
            drawLoopXY(xDelta, yDelta);
            /* begin showDisplayBits */
            if (numGCsOnInvocation != (statNumGCs())) {
                reloadDestAndSourceForms();
            }
            showDisplayBitsLeftTopRightBottom(destForm, affectedL, affectedT, affectedR, affectedB);
        }
        return rcvr; // TODO: verify return value
    }

/*
 * returns the single pixel at x@y. It does not handle LSB bitmaps right now. If x or y are < 0,
 * return 0 to indicate transparent (cf BitBlt>bitPeekerFromForm: usage). Likewise if x>width or
 * y>depth. Fail if the rcvr doesn't seem to be a Form, or x|y seem wrong
 */

    /* BitBltSimulation>>#primitivePixelValueAtX:y: */
    public long primitivePixelValueAt(final PointersObject rcvr, final long xVal, final long yVal) {
        final NativeObject bitmap;
        final long bitsSize;
        final long depth;
        final long mask;
        final long pixel;
        final long ppW;
        final long shift;
        final long stride;
        final long word;
        final long returnValue;

        if ((xVal < 0) || (yVal < 0)) {
            return 0L;
        }
        if (!((isPointers(rcvr)) && ((slotSizeOf(rcvr)) >= 4))) {
            throw new PrimitiveFailed();
        }
        bitmap = fetchNativeofObjectOrNull(FormBitsIndex, rcvr);
        if (!(isWordsOrBytes(bitmap))) {
            throw new PrimitiveFailed();
        }
        width = fetchIntegerofObject(FormWidthIndex, rcvr);
        height = fetchIntegerofObject(FormHeightIndex, rcvr);

        /* if width/height/depth are not integer, fail */
        depth = fetchIntegerofObject(FormDepthIndex, rcvr);
        if (failed()) {
            throw new SqueakException("return null");
        }
        if ((xVal >= width) || (yVal >= height)) {
            return 0L;
        }
        if (depth < 0) {
            throw new PrimitiveFailed();
        }

        /* pixels in each word */
        ppW = 32 / depth;

        // TODO: use code below or hand-ported code?

        // /* how many words per row of pixels */
        // stride = (width + (ppW - 1)) / ppW;
        // bitsSize = byteSizeOf(bitmap);
        // if (!(bitsSize >= ((stride * height) * 4))) {
        // /* bytes per word */
        // throw new PrimitiveFailed();
        // }
        //
        // /* load the word that contains our target */
        // word = fetchLong32ofObject((yVal * stride) + (xVal / ppW), bitmap);
        //
        // /* make a mask to isolate the pixel within that word */
        // mask = 0xFFFFFFFFL >> (32 - depth);
        //
        // /*
        // * this is the tricky MSB part - we mask the xVal to find how far into the word we need,
        // * then add 1 for the pixel we're looking for, then * depth to get the bit shift
        // */
        // shift = 32 - (((xVal & (ppW - 1)) + 1) * depth);
        //
        // /* shift, mask and dim the lights */
        // pixel = (((long) word) >> shift) & mask;
        // if (failed()) {
        // throw new SqueakException("return null");
        // }
        // returnValue = positive32BitIntegerFor(pixel);
        // if (failed()) {
        // throw new SqueakException("return null");
        // }
        // return returnValue;
        return -1;
    }

/*
 * Invoke the warpBits primitive. If the destination is the display, then copy it to the screen.
 */

    /* BitBltSimulation>>#primitiveWarpBits */
    public PointersObject primitiveWarpBits(final PointersObject rcvr, final long n, final AbstractSqueakObject sourceMap) {
        if (!(loadBitBltFromwarping(rcvr, true))) {
            throw new PrimitiveFailed();
        }
        warpBits(n, sourceMap);
        if (failed()) {
            throw new SqueakException("return null");
        }
        /* begin showDisplayBits */
        if (numGCsOnInvocation != (statNumGCs())) {
            reloadDestAndSourceForms();
        }
        showDisplayBitsLeftTopRightBottom(destForm, affectedL, affectedT, affectedR, affectedB);
        if (failed()) {
            throw new SqueakException("return null");
        }
        return rcvr;
    }

/*
 * A GC has occurred. The destForm must be updated. But where to derive it from? For copyBits and
 * warpBits it is derived from the receiver. But for a BalloonEnginePlugin it should be obtained
 * from (interpreterProxy fetchPointer: BEBitBltIndex ofObject: engine). For the moment implement
 * something that works for these two cases.
 */

    /* BitBltSimulation>>#reloadDestAndSourceForms */
    static void reloadDestAndSourceForms() {
        // TODO: can be removed?
// receiver = stackValue(methodArgumentCount());
// destForm = fetchPointerofObject(BBDestFormIndex, receiver);
// sourceForm = fetchPointerofObject(BBSourceFormIndex, receiver);
    }

    /* BitBltSimulation>>#rgbAdd:with: */
    static long rgbAddwith(final long sourceWord, final long destinationWord) {
        long carryOverflowMask;
        long componentMask;

        if (destDepth < 16) {

            /* Add each pixel separately */
            componentMask = (1L << destDepth) - 1;
            carryOverflowMask = (((0xFFFFFFFFL / componentMask)) << (destDepth - 1));
            return partitionedAddtonBitscomponentMaskcarryOverflowMask(sourceWord, destinationWord, destDepth, componentMask, carryOverflowMask);
        }
        if (destDepth == 16) {

            /* Add RGB components of each pixel separately */
            componentMask = 0x1F;
            carryOverflowMask = 1108361744;
            return partitionedAddtonBitscomponentMaskcarryOverflowMask(sourceWord & 2147450879, destinationWord & 2147450879, 5, componentMask, carryOverflowMask);
        } else {

            /* Add RGBA components of the pixel separately */
            componentMask = 0xFF;
            carryOverflowMask = 2155905152L;
            return partitionedAddtonBitscomponentMaskcarryOverflowMask(sourceWord, destinationWord, 8, componentMask, carryOverflowMask);
        }
    }

/*
 * This version assumes combinationRule = 41 sourcePixSize = 32 destPixSize = 16 sourceForm ~=
 * destForm.
 */
/* This particular method should be optimized in itself */

    /* BitBltSimulation>>#rgbComponentAlpha16 */
    static long rgbComponentAlpha16() {
        int deltaX;
        int deltaY;
        long destWord;
        int ditherBase;
        int ditherIndex;
        int ditherThreshold;
        long dstIndex;
        long dstMask;
        long dstValue;
        int dstY;
        long sourceWord;
        long srcAlpha;
        long srcIndex;
        int srcShift;
        int srcY;

        /* So we can pre-decrement */
        deltaY = bbH + 1;
        srcY = sy;
        dstY = dy;
        srcShift = (dx & 1) * 16;
        if (destMSB) {
            srcShift = 16 - srcShift;
        }

        /* This is the outer loop */
        mask1 = 0xFFFFL << (16 - srcShift);
        while (((deltaY -= 1)) != 0) {
            srcIndex = (sourceBits + (srcY * sourcePitch)) + (sx * 4);
            dstIndex = (destBits + (dstY * destPitch)) + ((dx / 2) * 4);
            ditherBase = (dstY & 3) * 4;

            /* For pre-increment */
            ditherIndex = (sx & 3) - 1;

            /* So we can pre-decrement */
            deltaX = bbW + 1;
            dstMask = mask1;
            if (dstMask == 0xFFFF) {
                srcShift = 16;
            } else {
                srcShift = 0;
            }
            while (((deltaX -= 1)) != 0) {
                ditherThreshold = ditherMatrix4x4[ditherBase + ((ditherIndex = (ditherIndex + 1) & 3))];
                assert (((srcIndex)) < endOfSource);
                sourceWord = srcLongAt(srcIndex);
                srcAlpha = sourceWord & 0xFFFFFF;
                if (!(srcAlpha == 0)) {

                    /* 0 < srcAlpha */
                    /* If we have to mix colors then just copy a single word */
                    /* begin dstLongAt: */
                    assert (((dstIndex)) < endOfDestination);
                    destWord = ((dstLongAt(dstIndex)));
                    destWord = destWord & (~dstMask);

                    /* Expand from 16 to 32 bit by adding zero bits */
                    destWord = (destWord) >> srcShift;

                    /* Mix colors */
                    destWord = ((((destWord & 0x7C00) << 9)) | (((destWord & 0x3E0) << 6))) | ((((destWord & 0x1F) << 3)) | 0xFF000000L);

                    /* And dither */
                    sourceWord = rgbComponentAlpha32with(sourceWord, destWord);
                    sourceWord = dither32To16threshold(sourceWord, ditherThreshold);
                    if (sourceWord == 0) {
                        sourceWord = 1L << srcShift;
                    } else {
                        sourceWord = ((sourceWord) << srcShift);
                    }
                    /* begin dstLongAt:put:mask: */
                    assert (((dstIndex)) < endOfDestination);
                    dstValue = dstLongAt(dstIndex);
                    dstValue = dstValue & dstMask;
                    dstValue = dstValue | sourceWord;
                    /* begin dstLongAt:put: */
                    dstLongAtput(dstIndex, dstValue);
                }
                srcIndex += 4;
                if (destMSB) {
                    if (srcShift == 0) {
                        dstIndex += 4;
                    }
                } else {
                    if (!(srcShift == 0)) {
                        dstIndex += 4;
                    }
                }

                /* Toggle between 0 and 16 */
                srcShift = srcShift ^ 16;
                dstMask = ~dstMask;
            }
            srcY += 1;
            dstY += 1;
        }
        return 0;
    }

/*
 * This version assumes combinationRule = 41 sourcePixSize = destPixSize = 32 sourceForm ~=
 * destForm. Note: The inner loop has been optimized for dealing with the special case of aR = aG =
 * aB = 0
 */

    /* BitBltSimulation>>#rgbComponentAlpha32 */
    static long rgbComponentAlpha32() {
        long deltaX;
        int deltaY;
        long destWord;
        long dstIndex;
        int dstY;
        long sourceWord;
        long srcAlpha;
        long srcIndex;
        int srcY;

        /* This particular method should be optimized in itself */
        /* Give the compile a couple of hints */
        /*
         * The following should be declared as pointers so the compiler will notice that they're
         * used for accessing memory locations (good to know on an Intel architecture) but then the
         * increments would be different between ST code and C code so must hope the compiler
         * notices what happens (MS Visual C does)
         */

        /* So we can pre-decrement */
        deltaY = bbH + 1;
        srcY = sy;

        /* This is the outer loop */
        dstY = dy;
        while (((deltaY -= 1)) != 0) {
            srcIndex = (sourceBits + (srcY * sourcePitch)) + (sx * 4);
            dstIndex = (destBits + (dstY * destPitch)) + (dx * 4);

            /* So we can pre-decrement */
            /* This is the inner loop */
            deltaX = bbW + 1;
            while (((deltaX -= 1)) != 0) {
                assert (((srcIndex)) < endOfSource);
                sourceWord = srcLongAt(srcIndex);
                srcAlpha = sourceWord & 0xFFFFFF;
                if (srcAlpha == 0) {
                    srcIndex += 4;

                    /* Now skip as many words as possible, */
                    dstIndex += 4;
                    while ((((deltaX -= 1)) != 0) && ((((sourceWord = srcLongAt(srcIndex))) & 0xFFFFFF) == 0)) {
                        srcIndex += 4;
                        dstIndex += 4;
                    }
                    deltaX += 1;
                } else {

                    /* 0 < srcAlpha */
                    /* If we have to mix colors then just copy a single word */
                    /* begin dstLongAt: */
                    assert (((dstIndex)) < endOfDestination);
                    destWord = ((dstLongAt(dstIndex)));
                    destWord = rgbComponentAlpha32with(sourceWord, destWord);
                    /* begin dstLongAt:put: */
                    dstLongAtput(dstIndex, destWord);
                    srcIndex += 4;
                    dstIndex += 4;
                }
            }
            srcY += 1;
            dstY += 1;
        }
        return 0;
    }

/*
 * componentAlphaModeColor is the color, sourceWord contains an alpha value for each component of
 * RGB each of which is encoded as0 meaning 0.0 and 255 meaning 1.0 . the rule is...
 *
 * color = componentAlphaModeColor. colorAlpha = componentAlphaModeAlpha. mask = sourceWord. dst.A =
 * colorAlpha + (1 - colorAlpha) * dst.A dst.R = color.R * mask.R * colorAlpha + (1 - (mask.R *
 * colorAlpha)) * dst.R dst.G = color.G * mask.G * colorAlpha + (1 - (mask.G* colorAlpha)) * dst.G
 * dst.B = color.B * mask.B * colorAlpha + (1 - (mask.B* colorAlpha)) * dst.B
 */
/* Do NOT inline this into optimized loops */

    /* BitBltSimulation>>#rgbComponentAlpha32:with: */
    static long rgbComponentAlpha32with(final long sourceWord, final long destinationWord) {
        long a;
        long aA;
        long aB;
        long aG;
        long alpha;
        final long answer;
        long aR;
        long b;
        long d;
        long dstMask;
        long g;
        long r;
        long s;
        final long srcAlpha;
        long srcColor;

        alpha = sourceWord;
        if (alpha == 0) {
            return destinationWord;
        }
        srcColor = componentAlphaModeColor;
        srcAlpha = componentAlphaModeAlpha & 0xFF;
        aB = alpha & 0xFF;
        alpha = (alpha) >> 8;
        aG = alpha & 0xFF;
        alpha = (alpha) >> 8;
        aR = alpha & 0xFF;
        alpha = (alpha) >> 8;
        aA = alpha & 0xFF;
        if (!(srcAlpha == 0xFF)) {
            aA = (aA * srcAlpha) >> 8;
            aR = (aR * srcAlpha) >> 8;
            aG = (aG * srcAlpha) >> 8;
            aB = (aB * srcAlpha) >> 8;
        }
        dstMask = destinationWord;
        d = dstMask & 0xFF;
        s = srcColor & 0xFF;
        if (!(ungammaLookupTable == null)) {
            d = ungammaLookupTable[(int) d];
            s = ungammaLookupTable[(int) s];
        }
        b = ((d * (0xFF - aB)) >> 8) + ((s * aB) >> 8);
        if (b > 0xFF) {
            b = 0xFF;
        }
        if (!(gammaLookupTable == null)) {
            b = gammaLookupTable[(int) b];
        }
        dstMask = (dstMask) >> 8;
        srcColor = (srcColor) >> 8;
        d = dstMask & 0xFF;
        s = srcColor & 0xFF;
        if (!(ungammaLookupTable == null)) {
            d = ungammaLookupTable[(int) d];
            s = ungammaLookupTable[(int) s];
        }
        g = ((d * (0xFF - aG)) >> 8) + ((s * aG) >> 8);
        if (g > 0xFF) {
            g = 0xFF;
        }
        if (!(gammaLookupTable == null)) {
            g = gammaLookupTable[(int) g];
        }
        dstMask = (dstMask) >> 8;
        srcColor = (srcColor) >> 8;
        d = dstMask & 0xFF;
        s = srcColor & 0xFF;
        if (!(ungammaLookupTable == null)) {
            d = ungammaLookupTable[(int) d];
            s = ungammaLookupTable[(int) s];
        }
        r = ((d * (0xFF - aR)) >> 8) + ((s * aR) >> 8);
        if (r > 0xFF) {
            r = 0xFF;
        }
        if (!(gammaLookupTable == null)) {
            r = gammaLookupTable[(int) r];
        }
        dstMask = (dstMask) >> 8;
        srcColor = (srcColor) >> 8;

        /* no need to gamma correct alpha value ? */
        a = (((dstMask & 0xFF) * (0xFF - aA)) >> 8) + aA;
        if (a > 0xFF) {
            a = 0xFF;
        }
        answer = (((((((((((a) << 8)) + r)) << 8)) + g)) << 8)) + b;
        return answer;
    }

/*
 * This version assumes combinationRule = 41 sourcePixSize = 32 destPixSize = 8 sourceForm ~=
 * destForm. Note: This is not real blending since we don't have the source colors available.
 */

    /* BitBltSimulation>>#rgbComponentAlpha8 */
    static long rgbComponentAlpha8() {
        long adjust;
        int deltaX;
        int deltaY;
        long destWord;
        long dstIndex;
        long dstMask;
        long dstValue;
        int dstY;
        final long mapperFlags;
        final long[] mappingTable;
        long sourceWord;
        long srcAlpha;
        long srcIndex;
        long srcShift;
        int srcY;

        /* This particular method should be optimized in itself */
        /* begin default8To32Table */
        mappingTable = default8To32Table;
        mapperFlags = cmFlags & (~ColorMapNewStyle);

        /* So we can pre-decrement */
        deltaY = bbH + 1;
        srcY = sy;
        dstY = dy;
        mask1 = (dx & 3) * 8;
        if (destMSB) {
            mask1 = 24 - mask1;
        }
        mask2 = AllOnes ^ (0xFFL << mask1);
        if ((dx & 1) == 0) {
            adjust = 0;
        } else {
            adjust = 522133279;
        }
        if ((dy & 1) == 0) {
            adjust = adjust ^ 522133279;
        }
        while (((deltaY -= 1)) != 0) {
            adjust = adjust ^ 522133279;
            srcIndex = (sourceBits + (srcY * sourcePitch)) + (sx * 4);
            dstIndex = (destBits + (dstY * destPitch)) + ((dx / 4) * 4);

            /* So we can pre-decrement */
            deltaX = bbW + 1;
            srcShift = mask1;

            /* This is the inner loop */
            dstMask = mask2;
            while (((deltaX -= 1)) != 0) {
                sourceWord = (srcLongAt(srcIndex) & (~adjust)) + adjust;

                /* set srcAlpha to the average of the 3 separate aR,Ag,AB values */
                srcAlpha = sourceWord & 0xFFFFFF;
                srcAlpha = ((((srcAlpha) >> 16) + (((srcAlpha) >> 8) & 0xFF)) + (srcAlpha & 0xFF)) / 3;
                if (srcAlpha > 0x1F) {
                    /* Everything below 31 is transparent */
                    if (srcAlpha > 224) {
                        /* treat everything above 224 as opaque */
                        sourceWord = 0xFFFFFFFFL;
                    }
                    /* begin dstLongAt: */
                    assert (((dstIndex)) < endOfDestination);
                    destWord = ((dstLongAt(dstIndex)));
                    destWord = destWord & (~dstMask);
                    destWord = (destWord) >> srcShift;
                    destWord = mappingTable[(int) destWord];
                    sourceWord = rgbComponentAlpha32with(sourceWord, destWord);
                    sourceWord = mapPixelflags(sourceWord, mapperFlags);

                    /* Store back */
                    sourceWord = ((sourceWord) << srcShift);
                    /* begin dstLongAt:put:mask: */
                    assert (((dstIndex)) < endOfDestination);
                    dstValue = dstLongAt(dstIndex);
                    dstValue = dstValue & dstMask;
                    dstValue = dstValue | sourceWord;
                    /* begin dstLongAt:put: */
                    dstLongAtput(dstIndex, dstValue);
                }
                srcIndex += 4;
                if (destMSB) {
                    if (srcShift == 0) {
                        dstIndex += 4;
                        srcShift = 24;
                        dstMask = 0xFFFFFF;
                    } else {
                        srcShift -= 8;
                        dstMask = ((dstMask) >> 8) | 0xFF000000L;
                    }
                } else {
                    if (srcShift == 32) {
                        dstIndex += 4;
                        srcShift = 0;
                        dstMask = 0xFFFFFF00L;
                    } else {
                        srcShift += 8;
                        dstMask = (((dstMask) << 8)) | 0xFF;
                    }
                }
                adjust = adjust ^ 522133279;
            }
            srcY += 1;
            dstY += 1;
        }
        return 0;
    }

/*
 * componentAlphaModeColor is the color, sourceWord contains an alpha value for each component of
 * RGB each of which is encoded as0 meaning 0.0 and 255 meaning 1.0 . the rule is...
 *
 * color = componentAlphaModeColor. colorAlpha = componentAlphaModeAlpha. mask = sourceWord. dst.A =
 * colorAlpha + (1 - colorAlpha) * dst.A dst.R = color.R * mask.R * colorAlpha + (1 - (mask.R *
 * colorAlpha)) * dst.R dst.G = color.G * mask.G * colorAlpha + (1 - (mask.G* colorAlpha)) * dst.G
 * dst.B = color.B * mask.B * colorAlpha + (1 - (mask.B* colorAlpha)) * dst.B
 */
/* Do NOT inline this into optimized loops */

    /* BitBltSimulation>>#rgbComponentAlpha:with: */
    static long rgbComponentAlphawith(final long sourceWord, final long destinationWord) {
        final long alpha;
        long i;
        long mask;
        long p1;
        long p2;
        long result;
        long v;

        alpha = sourceWord;
        if (alpha == 0) {
            return destinationWord;
        }
        /* begin partitionedRgbComponentAlpha:dest:nBits:nPartitions: */

        /* partition mask starts at the right */
        mask = maskTable[destDepth];
        result = 0;
        for (i = 1; i <= destPPW; i += 1) {
            p1 = (((sourceWord)) & mask) >> ((i - 1) * destDepth);
            p2 = (((destinationWord)) & mask) >> ((i - 1) * destDepth);
            if (!(destDepth == 32)) {
                if (destDepth == 16) {
                    p1 = ((((((p1 & 0x1F)) << 3)) | ((((p1 & 0x3E0)) << 6))) | ((((p1 & 0x7C00)) << 9))) | 0xFF000000L;
                    p2 = ((((((p2 & 0x1F)) << 3)) | ((((p2 & 0x3E0)) << 6))) | ((((p2 & 0x7C00)) << 9))) | 0xFF000000L;
                } else {
                    p1 = (rgbMapfromto(p1, destDepth, 32)) | 0xFF000000L;
                    p2 = (rgbMapfromto(p2, destDepth, 32)) | 0xFF000000L;
                }
            }
            v = rgbComponentAlpha32with(p1, p2);
            if (!(destDepth == 32)) {
                v = rgbMapfromto(v, 32, destDepth);
            }
            result = result | (((v) << ((i - 1) * destDepth)));

            /* slide left to next partition */
            mask = ((mask) << destDepth);
        }
        return result;
    }

/*
 * Subract the pixels in the source and destination, color by color, and return the sum of the
 * absolute value of all the differences. For non-rgb, return the number of differing pixels.
 */

    /* BitBltSimulation>>#rgbDiff:with: */
    static long rgbDiffwith(final long sourceWord, final long destinationWord) {
        final int bitsPerColor;
        long destPixVal;
        long destShifted;
        long diff;
        long i;
        long maskShifted;
        final long pixMask;
        final long rgbMask;
        long sourcePixVal;
        long sourceShifted;

        pixMask = maskTable[destDepth];
        if (destDepth == 16) {
            bitsPerColor = 5;
            rgbMask = 0x1F;
        } else {
            bitsPerColor = 8;
            rgbMask = 0xFF;
        }
        maskShifted = destMask;
        destShifted = destinationWord;
        sourceShifted = sourceWord;
        for (i = 1; i <= destPPW; i += 1) {
            if ((maskShifted & pixMask) > 0) {

                /* Only tally pixels within the destination rectangle */
                destPixVal = destShifted & pixMask;
                sourcePixVal = sourceShifted & pixMask;
                if (destDepth < 16) {
                    if (sourcePixVal == destPixVal) {
                        diff = 0;
                    } else {
                        diff = 1;
                    }
                } else {
                    diff = partitionedSubfromnBitsnPartitions(sourcePixVal, destPixVal, bitsPerColor, 3);
                    diff = ((diff & rgbMask) + (((diff) >> bitsPerColor) & rgbMask)) + ((((diff) >> bitsPerColor) >> bitsPerColor) & rgbMask);
                }
                bitCount += diff;
            }
            maskShifted = (maskShifted) >> destDepth;
            sourceShifted = (sourceShifted) >> destDepth;
            destShifted = (destShifted) >> destDepth;
        }
        return destinationWord;
    }

/*
 * Convert the given 16bit pixel value to a 32bit RGBA value. Note: This method is intended to deal
 * with different source formats.
 */

    /* BitBltSimulation>>#rgbMap16To32: */
    static long rgbMap16To32(final long sourcePixel) {
        return (((((sourcePixel & 0x1F)) << 3)) | ((((sourcePixel & 0x3E0)) << 6))) | ((((sourcePixel & 0x7C00)) << 9));
    }

/*
 * Convert the given 32bit pixel value to a 32bit RGBA value. Note: This method is intended to deal
 * with different source formats.
 */

    /* BitBltSimulation>>#rgbMap32To32: */
    static long rgbMap32To32(final long sourcePixel) {
        return sourcePixel;
    }

/* Perform the RGBA conversion for the given source pixel */

    /* BitBltSimulation>>#rgbMapPixel:flags: */
    static long rgbMapPixelflags(final long sourcePixel, final long mapperFlags) {
        long val;

        val = (((((cmShiftTable[0]))) < 0) ? ((sourcePixel & (cmMaskTable[0])) >> -(((cmShiftTable[0]))))
                        : ((sourcePixel & (cmMaskTable[0])) << (((cmShiftTable[0])))));
        val = val | ((((((cmShiftTable[1]))) < 0) ? ((sourcePixel & (cmMaskTable[1])) >> -(((cmShiftTable[1]))))
                        : ((sourcePixel & (cmMaskTable[1])) << (((cmShiftTable[1]))))));
        val = val | ((((((cmShiftTable[2]))) < 0) ? ((sourcePixel & (cmMaskTable[2])) >> -(((cmShiftTable[2]))))
                        : ((sourcePixel & (cmMaskTable[2])) << (((cmShiftTable[2]))))));
        return val | ((((((cmShiftTable[3]))) < 0) ? ((sourcePixel & (cmMaskTable[3])) >> -(((cmShiftTable[3]))))
                        : ((sourcePixel & (cmMaskTable[3])) << (((cmShiftTable[3]))))));
    }

/*
 * Convert the given pixel value with nBitsIn bits for each color component to a pixel value with
 * nBitsOut bits for each color component. Typical values for nBitsIn/nBitsOut are 3, 5, or 8.
 */

    /* BitBltSimulation>>#rgbMap:from:to: */
    static long rgbMapfromto(final long sourcePixel, final long nBitsIn, final long nBitsOut) {
        long d;
        long destPix;
        long mask;
        long srcPix;

        if (((d = nBitsOut - nBitsIn)) > 0) {

            /* Expand to more bits by zero-fill */

            /* Transfer mask */
            mask = (1L << nBitsIn) - 1;
            srcPix = ((sourcePixel) << d);
            mask = ((mask) << d);
            destPix = srcPix & mask;
            mask = ((mask) << nBitsOut);
            srcPix = ((srcPix) << d);
            return (destPix + (srcPix & mask)) + ((((srcPix) << d)) & (((mask) << nBitsOut)));
        } else {

            /* Compress to fewer bits by truncation */
            if (d == 0) {
                if (nBitsIn == 5) {
                    /*
                     * Sometimes called with 16 bits, though pixel is 15, but we must never return
                     * more than 15.
                     */
                    return sourcePixel & 0x7FFF;
                }
                if (nBitsIn == 8) {
                    /*
                     * Sometimes called with 32 bits, though pixel is 24, but we must never return
                     * more than 24.
                     */
                    return sourcePixel & 0xFFFFFF;
                }
                return sourcePixel;
            }
            if (sourcePixel == 0) {
                return sourcePixel;
            }
            d = nBitsIn - nBitsOut;

            /* Transfer mask */
            mask = (1L << nBitsOut) - 1;
            srcPix = (sourcePixel) >> d;
            destPix = srcPix & mask;
            mask = ((mask) << nBitsOut);
            srcPix = (srcPix) >> d;
            destPix = (destPix + (srcPix & mask)) + (((srcPix) >> d) & (((mask) << nBitsOut)));
            if (destPix == 0) {
                return 1L;
            }
            return destPix;
        }
    }

    /* BitBltSimulation>>#rgbMax:with: */
    static long rgbMaxwith(final long sourceWord, final long destinationWord) {
        if (destDepth < 16) {

            /* Max each pixel separately */
            return partitionedMaxwithnBitsnPartitions(sourceWord, destinationWord, destDepth, destPPW);
        }
        if (destDepth == 16) {

            /* Max RGB components of each pixel separately */
            return (partitionedMaxwithnBitsnPartitions(sourceWord, destinationWord, 5, 3)) +
                            ((((partitionedMaxwithnBitsnPartitions((sourceWord) >> 16, (destinationWord) >> 16, 5, 3))) << 16));
        } else {

            /* Max RGBA components of the pixel separately */
            return partitionedMaxwithnBitsnPartitions(sourceWord, destinationWord, 8, 4);
        }
    }

    /* BitBltSimulation>>#rgbMinInvert:with: */
    static long rgbMinInvertwith(final long wordToInvert, final long destinationWord) {
        final long sourceWord;

        sourceWord = ~wordToInvert;
        if (destDepth < 16) {

            /* Min each pixel separately */
            return partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, destDepth, destPPW);
        }
        if (destDepth == 16) {

            /* Min RGB components of each pixel separately */
            return (partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, 5, 3)) +
                            ((((partitionedMinwithnBitsnPartitions((sourceWord) >> 16, (destinationWord) >> 16, 5, 3))) << 16));
        } else {

            /* Min RGBA components of the pixel separately */
            return partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, 8, 4);
        }
    }

    /* BitBltSimulation>>#rgbMin:with: */
    static long rgbMinwith(final long sourceWord, final long destinationWord) {
        if (destDepth < 16) {

            /* Min each pixel separately */
            return partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, destDepth, destPPW);
        }
        if (destDepth == 16) {

            /* Min RGB components of each pixel separately */
            return (partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, 5, 3)) +
                            ((((partitionedMinwithnBitsnPartitions((sourceWord) >> 16, (destinationWord) >> 16, 5, 3))) << 16));
        } else {

            /* Min RGBA components of the pixel separately */
            return partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, 8, 4);
        }
    }

    /* BitBltSimulation>>#rgbMul:with: */
    static long rgbMulwith(final long sourceWord, final long destinationWord) {
        if (destDepth < 16) {

            /* Mul each pixel separately */
            return partitionedMulwithnBitsnPartitions(sourceWord, destinationWord, destDepth, destPPW);
        }
        if (destDepth == 16) {

            /* Mul RGB components of each pixel separately */
            return (partitionedMulwithnBitsnPartitions(sourceWord, destinationWord, 5, 3)) +
                            ((((partitionedMulwithnBitsnPartitions((sourceWord) >> 16, (destinationWord) >> 16, 5, 3))) << 16));
        } else {

            /* Mul RGBA components of the pixel separately */
            return partitionedMulwithnBitsnPartitions(sourceWord, destinationWord, 8, 4);
        }
    }

    /* BitBltSimulation>>#rgbSub:with: */
    static long rgbSubwith(final long sourceWord, final long destinationWord) {
        if (destDepth < 16) {

            /* Sub each pixel separately */
            return partitionedSubfromnBitsnPartitions(sourceWord, destinationWord, destDepth, destPPW);
        }
        if (destDepth == 16) {

            /* Sub RGB components of each pixel separately */
            return (partitionedSubfromnBitsnPartitions(sourceWord, destinationWord, 5, 3)) +
                            ((((partitionedSubfromnBitsnPartitions((sourceWord) >> 16, (destinationWord) >> 16, 5, 3))) << 16));
        } else {

            /* Sub RGBA components of the pixel separately */
            return partitionedSubfromnBitsnPartitions(sourceWord, destinationWord, 8, 4);
        }
    }

/* Note: This is coded so that it can be run in Squeak. */

    /* InterpreterPlugin>>#setInterpreter: */
    public long setInterpreter() {
        // TODO: remove
        return 0;
    }

/* WARNING: For WarpBlt w/ smoothing the source depth is wrong here! */

    /* BitBltSimulation>>#setupColorMasks */
    static void setupColorMasks() {
        long bits;
        long targetBits;

        bits = (targetBits = 0);
        if (sourceDepth <= 8) {
            return;
        }
        if (sourceDepth == 16) {
            bits = 5;
        }
        if (sourceDepth == 32) {
            bits = 8;
        }
        if (cmBitsPerColor == 0) {
            /* Convert to destDepth */
            if (destDepth <= 8) {
                return;
            }
            if (destDepth == 16) {
                targetBits = 5;
            }
            if (destDepth == 32) {
                targetBits = 8;
            }
        } else {
            targetBits = cmBitsPerColor;
        }
        setupColorMasksFromto(bits, targetBits);
    }

/*
 * Setup color masks for converting an incoming RGB pixel value from srcBits to targetBits.
 */

    /* BitBltSimulation>>#setupColorMasksFrom:to: */
    static void setupColorMasksFromto(final long srcBits, final long targetBits) {
        final int deltaBits;
        final long mask;
        final int[] masks = new int[]{0, 0, 0, 0};
        final int[] shifts = new int[]{0, 0, 0, 0};

        deltaBits = (int) (targetBits - srcBits);
        if (deltaBits == 0) {
            return;
        }
        if (deltaBits <= 0) {
            /* Mask for extracting a color part of the source */
            mask = (1L << targetBits) - 1;
            masks[RedIndex] = (int) (((mask) << ((srcBits * 2) - deltaBits)));
            masks[GreenIndex] = (int) (((mask) << (srcBits - deltaBits)));
            masks[BlueIndex] = (int) (((mask) << (0 - deltaBits)));
            masks[AlphaIndex] = 0;
        } else {
            /* Mask for extracting a color part of the source */
            mask = (1L << srcBits) - 1;
            masks[RedIndex] = (int) (((mask) << (srcBits * 2)));
            masks[GreenIndex] = (int) (((mask) << srcBits));
            masks[BlueIndex] = (int) mask;
        }
        shifts[RedIndex] = (deltaBits * 3);
        shifts[GreenIndex] = (deltaBits * 2);
        shifts[BlueIndex] = deltaBits;
        shifts[AlphaIndex] = 0;
        cmShiftTable = shifts;
        cmMaskTable = masks;
        cmFlags = cmFlags | (ColorMapPresent | ColorMapFixedPart);
        return;
    }

    /* BitBltSimulation>>#showDisplayBits */
    static long showDisplayBits() {
        /* begin ensureDestAndSourceFormsAreValid */
        if (numGCsOnInvocation != (statNumGCs())) {
            reloadDestAndSourceForms();
        }
        showDisplayBitsLeftTopRightBottom(destForm, affectedL, affectedT, affectedR, affectedB);
        return 0;
    }

/*
 * This is only used when source and dest are same depth, ie, when the barrel-shift copy loop is
 * used.
 */

    /* BitBltSimulation>>#sourceSkewAndPointerInit */
    static long sourceSkewAndPointerInit() {
        final long dxLowBits;
        final long m1;
        final long pixPerM1;
        final long startBits;
        final long sxLowBits;

        assert ((destPPW == sourcePPW) && ((destMSB == sourceMSB) && (destDepth == sourceDepth)));

        /* A mask, assuming power of two */
        pixPerM1 = destPPW - 1;
        sxLowBits = sx & pixPerM1;

        /* how many pixels in first word */
        dxLowBits = dx & pixPerM1;
        startBits = (hDir > 0
                        ? sourcePPW - (sx & pixPerM1)
                        : (((sx + bbW) - 1) & pixPerM1) + 1);
        m1 = (destMSB
                        ? (AllOnes) >> (32 - (startBits * destDepth))
                        : ((AllOnes) << (32 - (startBits * destDepth))));

        /* i.e. there are some missing bits */
        /* calculate right-shift skew from source to dest */
        preload = (m1 & mask1) != mask1;

        /* -32..32 */
        skew = destDepth * ((sourceMSB
                        ? sxLowBits - dxLowBits
                        : dxLowBits - sxLowBits));
        if (preload) {
            skew = (skew < 0
                            ? skew + 32
                            : skew - 32);
        }

        /* calculate increments from end of 1 line to start of next */
        sourceIndex = (sourceBits + (sy * sourcePitch)) + ((sx / (32 / sourceDepth)) * 4);
        sourceDelta = (sourcePitch * vDir) - (4 * (nWords * hDir));
        if (preload) {

            /* Compensate for extra source word fetched */
            sourceDelta -= 4 * hDir;
        }
        assert (!((preload && (skew == 0))));
        assert (((skew >= -31) && (skew <= 0x1F)));
        return 0;
    }

    /* BitBltSimulation>>#sourceWord:with: */
    static long

                    sourceWordwith(final long sourceWord, final long destinationWord) {
        return sourceWord;
    }

    /* BitBltSimulation>>#subWord:with: */
    static long subWordwith(final long sourceWord, final long destinationWord) {
        return sourceWord - destinationWord;
    }

/*
 * Tally pixels into the color map. Those tallied are exactly those in the destination rectangle.
 * Note that the source should be specified == destination, in order for the proper color map checks
 * to be performed at setup.
 */

    /* BitBltSimulation>>#tallyIntoMap:with: */
    static long tallyIntoMapwith(final long sourceWord, final long destinationWord) {
        long destShifted;
        long i;
        long mapIndex;
        long maskShifted;
        final long pixMask;
        long pixVal;
        long value;

        if (!((cmFlags & (ColorMapPresent | ColorMapIndexedPart)) == (ColorMapPresent | ColorMapIndexedPart))) {
            return destinationWord;
        }
        pixMask = maskTable[destDepth];
        destShifted = destinationWord;
        maskShifted = destMask;
        for (i = 1; i <= destPPW; i += 1) {
            if (!((maskShifted & pixMask) == 0)) {

                /* Only tally pixels within the destination rectangle */
                pixVal = destShifted & pixMask;
                if (destDepth < 16) {
                    mapIndex = pixVal;
                } else {
                    if (destDepth == 16) {
                        mapIndex = rgbMapfromto(pixVal, 5, cmBitsPerColor);
                    } else {
                        mapIndex = rgbMapfromto(pixVal, 8, cmBitsPerColor);
                    }
                }
                /* begin tallyMapAt:put: */
                final int index = (int) (mapIndex & cmMask);
                value = (cmLookupTable[index]) + 1;
                cmLookupTable[index] = (int) value;
            }
            maskShifted = (maskShifted) >> destDepth;
            destShifted = (destShifted) >> destDepth;
        }
        return destinationWord;
    }

/*
 * Shortcut for stuff that's being run from the balloon engine. Since we do this at each scan line
 * we should avoid the expensive setup for source and destination.
 */
/* We need a source. */

    /* BitBltSimulation>>#tryCopyingBitsQuickly */
    static boolean tryCopyingBitsQuickly() {
        if (noSource) {
            return false;
        }
        if (!((combinationRule == 34) || (combinationRule == 41))) {
            return false;
        }
        if (!(sourceDepth == 32)) {
            return false;
        }
        if (sourceForm == destForm) {
            return false;
        }
        if (combinationRule == 41) {
            if (destDepth == 32) {
                rgbComponentAlpha32();
                affectedL = dx;
                affectedR = dx + bbW;
                affectedT = dy;
                affectedB = dy + bbH;
                return true;
            }
            if (destDepth == 16) {
                rgbComponentAlpha16();
                affectedL = dx;
                affectedR = dx + bbW;
                affectedT = dy;
                affectedB = dy + bbH;
                return true;
            }
            if (destDepth == 8) {
                rgbComponentAlpha8();
                affectedL = dx;
                affectedR = dx + bbW;
                affectedT = dy;
                affectedB = dy + bbH;
                return true;
            }
            return false;
        }
        if (destDepth < 8) {
            return false;
        }
        if ((destDepth == 8) && ((cmFlags & ColorMapPresent) == 0)) {
            return false;
        }
        if (destDepth == 32) {
            alphaSourceBlendBits32();
        }
        if (destDepth == 16) {
            alphaSourceBlendBits16();
        }
        if (destDepth == 8) {
            alphaSourceBlendBits8();
        }
        affectedL = dx;
        affectedR = dx + bbW;
        affectedT = dy;
        affectedB = dy + bbH;
        return true;
    }

/* Unlock the bits of any OS surfaces. */
/*
 * See the comment in lockSurfaces. Similar rules apply. That is, the area provided in
 * ioUnlockSurface can be used to determine the dirty region after drawing. If a source is unlocked,
 * then the area will be (0,0,0,0) to indicate that no portion is dirty. Note that if a GC happens
 * during unlockSourceFn (if it is effectively a callback) no matter. No bits are touched after
 * unlock.
 */

    /* BitBltSimulation>>#unlockSurfaces */
    static void unlockSurfaces() {
        // TODO: remove or uncomment
        // final long destHandle;
        // long destLocked;
        // final long sourceHandle;
        //
        // if (!hasSurfaceLock) {
        // return 0;
        // }
        // if (unlockSurfaceFn == 0) {
        // if (!(loadSurfacePlugin())) {
        // return 0;
        // }
        // }
        // /* begin ensureDestAndSourceFormsAreValid */
        // if (numGCsOnInvocation != (statNumGCs())) {
        // reloadDestAndSourceForms();
        // }
        // destLocked = 0;
        // destHandle = fetchPointerofObject(FormBitsIndex, destForm);
        // if (isIntegerObject(destHandle)) {
        //
        // /* The destBits are always assumed to be dirty */
        // unlockSurfaceFn(integerValueOf(destHandle), affectedL, affectedT, affectedR - affectedL,
        // affectedB - affectedT);
        // destBits = (destPitch = 0);
        // destLocked = 1;
        // }
        // if (!noSource) {
        // /* begin ensureDestAndSourceFormsAreValid */
        // if (numGCsOnInvocation != (statNumGCs())) {
        // reloadDestAndSourceForms();
        // }
        // sourceHandle = fetchPointerofObject(FormBitsIndex, sourceForm);
        // if (isIntegerObject(sourceHandle)) {
        //
        // /* Only unlock sourceHandle if different from destHandle */
        // if (!(destLocked && (sourceHandle == destHandle))) {
        // unlockSurfaceFn(integerValueOf(sourceHandle), 0, 0, 0, 0);
        // }
        // sourcePitch = 0;
        // }
        // }
        // hasSurfaceLock = false;
    }

    /* BitBltSimulation>>#warpBits */
    static void warpBits(final long smoothingCount, final AbstractSqueakObject sourceMap) {
        final boolean ns;

        ns = noSource;
        noSource = true;
        clipRange();
        noSource = ns;
        if (noSource || ((bbW <= 0) || (bbH <= 0))) {

            /* zero width or height; noop */
            affectedL = (affectedR = (affectedT = (affectedB = 0)));
            return;
        }
        if (!(lockSurfaces())) {
            throw new PrimitiveFailed();
        }
        destMaskAndPointerInit();
        warpLoop(smoothingCount, sourceMap);
        if (hDir > 0) {
            affectedL = dx;
            affectedR = dx + bbW;
        } else {
            affectedL = (dx - bbW) + 1;
            affectedR = dx + 1;
        }
        if (vDir > 0) {
            affectedT = dy;
            affectedB = dy + bbH;
        } else {
            affectedT = (dy - bbH) + 1;
            affectedB = dy + 1;
        }
        unlockSurfaces();
    }

/*
 * This version of the inner loop traverses an arbirary quadrilateral source, thus producing a
 * general affine transformation.
 */

    /* BitBltSimulation>>#warpLoop */
    static long warpLoop(final long smoothingCountValue, final AbstractSqueakObject sourceMapOopValue) {
        final long deltaP12x;
        final long deltaP12y;
        final long deltaP43x;
        final long deltaP43y;
        long destWord;
        final int dstShiftInc;
        final int dstShiftLeft;
        final long endBits;
        long halftoneWord;
        long i;
        final long mapperFlags;
        long mergeWord;
        long nPix;
        long nSteps;
        long pAx;
        long pAy;
        long pBx;
        long pBy;
        long skewWord;
        final long smoothingCount;
        final long[] sourceMap;
        long startBits;
        long words;
        long xDelta;
        long yDelta;

        halftoneWord = 0;
        final LongBinaryOperator mergeFnwith = opTable[combinationRule + 1];
        if (!((slotSizeOf(bitBltOop)) >= (BBWarpBase + 12))) {
            throw new PrimitiveFailed();
        }
        nSteps = height - 1;
        if (nSteps <= 0) {
            nSteps = 1;
        }
        pAx = fetchIntOrFloatofObject(BBWarpBase, bitBltOop);
        words = fetchIntOrFloatofObject(BBWarpBase + 3, bitBltOop);
        deltaP12x = deltaFromtonSteps(pAx, words, nSteps);
        if (deltaP12x < 0) {
            pAx = words - (nSteps * deltaP12x);
        }
        pAy = fetchIntOrFloatofObject(BBWarpBase + 1, bitBltOop);
        words = fetchIntOrFloatofObject(BBWarpBase + 4, bitBltOop);
        deltaP12y = deltaFromtonSteps(pAy, words, nSteps);
        if (deltaP12y < 0) {
            pAy = words - (nSteps * deltaP12y);
        }
        pBx = fetchIntOrFloatofObject(BBWarpBase + 9, bitBltOop);
        words = fetchIntOrFloatofObject(BBWarpBase + 6, bitBltOop);
        deltaP43x = deltaFromtonSteps(pBx, words, nSteps);
        if (deltaP43x < 0) {
            pBx = words - (nSteps * deltaP43x);
        }
        pBy = fetchIntOrFloatofObject(BBWarpBase + 10, bitBltOop);
        words = fetchIntOrFloatofObject(BBWarpBase + 7, bitBltOop);
        deltaP43y = deltaFromtonSteps(pBy, words, nSteps);
        if (deltaP43y < 0) {
            pBy = words - (nSteps * deltaP43y);
        }
        if (failed()) {
            return 0;
        }
        if (sourceMapOopValue != null) {
            smoothingCount = smoothingCountValue;
            if (sourceMapOopValue.isNil()) {
                if (sourceDepth < 16) {
                    /* color map is required to smooth non-RGB dest */
                    throw new PrimitiveFailed();
                }
                sourceMap = null;
            } else {
                if (sourceMapOopValue instanceof ArrayObject && (((ArrayObject) sourceMapOopValue).getLongLength() < (1L << sourceDepth))) {
                    /* sourceMap must be long enough for sourceDepth */
                    throw new PrimitiveFailed();
                }
                sourceMap = ((ArrayObject) sourceMapOopValue).getLongStorage();
            }
        } else {
            smoothingCount = 1;
            sourceMap = null;
        }
        nSteps = width - 1;
        if (nSteps <= 0) {
            nSteps = 1;
        }
        startBits = destPPW - (dx & (destPPW - 1));
        endBits = (((dx + bbW) - 1) & (destPPW - 1)) + 1;
        if (bbW < startBits) {
            startBits = bbW;
        }
        if (destY < clipY) {

            /* Advance increments if there was clipping in y */
            pAx += (clipY - destY) * deltaP12x;
            pAy += (clipY - destY) * deltaP12y;
            pBx += (clipY - destY) * deltaP43x;
            pBy += (clipY - destY) * deltaP43y;
        }
        warpLoopSetup();
        if ((smoothingCount > 1) && ((cmFlags & ColorMapNewStyle) == 0)) {
            if (cmLookupTable == null) {
                if (destDepth == 16) {
                    setupColorMasksFromto(8, 5);
                }
            } else {
                setupColorMasksFromto(8, cmBitsPerColor);
            }
        }
        mapperFlags = cmFlags & (~ColorMapNewStyle);
        if (destMSB) {
            dstShiftInc = 0 - destDepth;
            dstShiftLeft = 32 - destDepth;
        } else {
            dstShiftInc = destDepth;
            dstShiftLeft = 0;
        }
        if (noHalftone) {
            halftoneWord = AllOnes;
        }
        for (i = 1; i <= bbH; i += 1) {

            /* here is the vertical loop... */
            xDelta = deltaFromtonSteps(pAx, pBx, nSteps);
            if (xDelta >= 0) {
                sx = (int) pAx;
            } else {
                sx = (int) (pBx - (nSteps * xDelta));
            }
            yDelta = deltaFromtonSteps(pAy, pBy, nSteps);
            if (yDelta >= 0) {
                sy = (int) pAy;
            } else {
                sy = (int) (pBy - (nSteps * yDelta));
            }
            if (destMSB) {
                dstBitShift = 32 - (((dx & (destPPW - 1)) + 1) * destDepth);
            } else {
                dstBitShift = (dx & (destPPW - 1)) * destDepth;
            }
            if (destX < clipX) {

                /* Advance increments if there was clipping in x */
                sx += (clipX - destX) * xDelta;
                sy += (clipX - destX) * yDelta;
            }
            if (!noHalftone) {
                /* begin halftoneAt: */
                halftoneWord = ((halftoneLongAt(halftoneBase + ((((dy + i) - 1) % halftoneHeight) * 4))));
            }
            destMask = mask1;

            /* Here is the inner loop... */
            nPix = startBits;
            words = nWords;
            do {
                if (smoothingCount == 1) {
                    /* Faster if not smoothing */
                    skewWord = warpPickSourcePixelsxDeltahyDeltahxDeltavyDeltavdstShiftIncflags(nPix, xDelta, yDelta, deltaP12x, deltaP12y, dstShiftInc, mapperFlags);
                } else {
                    /* more difficult with smoothing */
                    skewWord = warpPickSmoothPixelsxDeltahyDeltahxDeltavyDeltavsourceMapsmoothingdstShiftInc(nPix, xDelta, yDelta, deltaP12x, deltaP12y, sourceMap, smoothingCount, dstShiftInc);
                }
                dstBitShift = dstShiftLeft;
                if (destMask == AllOnes) {
                    /* avoid read-modify-write */
                    mergeWord = mergeFnwith.applyAsLong(skewWord & halftoneWord, dstLongAt(destIndex));
                    /* begin dstLongAt:put: */
                    dstLongAtput(destIndex, destMask & mergeWord);
                } else {

                    /* General version using dest masking */
                    /* begin dstLongAt: */
                    assert (((destIndex)) < endOfDestination);
                    destWord = ((dstLongAt(destIndex)));
                    mergeWord = mergeFnwith.applyAsLong(skewWord & halftoneWord, destWord & destMask);
                    destWord = (destMask & mergeWord) | (destWord & (~destMask));
                    /* begin dstLongAt:put: */
                    dstLongAtput(destIndex, destWord);
                }
                /* begin incDestIndex: */
                destIndex += 4;
                if (words == 2) {
                    /* e.g., is the next word the last word? */
                    /* set mask for last word in this row */
                    destMask = mask2;
                    nPix = endBits;
                } else {

                    /* use fullword mask for inner loop */
                    destMask = AllOnes;
                    nPix = destPPW;
                }
            } while (!(((words -= 1)) == 0));
            pAx += deltaP12x;
            pAy += deltaP12y;
            pBx += deltaP43x;
            pBy += deltaP43y;
            /* begin incDestIndex: */
            destIndex += destDelta;
        }
        return 0;
    }

/* Setup values for faster pixel fetching. */

    /* BitBltSimulation>>#warpLoopSetup */
    static long warpLoopSetup() {
        long words;

        /* warpSrcShift = log2(sourceDepth) */
        warpSrcShift = 0;

        /* recycle temp */
        words = sourceDepth;
        while (!(words == 1)) {
            warpSrcShift += 1;
            words = (words) >> 1;
        }

        /* warpAlignShift: Shift for aligning x position to word boundary */
        warpSrcMask = maskTable[sourceDepth];

        /* warpAlignMask: Mask for extracting the pixel position from an x position */
        warpAlignShift = 5 - warpSrcShift;

        /* Setup the lookup table for source bit shifts */
        /* warpBitShiftTable: given an sub-word x value what's the bit shift? */
        warpAlignMask = (1L << warpAlignShift) - 1;
        for (int i = 0; i <= warpAlignMask; i += 1) {
            if (sourceMSB) {
                warpBitShiftTable[i] = (int) (32 - (((long) ((i + 1)) << warpSrcShift)));
            } else {
                warpBitShiftTable[i] = (int) (((long) (i) << warpSrcShift));
            }
        }
        return 0;
    }

/*
 * Pick n (sub-) pixels from the source form, mapped by sourceMap, average the RGB values, map by
 * colorMap and return the new word. This version is only called from WarpBlt with smoothingCount >
 * 1
 */

    /*
     * BitBltSimulation>>#warpPickSmoothPixels:xDeltah:yDeltah:xDeltav:yDeltav:sourceMap:smoothing:
     * dstShiftInc:
     */
    static long warpPickSmoothPixelsxDeltahyDeltahxDeltavyDeltavsourceMapsmoothingdstShiftInc(final long nPixels, final long xDeltah, final long yDeltah, final long xDeltav, final long yDeltav,
                    final long[] sourceMap, final long n,
                    final long dstShiftInc) {
        long a;
        long b;
        long destWord;
        final int dstMask;
        long g;
        long i;
        long j;
        long k;
        long nPix;
        long r;
        long rgb;
        int x;
        final long xdh;
        final long xdv;
        int xx;
        int y;
        final long ydh;
        final long ydv;
        int yy;

        /* nope - too much stuff in here */
        dstMask = maskTable[destDepth];
        destWord = 0;
        if (n == 2) {

            /* Try avoiding divides for most common n (divide by 2 is generated as shift) */
            xdh = xDeltah / 2;
            ydh = yDeltah / 2;
            xdv = xDeltav / 2;
            ydv = yDeltav / 2;
        } else {
            xdh = xDeltah / n;
            ydh = yDeltah / n;
            xdv = xDeltav / n;
            ydv = yDeltav / n;
        }
        i = nPixels;
        do {
            x = sx;
            y = sy;

            /* Pick and average n*n subpixels */
            a = (r = (g = (b = 0)));

            /* actual number of pixels (not clipped and not transparent) */
            nPix = 0;
            j = n;
            do {
                xx = x;
                yy = y;
                k = n;
                do {
                    rgb = pickWarpPixelAtXy(xx, yy);
                    if (!((combinationRule == 25) && (rgb == 0))) {
                        /* If not clipped and not transparent, then tally rgb values */
                        nPix += 1;
                        if (sourceDepth < 16) {
                            /* Get RGBA values from sourcemap table */
                            rgb = sourceMap[(int) (((rgb) << 2))];
                        } else {
                            /* Already in RGB format */
                            if (sourceDepth == 16) {
                                /* begin rgbMap16To32: */
                                rgb = (((((rgb & 0x1F)) << 3)) | ((((rgb & 0x3E0)) << 6))) | ((((rgb & 0x7C00)) << 9));
                            } else {
                                /* begin rgbMap32To32: */
                                rgb = rgb;
                            }
                        }
                        b += rgb & 0xFF;
                        g += ((rgb) >> 8) & 0xFF;
                        r += ((rgb) >> 16) & 0xFF;
                        a += (rgb) >> 24;
                    }
                    xx += xdh;
                    yy += ydh;
                } while (!(((k -= 1)) == 0));
                x += xdv;
                y += ydv;
            } while (!(((j -= 1)) == 0));
            if ((nPix == 0) || ((combinationRule == 25) && (nPix < ((n * n) / 2)))) {

                /* All pixels were 0, or most were transparent */
                rgb = 0;
            } else {

                /* normalize rgba sums */
                if (nPix == 4) {

                    /* Try to avoid divides for most common n */
                    r = (r) >> 2;
                    g = (g) >> 2;
                    b = (b) >> 2;
                    a = (a) >> 2;
                } else {
                    r = r / nPix;
                    g = g / nPix;
                    b = b / nPix;
                    a = a / nPix;
                }

                /* map the pixel */
                rgb = (((((a) << 24)) + (((r) << 16))) + (((g) << 8))) + b;
                if (rgb == 0) {

                    /* only generate zero if pixel is really transparent */
                    if ((((r + g) + b) + a) > 0) {
                        rgb = 1;
                    }
                }
                rgb = mapPixelflags(rgb, cmFlags);
            }
            destWord = destWord | ((((rgb & dstMask)) << dstBitShift));
            dstBitShift += dstShiftInc;
            sx += xDeltah;
            sy += yDeltah;
        } while (!(((i -= 1)) == 0));
        return destWord;
    }

/*
 * Pick n pixels from the source form, map by colorMap and return aligned by dstBitShift. This
 * version is only called from WarpBlt with smoothingCount = 1
 */

    /* BitBltSimulation>>#warpPickSourcePixels:xDeltah:yDeltah:xDeltav:yDeltav:dstShiftInc:flags: */
    static long warpPickSourcePixelsxDeltahyDeltahxDeltavyDeltavdstShiftIncflags(final long nPixels, final long xDeltah, final long yDeltah, final long xDeltav, final long yDeltav,
                    final long dstShiftInc, final long mapperFlags) {
        long destPix;
        long destWord;
        final int dstMask;
        long nPix;
        long sourcePix;

        /* Yepp - this should go into warpLoop */
        dstMask = maskTable[destDepth];
        destWord = 0;
        nPix = nPixels;
        if (mapperFlags == (ColorMapPresent | ColorMapIndexedPart)) {

            /* a little optimization for (pretty crucial) blits using indexed lookups only */
            /* grab, colormap and mix in pixel */
            do {
                sourcePix = pickWarpPixelAtXy(sx, sy);
                destPix = cmLookupTable[(int) (sourcePix & cmMask)];
                destWord = destWord | ((((destPix & dstMask)) << dstBitShift));
                dstBitShift += dstShiftInc;
                sx += xDeltah;
                sy += yDeltah;
            } while (!(((nPix -= 1)) == 0));
        } else {

            /* grab, colormap and mix in pixel */
            do {
                sourcePix = pickWarpPixelAtXy(sx, sy);
                destPix = mapPixelflags(sourcePix, mapperFlags);
                destWord = destWord | ((((destPix & dstMask)) << dstBitShift));
                dstBitShift += dstShiftInc;
                sx += xDeltah;
                sy += yDeltah;
            } while (!(((nPix -= 1)) == 0));
        }
        return destWord;
    }

    /*
     * POLYFILLS
     */

    private static int fetchIntegerofObject(final int index, final PointersObject object) {
        return (int) (long) fetchPointerofObject(index, object);
    }

    private static int fetchIntOrFloatofObjectifNil(final int index, final PointersObject object, final int defaultValue) {
        final Object value = object.at0(index);
        if (value == object.image.nil) {
            return defaultValue;
        } else if (value instanceof Long) {
            return (int) (long) value;
        } else if (value instanceof FloatObject) {
            return (int) ((FloatObject) value).getValue();
        } else if (value instanceof Double) {
            return (int) (double) value;
        } else {
            CompilerDirectives.transferToInterpreter();
            throw new SqueakException("Should not be reached");
        }
    }

    private static PointersObject fetchPointerofObjectOrNull(final int index, final PointersObject object) {
        final Object value = fetchPointerofObject(index, object);
        if (value == object.image.nil) {
            return null;
        } else {
            return (PointersObject) value;
        }
    }

    private static NativeObject fetchNativeofObjectOrNull(final int index, final PointersObject object) {
        final Object value = fetchPointerofObject(index, object);
        if (value == object.image.nil) {
            return null;
        } else {
            return (NativeObject) value;
        }
    }

    private static Object fetchPointerofObject(final int index, final PointersObject object) {
        return object.at0(index);
    }

    private static boolean isBytes(final NativeObject object) {
        return object.isByteType();
    }

    private static boolean isWords(final NativeObject object) {
        return object.isIntType();
    }

    private static boolean isWordsOrBytes(final NativeObject object) {
        return isWords(object) || isBytes(object);
    }

    private static boolean isWordsOrBytes(final Object object) {
        return SqueakGuards.isNativeObject(object) && isWordsOrBytes((NativeObject) object);
    }

    private static int slotSizeOfWords(final NativeObject object) {
        return object.getIntLength();
    }

    private static int slotSizeOf(final PointersObject object) {
        return object.size();
    }

    private static int slotSizeOf(final ArrayObject object) {
        return object.getLongLength();
    }

    private static boolean isPointers(final Object object) {
        return object != null && object instanceof PointersObject;
    }

    private static Object nilObject() {
        return bitBltOop.image.nil;
    }

    private static boolean isArray(final ArrayObject xTable) {
        return true;
    }

    private static boolean failed() {
        return false;
    }

    private static void storeIntegerofObjectwithValue(final int index, final PointersObject target, final long value) {
        target.atput0(index, value);
    }

    private static long dstLongAt(final long index) {
        if (destWords == null) {
            return Byte.toUnsignedLong(destBytes[(int) index]);
        } else {
            return Integer.toUnsignedLong(destWords[(int) index >>> 2]);
        }
    }

    private static void dstLongAtput(final long index, final long value) {
        if (destWords == null) {
            destBytes[(int) index] = (byte) value;
        } else {
            destWords[(int) index >>> 2] = (int) value;
        }
    }

    private static long halftoneLongAt(final long index) {
        return Integer.toUnsignedLong(halftoneWords[(int) index]);
    }

    private static long srcLongAt(final long index) {
        if (sourceWords == null) {
            return Byte.toUnsignedLong(sourceBytes[(int) index]);
        } else {
            return Integer.toUnsignedLong(sourceWords[(int) index >>> 2]);
        }
    }

    private static int[] lockSurfaceFn(final long sourceHandle, final int sourcePitch, final int i, final int j, final int sourceWidth, final int sourceHeight) {
        throw new SqueakException("Not yet implemented");
    }

    private static void showDisplayBitsLeftTopRightBottom(final PointersObject destForm, final long left, final long top, final long right, final long bottom) {
        // TODO: check that destForm is display here.
        destForm.image.getDisplay().forceRect((int) left, (int) right, (int) top, (int) bottom);
    }

    private static long statNumGCs() {
        // TODO Auto-generated method stub
        return 0;
    }
}
